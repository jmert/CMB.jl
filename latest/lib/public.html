<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public · CMB Analysis</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>CMB Analysis</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">CMB.jl Documentation</a></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../man/healpix.html">HEALPix Pixelization</a></li><li><a class="toctext" href="../man/legendre.html">Legendre Polynomials</a></li><li><a class="toctext" href="../man/references.html">References</a></li></ul></li><li><span class="toctext">API Reference</span><ul><li class="current"><a class="toctext" href="public.html">Public</a><ul class="internal"><li><a class="toctext" href="#Contents-1">Contents</a></li><li><a class="toctext" href="#Sphere-Functions-1">Sphere Functions</a></li><li><a class="toctext" href="#Legendre-Functions-1">Legendre Functions</a></li><li><a class="toctext" href="#Healpix-1">Healpix</a></li><li><a class="toctext" href="#Pixel-Covariance-1">Pixel Covariance</a></li><li><a class="toctext" href="#Miscellaneous-Utilities-1">Miscellaneous Utilities</a></li></ul></li><li><a class="toctext" href="private.html">Private</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>API Reference</li><li><a href="public.html">Public</a></li></ul><a class="edit-page" href="https://github.com/jmert/CMB.jl/blob/master/docs/src/lib/public.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Public</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Public-Documentation-1" href="#Public-Documentation-1">Public Documentation</a></h1><h2><a class="nav-anchor" id="Contents-1" href="#Contents-1">Contents</a></h2><ul><li><a href="public.html#Public-Documentation-1">Public Documentation</a></li><ul><li><a href="public.html#Contents-1">Contents</a></li><li><a href="public.html#Sphere-Functions-1">Sphere Functions</a></li><li><a href="public.html#Legendre-Functions-1">Legendre Functions</a></li><li><a href="public.html#Healpix-1">Healpix</a></li><li><a href="public.html#Pixel-Covariance-1">Pixel Covariance</a></li><li><a href="public.html#Miscellaneous-Utilities-1">Miscellaneous Utilities</a></li></ul></ul><h2><a class="nav-anchor" id="Sphere-Functions-1" href="#Sphere-Functions-1">Sphere Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Sphere" href="#CMB.Sphere"><code>CMB.Sphere</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Collection of routines for working with coordinates on the sphere.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/sphere.jl#L1-L3">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Sphere.bearing" href="#CMB.Sphere.bearing"><code>CMB.Sphere.bearing</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculates the bearing angle (<span>$α$</span>), defined as the angle between the meridian (at the first coordinate) and the great circle connecting the first coordinate to the second. Angles are measured clockwise and will be in the range <span>$[0,π)$</span>. See also <a href="public.html#CMB.Sphere.bearing2"><code>bearing2</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/sphere.jl#L62-L66">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Sphere.bearing-NTuple{4,Any}" href="#CMB.Sphere.bearing-NTuple{4,Any}"><code>CMB.Sphere.bearing</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">α = bearing(θ₁, ϕ₁, θ₂, ϕ₂)</code></pre><p>Points on the sphere are given as coordinate pairs <span>$(θ₁,ϕ₁)$</span> and <span>$(θ₂,ϕ₂)$</span> where <span>$θ$</span> is the colatitude angle from the North Pole and <span>$ϕ$</span> is the azimuthal angle, both in radians.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; bearing(π/2, 0.0, π/4, π/4)
0.6154797086703871</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/sphere.jl#L69-L81">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Sphere.bearing-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#CMB.Sphere.bearing-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>CMB.Sphere.bearing</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">α = bearing(r₁, r₂)</code></pre><p>Points on the sphere are given as unit vectors <span>$r₁$</span> and <span>$r₂$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; bearing([1.0, 0.0, 0.0], [0.5, 0.5, sqrt(2)/2])
0.6154797086703873</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/sphere.jl#L111-L121">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Sphere.bearing2" href="#CMB.Sphere.bearing2"><code>CMB.Sphere.bearing2</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculates the latitude/longitude vector components of the bearing angle (i.e. <span>$δθ = \cos(α), δϕ = \sin(α)$</span>), defined as the angle between the meridian (at the first coordinate) and the great circle connecting the first coordinate to the second. See also <a href="public.html#CMB.Sphere.bearing"><code>bearing</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/sphere.jl#L137-L142">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Sphere.bearing2-NTuple{4,Any}" href="#CMB.Sphere.bearing2-NTuple{4,Any}"><code>CMB.Sphere.bearing2</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(δθ, δϕ) = bearing2(θ₁, ϕ₁, θ₂, ϕ₂)</code></pre><p>Points on the sphere are given as coordinate pairs <span>$(θ₁,ϕ₁)$</span> and <span>$(θ₂,ϕ₂)$</span> where <span>$θ$</span> is the colatitude angle from the North Pole and <span>$ϕ$</span> is the azimuthal angle, both in radians.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; bearing2(π/2, 0.0, π/4, π/4)
(0.8164965809277261, 0.5773502691896256)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/sphere.jl#L145-L157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Sphere.bearing2-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#CMB.Sphere.bearing2-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>CMB.Sphere.bearing2</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(δθ, δϕ) = bearing2(r₁, r₂)</code></pre><p>Points on the sphere are given as unit vectors <span>$r₁$</span> and <span>$r₂$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; bearing2([1.0, 0.0, 0.0], [0.5, 0.5, sqrt(2)/2])
(0.816496580927726, 0.5773502691896257)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/sphere.jl#L189-L199">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Sphere.cosdistance" href="#CMB.Sphere.cosdistance"><code>CMB.Sphere.cosdistance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculates the cosine of the inner angle (<span>$z$</span>) between unit vectors pointing from the center of the sphere to two points on its surface.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/sphere.jl#L274-L277">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Sphere.cosdistance-NTuple{4,Any}" href="#CMB.Sphere.cosdistance-NTuple{4,Any}"><code>CMB.Sphere.cosdistance</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">z = cosdistance(θ₁, ϕ₁, θ₂, ϕ₂)</code></pre><p>Points on the sphere are given as coordinate pairs <span>$(θ₁,ϕ₁)$</span> and <span>$(θ₂,ϕ₂)$</span> where <span>$θ$</span> is the colatitude angle from the North Pole and <span>$ϕ$</span> is the azimuthal angle, both in radians.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; cosdistance(π/2, 0.0, π/4, π/4)
0.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/sphere.jl#L280-L292">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Sphere.cosdistance-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#CMB.Sphere.cosdistance-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>CMB.Sphere.cosdistance</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">z = cosdistance(r₁, r₂)</code></pre><p>Points on the sphere are given as unit vectors <span>$r₁$</span> and <span>$r₂$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; cosdistance([1.,0.,0.], [0.5,0.5,sqrt(2)/2])
0.5</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/sphere.jl#L318-L328">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Sphere.distance" href="#CMB.Sphere.distance"><code>CMB.Sphere.distance</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Calculates the inner angle (<span>$σ$</span>) between unit vectors pointing from the center of the sphere to two points on its surface.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/sphere.jl#L215-L218">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Sphere.distance-NTuple{4,Any}" href="#CMB.Sphere.distance-NTuple{4,Any}"><code>CMB.Sphere.distance</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">σ = distance(θ₁, ϕ₁, θ₂, ϕ₂)</code></pre><p>Points on the sphere are given as coordinate pairs <span>$(θ₁,ϕ₁)$</span> and <span>$(θ₂,ϕ₂)$</span> where <span>$θ$</span> is the colatitude angle from the North Pole and <span>$ϕ$</span> is the azimuthal angle, both in radians.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; distance(π/2, 0.0, π/4, π/4)
1.0471975511965979</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/sphere.jl#L221-L233">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Sphere.distance-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#CMB.Sphere.distance-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>CMB.Sphere.distance</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">σ = distance(r₁, r₂)</code></pre><p>Points on the sphere are given as unit vectors <span>$r₁$</span> and <span>$r₂$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; distance([1.,0.,0.], [0.5,0.5,sqrt(2)/2])
1.0471975511965979</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/sphere.jl#L259-L269">source</a></section><h2><a class="nav-anchor" id="Legendre-Functions-1" href="#Legendre-Functions-1">Legendre Functions</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Legendre" href="#CMB.Legendre"><code>CMB.Legendre</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Collections of functions which compute the associated Legendre functions.</p><p>Based on implementation described in Limpanuparb and Milthorpe (2014) <em>“Associated Legendre Polynomials and Spherical Harmonics Computation for Chemistry Applications”</em> arXiv:1410.1748v1</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/legendre.jl#L1-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Legendre.AbstractLegendreNorm" href="#CMB.Legendre.AbstractLegendreNorm"><code>CMB.Legendre.AbstractLegendreNorm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">abstract type AbstractLegendreNorm end</code></pre><p>Abstract supertype for normalization conditions of the Associated Legendre polynomials.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; subtypes(AbstractLegendreNorm)
3-element Array{Union{DataType, UnionAll},1}:
 CMB.Legendre.LegendreNormCoeff
 CMB.Legendre.LegendreSphereNorm
 CMB.Legendre.LegendreUnitNorm</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/legendre.jl#L26-L39">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Legendre.LegendreNormCoeff" href="#CMB.Legendre.LegendreNormCoeff"><code>CMB.Legendre.LegendreNormCoeff</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct LegendreNormCoeff{N&lt;:AbstractLegendreNorm,T&lt;:Real} &lt;: AbstractLegendreNorm</code></pre><p>Precomputed recursion relation coefficients for the normalization <code>N</code> and value type <code>T</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; LegendreNormCoeff{LegendreSphereNorm,Float64}(1)
CMB.Legendre.LegendreNormCoeff{CMB.Legendre.LegendreSphereNorm,Float64} for lmax = 1, mmax = 1 with coefficients:
    μ: [0.0, 1.22474]
    ν: [1.73205, 2.23607]
    α: [0.0 0.0; 1.73205 0.0]
    β: [0.0 0.0; -0.0 0.0]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/legendre.jl#L52-L67">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Legendre.LegendreSphereCoeff" href="#CMB.Legendre.LegendreSphereCoeff"><code>CMB.Legendre.LegendreSphereCoeff</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LegendreSphereCoeff{T}</code></pre><p>Table type of precomputed recursion relation coefficients for the spherical harmonic normalization. Alias for <code>LegendreNormCoeff{LegendreSphereNorm,T}</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/legendre.jl#L117-L122">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Legendre.LegendreSphereNorm" href="#CMB.Legendre.LegendreSphereNorm"><code>CMB.Legendre.LegendreSphereNorm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct LegendreSphereNorm &lt;: AbstractLegendreNorm end</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/legendre.jl#L47-L49">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Legendre.LegendreUnitCoeff" href="#CMB.Legendre.LegendreUnitCoeff"><code>CMB.Legendre.LegendreUnitCoeff</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">LegendreUnitCoeff{T}</code></pre><p>Precomputed recursion relation coefficients for the standard unit normalization. Alias for <code>LegendreNormCoeff{LegendreUnitNorm,T}</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/legendre.jl#L109-L114">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Legendre.LegendreUnitNorm" href="#CMB.Legendre.LegendreUnitNorm"><code>CMB.Legendre.LegendreUnitNorm</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct LegendreUnitNorm &lt;: AbstractLegendreNorm end</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/legendre.jl#L42-L44">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Legendre.Nlm-Union{Tuple{T}, Tuple{Type{T},Integer,Integer}} where T" href="#CMB.Legendre.Nlm-Union{Tuple{T}, Tuple{Type{T},Integer,Integer}} where T"><code>CMB.Legendre.Nlm</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">N = Nlm([T=Float64], l, m)</code></pre><p>Computes the normalization constant</p><div>\[    N_ℓ^m ≡ \sqrt{\frac{2ℓ+1}{4π} \frac{(ℓ-m)!}{(ℓ+m)!}}\]</div><p>which defines the Spherical Harmonic normalized functions <span>$λ_ℓ^m(x)$</span> in terms of the standard unit normalized <span>$P_ℓ^m(x)$</span></p><div>\[    λ_ℓ^m(x) ≡ N_ℓ^m P_ℓ^m(x)\]</div><p>using numbers of type <code>T</code>.</p><p>See also <a href="public.html#CMB.Legendre.Plm-Tuple{Integer,Integer,Any}"><code>Plm</code></a> and <a href="public.html#CMB.Legendre.λlm-Tuple{Integer,Integer,Any}"><code>λlm</code></a>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/legendre.jl#L528-L543">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Legendre.Pl!-Tuple{AbstractArray{T,1} where T,Integer,Any}" href="#CMB.Legendre.Pl!-Tuple{AbstractArray{T,1} where T,Integer,Any}"><code>CMB.Legendre.Pl!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Pl!(P::AbstractVector, lmax::Integer, x)</code></pre><p>Fills the vector <code>P</code> with the Legendre polynomial values <span>$P_ℓ(x)$</span> for all degrees <code>0 ≤ ℓ ≤ lmax</code> at <code>x</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/legendre.jl#L481-L486">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Legendre.Pl-Tuple{Integer,Any}" href="#CMB.Legendre.Pl-Tuple{Integer,Any}"><code>CMB.Legendre.Pl</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">p = Pl(l::Integer, x)</code></pre><p>Computes the scalar value <span>$p = P_ℓ(x)$</span>, where <span>$P_ℓ(x)$</span> is the Legendre polynomial of degree <code>l</code> at <code>x</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/legendre.jl#L457-L462">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Legendre.Plm!-Tuple{AbstractArray{T,1} where T,Integer,Integer,Any}" href="#CMB.Legendre.Plm!-Tuple{AbstractArray{T,1} where T,Integer,Integer,Any}"><code>CMB.Legendre.Plm!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Plm!(P::AbstractVector, lmax::Integer, m::Integer, x)</code></pre><p>Fills the vector <code>P</code> with the Legendre polynomial values <span>$P_ℓ^m(x)$</span> for all degrees <code>0 ≤ ℓ ≤ lmax</code> and constant order <code>m</code> at <code>x</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/legendre.jl#L490-L495">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Legendre.Plm!-Tuple{AbstractArray{T,2} where T,Integer,Integer,Any}" href="#CMB.Legendre.Plm!-Tuple{AbstractArray{T,2} where T,Integer,Integer,Any}"><code>CMB.Legendre.Plm!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Plm!(P::AbstractMatrix, lmax::Integer, mmax::Integer, x)</code></pre><p>Fills the lower triangle of the matrix <code>P</code> with the associated Legendre polynomial values <span>$P_ℓ^m(x)$</span> for all degrees <code>0 ≤ ℓ ≤ lmax</code> and all orders <code>0 ≤ m ≤ ℓ</code> at <code>x</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/legendre.jl#L500-L505">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Legendre.Plm-Tuple{Integer,Integer,Any}" href="#CMB.Legendre.Plm-Tuple{Integer,Integer,Any}"><code>CMB.Legendre.Plm</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">p = Plm(l::Integer, m::Integer, x)</code></pre><p>Computes the scalar value <span>$p = P_ℓ^m(x)$</span>, where <span>$P_ℓ^m(x)$</span> is the associated Legendre polynomial of degree <code>l</code> and order <code>m</code> at <code>x</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/legendre.jl#L465-L470">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Legendre.legendre!-Tuple{AbstractLegendreNorm,AbstractArray{T,2} where T,Integer,Integer,Any}" href="#CMB.Legendre.legendre!-Tuple{AbstractLegendreNorm,AbstractArray{T,2} where T,Integer,Integer,Any}"><code>CMB.Legendre.legendre!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">legendre!(norm::AbstractLegendreNorm, P::AbstractMatrix, lmax::Integer, mmax::Integer, x)</code></pre><p>Fills the matrix <code>Λ</code> with the pre-normalized Legendre polynomial values <span>$N_ℓ^m P_ℓ^m(x)$</span> for all degrees <code>0 ≤ ℓ ≤ lmax</code> and all orders <code>0 ≤ m ≤ ℓ</code> at <code>x</code>, where <span>$N_ℓ^m$</span> is the normalization scheme <code>norm</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/legendre.jl#L427-L433">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Legendre.legendre!-Union{Tuple{T}, Tuple{AbstractLegendreNorm,AbstractArray{T,1} where T,Integer,Integer,Any}} where T" href="#CMB.Legendre.legendre!-Union{Tuple{T}, Tuple{AbstractLegendreNorm,AbstractArray{T,1} where T,Integer,Integer,Any}} where T"><code>CMB.Legendre.legendre!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">legendre!(norm::AbstractLegendreNorm, Λ::AbstractVector, lmax::Integer, m::Integer, x)</code></pre><p>Fills the vector <code>Λ</code> with the pre-normalized Legendre polynomial values <span>$N_ℓ^m P_ℓ^m(x)$</span> for all degrees <code>0 ≤ ℓ ≤ lmax</code> and constant order <code>m</code> at <code>x</code>, where <span>$N_ℓ^m$</span> is the normalization scheme <code>norm</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/legendre.jl#L414-L420">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Legendre.legendre-Tuple{AbstractLegendreNorm,Integer,Any}" href="#CMB.Legendre.legendre-Tuple{AbstractLegendreNorm,Integer,Any}"><code>CMB.Legendre.legendre</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">p = legendre(norm::AbstractLegendreNorm, l::Integer, x)</code></pre><p>Computes the scalar value <span>$p = N_ℓ P_ℓ(x)$</span>, where <span>$P_ℓ(x)$</span> is the Legendre polynomial of degree <code>l</code> at <code>x</code> and <span>$N_ℓ$</span> is the normalization scheme <code>norm</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/legendre.jl#L388-L393">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Legendre.legendre-Tuple{AbstractLegendreNorm,Integer,Integer,Any}" href="#CMB.Legendre.legendre-Tuple{AbstractLegendreNorm,Integer,Integer,Any}"><code>CMB.Legendre.legendre</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">p = legendre(norm::AbstractLegendreNorm, l::Integer, m::Integer, x)</code></pre><p>Computes the scalar value <span>$p = N_ℓ^m P_ℓ^m(x)$</span>, where <span>$P_ℓ^m(x)$</span> is the associated Legendre polynomial of degree <code>l</code> and order <code>m</code> at <code>x</code> and <span>$N_ℓ^m$</span> the normalization scheme <code>norm</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/legendre.jl#L400-L406">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Legendre.λlm!-Tuple{AbstractArray{T,1} where T,Integer,Integer,Any}" href="#CMB.Legendre.λlm!-Tuple{AbstractArray{T,1} where T,Integer,Integer,Any}"><code>CMB.Legendre.λlm!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">λlm!(Λ::AbstractVector, lmax::Integer, m::Integer, x)</code></pre><p>Fills the vector <code>Λ</code> with the spherical harmonic normalized associated Legendre polynomial values <span>$λ_ℓ^m(x)$</span> for all degrees <code>0 ≤ ℓ ≤ lmax</code> and constant order <code>m</code> at <code>x</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/legendre.jl#L509-L514">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Legendre.λlm!-Tuple{AbstractArray{T,2} where T,Integer,Integer,Any}" href="#CMB.Legendre.λlm!-Tuple{AbstractArray{T,2} where T,Integer,Integer,Any}"><code>CMB.Legendre.λlm!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">λlm!(Λ::AbstractMatrix, lmax::Integer, mmax::Integer, x::Real)</code></pre><p>Fills the lower triangle of the matrix <code>Λ</code> with the spherical harmonic normalized associated Legendre polynomial values <span>$Λ_ℓ^m(x)$</span> for all degrees <code>0 ≤ ℓ ≤ lmax</code> and all orders <code>0 ≤ m ≤ ℓ</code> at <code>x</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/legendre.jl#L518-L524">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Legendre.λlm-Tuple{Integer,Integer,Any}" href="#CMB.Legendre.λlm-Tuple{Integer,Integer,Any}"><code>CMB.Legendre.λlm</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">λ = λlm(l::Integer, m::Integer, x)</code></pre><p>Computes the scalar value <span>$λ = λ_ℓ^m(x)$</span>, where <span>$λ_ℓ^m(x)$</span> is the spherical-harmonic normalized associated Legendre polynomial of degree <code>l</code> and order <code>m</code> at <code>x</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/legendre.jl#L473-L478">source</a></section><h2><a class="nav-anchor" id="Healpix-1" href="#Healpix-1">Healpix</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix" href="#CMB.Healpix"><code>CMB.Healpix</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>A module of functions implementing function which interact with the HEALPix pixel definitions. In most cases, only the RING ordering functions are being provided.</p><p>See &quot;HEALPix: A Framework for High-Resolution Discretization and Fast Analysis of Data Distributed on the Sphere&quot; Górski, Hivon, &amp; Banday et al (2005) ApJ 622:759–771 arXiv: astro-ph/0409513</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L1-L8">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.UNSEEN" href="#CMB.Healpix.UNSEEN"><code>CMB.Healpix.UNSEEN</code></a> — <span class="docstring-category">Constant</span>.</div><div><div><pre><code class="language-none">const UNSEEN = -1.6375e+30</code></pre><p>Special value recognized by the libhealpix/healpy routines as an unobserved/masked pixel.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L22-L27">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.InvalidNside" href="#CMB.Healpix.InvalidNside"><code>CMB.Healpix.InvalidNside</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">InvalidNside(nside)</code></pre><p>An invalid <code>nside</code> value was provided.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L37-L41">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.InvalidPixel" href="#CMB.Healpix.InvalidPixel"><code>CMB.Healpix.InvalidPixel</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">InvalidPixel(nside, pix)</code></pre><p>An invalid pixel index <code>pix</code> was provided for the given <code>nside</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L48-L52">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.checkhealpix-Tuple{Any,Any}" href="#CMB.Healpix.checkhealpix-Tuple{Any,Any}"><code>CMB.Healpix.checkhealpix</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">checkhealpix(nside, pix)</code></pre><p>Throws an <a href="public.html#CMB.Healpix.InvalidNside"><code>InvalidNside</code></a> exception if <code>nside</code> is not a valid value or an <a href="public.html#CMB.Healpix.InvalidPixel"><code>InvalidPixel</code></a> exception if <code>pix</code> is out of range for the given <span>$N_\mathrm{side}$</span>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L90-L96">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.checkhealpix-Tuple{Any}" href="#CMB.Healpix.checkhealpix-Tuple{Any}"><code>CMB.Healpix.checkhealpix</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">checkhealpix(nside)</code></pre><p>Throws an <a href="public.html#CMB.Healpix.InvalidNside"><code>InvalidNside</code></a> exception if <code>nside</code> is not a valid value.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L80-L84">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.iscap" href="#CMB.Healpix.iscap"><code>CMB.Healpix.iscap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">iscap(nside, pix)</code></pre><p>Test for whether the given pixel <code>pix</code> is in either polar cap for an <code>nside</code> HEALPix map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L187-L192">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.isequbelt" href="#CMB.Healpix.isequbelt"><code>CMB.Healpix.isequbelt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isequbelt(nside, pix)</code></pre><p>Test for whether the given pixel <code>pix</code> is in the equatorial belt for an <code>nside</code> HEALPix map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L208-L213">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.ishealpixok-Tuple{Any,Any}" href="#CMB.Healpix.ishealpixok-Tuple{Any,Any}"><code>CMB.Healpix.ishealpixok</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">isheapixok(nside, pix)</code></pre><p>Returns <code>true</code> if <code>nside</code> is valid and <code>pix</code> is in the range <code>0</code> to <code>nside2npix(nside) - 1</code>, otherwise <code>false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L72-L77">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.ishealpixok-Tuple{Any}" href="#CMB.Healpix.ishealpixok-Tuple{Any}"><code>CMB.Healpix.ishealpixok</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ishealpixok(nside)</code></pre><p>Returns <code>true</code> if <code>nside</code> is a power of two in the range <code>1</code> to <code>2^29</code>, otherwise <code>false</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L64-L69">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.isnorth" href="#CMB.Healpix.isnorth"><code>CMB.Healpix.isnorth</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isnorth(nside, pix)</code></pre><p>Test for whether the given pixel <code>pix</code> is in the northern hemisphere (including the equatorial ring) for an <code>nside</code> HEALPix map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L215-L220">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.isnorthcap" href="#CMB.Healpix.isnorthcap"><code>CMB.Healpix.isnorthcap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isnorthcap(nside, pix)</code></pre><p>Test for whether the given pixel <code>pix</code> is in the northern polar cap for an <code>nside</code> HEALPix map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L173-L178">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.isnorthequbelt" href="#CMB.Healpix.isnorthequbelt"><code>CMB.Healpix.isnorthequbelt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isnorthequbelt(nside, pix)</code></pre><p>Test for whether the given pixel <code>pix</code> is in the northern equatorial belt (including the equatorial ring) for an <code>nside</code> HEALPix map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L194-L199">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.issouth" href="#CMB.Healpix.issouth"><code>CMB.Healpix.issouth</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">issouth(nside, pix)</code></pre><p>Test for whether the given pixel <code>pix</code> is in the southern hemisphere (excluding the equatorial ring) for an <code>nside</code> HEALPix map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L222-L227">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.issouthcap" href="#CMB.Healpix.issouthcap"><code>CMB.Healpix.issouthcap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">issouthcap(nside, pix)</code></pre><p>Test for whether the given pixel <code>pix</code> is in the southern polar cap for an <code>nside</code> HEALPix map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L180-L185">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.issouthequbelt" href="#CMB.Healpix.issouthequbelt"><code>CMB.Healpix.issouthequbelt</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">issouthequbelt(nside, pix)</code></pre><p>Test for whether the given pixel <code>pix</code> is in the southern equatorial belt (excluding the equatorial ring) for an <code>nside</code> HEALPix map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L201-L206">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.npix2nside-Tuple{Any}" href="#CMB.Healpix.npix2nside-Tuple{Any}"><code>CMB.Healpix.npix2nside</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Nisde = npix2nside(npix)</code></pre><p>Returns the equivalent <code>Nside</code> corresponding to the number of pixels <code>npix</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L128-L132">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.nring2nside-Tuple{Any}" href="#CMB.Healpix.nring2nside-Tuple{Any}"><code>CMB.Healpix.nring2nside</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">Nside = nring2nside(nring)</code></pre><p>Returns the equivalent <code>Nside</code> corresponding to the number of iso-latitude rings <code>nring</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L134-L138">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.nside2npix" href="#CMB.Healpix.nside2npix"><code>CMB.Healpix.nside2npix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Npix = nside2npix(nside)</code></pre><p>Returns the total number of pixels <code>Npix</code> in an <code>nside</code> HEALPix map. Note that <code>HEALPix</code> pixel indexing is 0-based, so valid pixel values are in the range <code>0</code> to <code>Npix - 1</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L140-L145">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.nside2npixcap" href="#CMB.Healpix.nside2npixcap"><code>CMB.Healpix.nside2npixcap</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Npix = nside2npixcap(nside)</code></pre><p>Returns the number of pixels <code>Npix</code> in the polar caps for the given <code>nside</code> HEALPix map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L153-L157">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.nside2npixequ" href="#CMB.Healpix.nside2npixequ"><code>CMB.Healpix.nside2npixequ</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Npix = nside2npixequ(nside)</code></pre><p>Returns the number of pixels <code>Npix</code> in the northern hemisphere, including the equatorial ring, for the given <code>nside</code> HEALPix map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L159-L164">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.nside2nring" href="#CMB.Healpix.nside2nring"><code>CMB.Healpix.nside2nring</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">Nring = nside2nring(nside)</code></pre><p>Returns the number of iso-latitude rings <code>Nring</code> in the <code>nside</code> HEALPix map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L147-L151">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.nside2pixarea" href="#CMB.Healpix.nside2pixarea"><code>CMB.Healpix.nside2pixarea</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">σ = nside2pixarea(nside)</code></pre><p>Returns the surface area <code>σ</code> (in steradians) of each pixel in the given <code>nside</code> HEALPix map.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L166-L171">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.pix2ang-Tuple{Any,Any}" href="#CMB.Healpix.pix2ang-Tuple{Any,Any}"><code>CMB.Healpix.pix2ang</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">(θ,ϕ) = pix2ang(nside, p)</code></pre><p>Computes the colatitude and azimuth pair <code>(θ,ϕ)</code> for the given pixel <code>p</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L359-L363">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.pix2phi-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer" href="#CMB.Healpix.pix2phi-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer"><code>CMB.Healpix.pix2phi</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">ϕ = pix2phi(nside, p)</code></pre><p>Computes the azimuth <code>ϕ</code> for the given pixel <code>p</code>. <code>nside</code> is the Nside resolution factor.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L320-L325">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.pix2ring-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer" href="#CMB.Healpix.pix2ring-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer"><code>CMB.Healpix.pix2ring</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">i = pix2ring(nside, p)</code></pre><p>Computes the ring index <code>i</code> for the given pixel <code>p</code>. <code>nside</code> is the Nside resolution factor.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L231-L236">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.pix2ringidx-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer" href="#CMB.Healpix.pix2ringidx-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer"><code>CMB.Healpix.pix2ringidx</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">j = pix2ringidx(nside, p)</code></pre><p>Computes the index <code>j</code> within the ring for the given pixel <code>p</code>. <code>nside</code> is the Nside resolution factor.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L250-L255">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.pix2theta-Tuple{Any,Any}" href="#CMB.Healpix.pix2theta-Tuple{Any,Any}"><code>CMB.Healpix.pix2theta</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">θ = pix2theta(nside, p)</code></pre><p>Computes the colatitude <code>θ</code> for the given pixel <code>p</code>. <code>nside</code> is the Nside resolution factor.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L304-L309">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.pix2vec-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer" href="#CMB.Healpix.pix2vec-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer"><code>CMB.Healpix.pix2vec</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">r::SVector{3} = pix2vec(nside, p)</code></pre><p>Computes the unit vector <code>r</code> pointing to the pixel center of the given pixel <code>p</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L374-L378">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Healpix.pix2z-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer" href="#CMB.Healpix.pix2z-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer"><code>CMB.Healpix.pix2z</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">z = pix2z(nside, p)</code></pre><p>Computes the cosine of the colatitude <code>z</code> for the given pixel <code>p</code>. <code>nside</code> is the Nside resolution factor.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/healpix.jl#L272-L277">source</a></section><h2><a class="nav-anchor" id="Pixel-Covariance-1" href="#Pixel-Covariance-1">Pixel Covariance</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.PixelCovariance" href="#CMB.PixelCovariance"><code>CMB.PixelCovariance</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Collection of functions which compute the pixel-pixel covariance of the CMB sky.</p><p>Based on equations given in Tegmark and de Oliveira-Costa (2001) <em>“How to measure CMB polarization power spectra without losing information”</em> arXiv:astro-ph/0012120v3</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/pixelcovariance.jl#L1-L8">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.PixelCovariance.PixelCovarianceCache" href="#CMB.PixelCovariance.PixelCovarianceCache"><code>CMB.PixelCovariance.PixelCovarianceCache</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct PixelCovarianceCache</code></pre><p>Data structure which contains all the information and buffers required to compute the pixel-pixel covariance terms for a given pixel with respect to all other pixels.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/pixelcovariance.jl#L197-L202">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.PixelCovariance.PixelCovarianceCoeff" href="#CMB.PixelCovariance.PixelCovarianceCoeff"><code>CMB.PixelCovariance.PixelCovarianceCoeff</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">struct PixelCovarianceCoeff{T&lt;:Real}</code></pre><p>Precomputed recursion relation coefficients for computing the pixel-pixel covariance.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; PixelCovarianceCoeff{Float64}(2)
CMB.PixelCovariance.PixelCovarianceCoeff{Float64} for lmax = 2 with coefficients:
    λ: CMB.Legendre.LegendreNormCoeff{CMB.Legendre.LegendreUnitNorm,Float64}
    η: [0.0795775, 0.238732, 0.397887]
    α: [0.0, 0.0, 0.324874]
    β: [0.0, 0.0, 0.0331573]</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/pixelcovariance.jl#L27-L41">source</a></section><h2><a class="nav-anchor" id="Miscellaneous-Utilities-1" href="#Miscellaneous-Utilities-1">Miscellaneous Utilities</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Util" href="#CMB.Util"><code>CMB.Util</code></a> — <span class="docstring-category">Module</span>.</div><div><div><p>Miscellaneous utility functions.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/util.jl#L1-L3">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Util.outer" href="#CMB.Util.outer"><code>CMB.Util.outer</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>Computes the outer product between a given column of a sparse matrix and a vector.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/sparse.jl#L5-L7">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Util.outer-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AbstractArray{Tv,1},SparseMatrixCSC{Tv,Ti},Integer}} where Ti where Tv" href="#CMB.Util.outer-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AbstractArray{Tv,1},SparseMatrixCSC{Tv,Ti},Integer}} where Ti where Tv"><code>CMB.Util.outer</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">outer(w::AbstractVector, A::SparseMatrixCSC, n::Integer)</code></pre><p>Performs the equivalent of <span>$\vec w \vec{a}_n^\dagger$</span> where <span>$\vec a_n$</span> is the column <code>A[:,n]</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/sparse.jl#L46-L51">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Util.outer-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixCSC{Tv,Ti},Integer,AbstractArray{Tv,1}}} where Ti where Tv" href="#CMB.Util.outer-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseMatrixCSC{Tv,Ti},Integer,AbstractArray{Tv,1}}} where Ti where Tv"><code>CMB.Util.outer</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">outer(A::SparseMatrixCSC, n::Integer, w::AbstractVector)</code></pre><p>Performs the equivalent of <span>$\vec a_n \vec w^\dagger$</span> where <span>$\vec a_n$</span> is the column <code>A[:,n]</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/sparse.jl#L10-L15">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="CMB.Util.quadprod" href="#CMB.Util.quadprod"><code>CMB.Util.quadprod</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">quadprod(A, b, n, dir=:col)</code></pre><p>Computes the quadratic product <span>$ABA^T$</span> efficiently for the case where <span>$B$</span> is all zero except for the <code>n</code>th column or row vector <code>b</code>, for <code>dir = :col</code> or <code>dir = :row</code>, respectively.</p></div></div><a class="source-link" target="_blank" href="https://github.com/jmert/CMB.jl/blob/ac198749de382666758f1dbbcf678575904ee519/src/sparse.jl#L86-L92">source</a></section><footer><hr/><a class="previous" href="../man/references.html"><span class="direction">Previous</span><span class="title">References</span></a><a class="next" href="private.html"><span class="direction">Next</span><span class="title">Private</span></a></footer></article></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>HEALPix Pixelization · CMB Analysis</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>CMB Analysis</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">CMB.jl Documentation</a></li><li><span class="toctext">Manual</span><ul><li class="current"><a class="toctext" href="healpix.html">HEALPix Pixelization</a><ul class="internal"><li><a class="toctext" href="#Basic-pixelization-properties-1">Basic pixelization properties</a></li><li><a class="toctext" href="#Working-with-pixel-indices-1">Working with pixel indices</a></li><li><a class="toctext" href="#Working-with-spherical-coordinates-1">Working with spherical coordinates</a></li><li><a class="toctext" href="#Input-validation-and-error-handling-1">Input validation and error handling</a></li></ul></li><li><a class="toctext" href="legendre.html">Legendre Polynomials</a></li><li><a class="toctext" href="references.html">References</a></li></ul></li><li><span class="toctext">API Reference</span><ul><li><a class="toctext" href="../lib/public.html">Public</a></li><li><a class="toctext" href="../lib/private.html">Private</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href="healpix.html">HEALPix Pixelization</a></li></ul><a class="edit-page" href="https://github.com/jmert/CMB.jl/blob/master/docs/src/man/healpix.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>HEALPix Pixelization</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="HEALPix-Pixelization-1" href="#HEALPix-Pixelization-1"><code>HEALPix</code> Pixelization</a></h1><ul><li><a href="healpix.html#HEALPix-Pixelization-1"><code>HEALPix</code> Pixelization</a></li><ul><li><a href="healpix.html#Basic-pixelization-properties-1">Basic pixelization properties</a></li><li><a href="healpix.html#Working-with-pixel-indices-1">Working with pixel indices</a></li><li><a href="healpix.html#Working-with-spherical-coordinates-1">Working with spherical coordinates</a></li><li><a href="healpix.html#Input-validation-and-error-handling-1">Input validation and error handling</a></li></ul></ul><p>The <a href="../lib/public.html#CMB.Healpix"><code>Healpix</code></a> module implements a selection of functions for interacting with the <strong>H</strong>ierarchical <strong>E</strong>qual-<strong>A</strong>rea Iso-<strong>L</strong>atitude <strong>Pix</strong>elization (<code>HEALPix</code>) as described in <a href="references.html#bib-healpix-1">Górski et al. (2005)</a>. The emphasis has been on working with pixel index and spherical coordinate conversions for the RING-ordered scheme only. If a complete <code>HEALPix</code> implementation is required, try <a href="https://github.com/mweastwood/LibHealpix.jl">LibHealpix.jl</a> which provides Julia bindings to the official C++ library or try using the Python <a href="https://github.com/healpy/healpy">healpy</a> interface via <a href="https://github.com/JuliaPy/PyCall.jl">PyCall.jl</a>. Additionally, the <a href="https://github.com/ziotom78/Healpix.jl">Healpix.jl</a> package aims for a complete native Julia reimplementation. <span>$\newcommand{\Nside}{N_\mathrm{side}}$</span></p><h2><a class="nav-anchor" id="Basic-pixelization-properties-1" href="#Basic-pixelization-properties-1">Basic pixelization properties</a></h2><p>A core defining attribute of the <code>HEALPix</code> map is the <span>$\Nside$</span> parameter. The minimum valid value is <span>$\Nside = 1$</span>, representing the coarsest pixelization of the sphere which can be represented by <code>HEALPix</code>. The <span>$\Nside$</span> then increases by factors of two—denoting ever finer resolutions—with the number of pixels covering the sphere being a function of <span>$\Nside$</span> alone. <a href="../lib/public.html#CMB.Healpix.nside2npix"><code>CMB.Healpix.nside2npix</code></a> returns the number of pixels in a given map:</p><pre><code class="language-julia-repl">julia&gt; using CMB.Healpix

julia&gt; nside = 4;

julia&gt; nside2npix(nside)
192</code></pre><p>Because all pixels are of equal area and the number of pixels is derived from only the <span>$\Nside$</span>, the pixel surface area must be as well. For convenience, <a href="../lib/public.html#CMB.Healpix.nside2pixarea"><code>CMB.Healpix.nside2pixarea</code></a> is provided and is equivalent to the simple from-scratch calculation (in steradians).</p><pre><code class="language-julia-repl">julia&gt; 4π / nside2npix(nside)
0.06544984694978735

julia&gt; nside2pixarea(nside)
0.06544984694978735</code></pre><p>The number of iso-latitude rings is also a function of only <span>$\Nside$</span> and calculated by <a href="../lib/public.html#CMB.Healpix.nside2nring"><code>CMB.Healpix.nside2nring</code></a>:</p><pre><code class="language-julia-repl">julia&gt; nside2nring(nside)
15</code></pre><h2><a class="nav-anchor" id="Working-with-pixel-indices-1" href="#Working-with-pixel-indices-1">Working with pixel indices</a></h2><p>The pixels are enumerated as 0-indexed integers from west to east along the iso-latitude rings, from north to south. For example, pixel 0 is the first pixel in the first ring, and pixel 103 is the sixteenth pixel in the eighth ring for an <span>$\Nside = 4$</span> map:</p><pre><code class="language-julia-repl">julia&gt; pix = (0, 103);

julia&gt; pix2ring.(nside, pix)    # Ring
(1, 8)

julia&gt; pix2ringidx.(nside, pix) # Index in ring
(1, 16)</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Be careful to note that pixels are 0-indexed, but the rings and indices within a ring are 1-indexed.</p></div></div><p>The <code>HEALPix</code> grid is symmetric about equator, with the equatorial ring considered part of the northern hemisphere by convention. Membership as part of the northern or southern hemisphere can be tested with the <a href="../lib/public.html#CMB.Healpix.isnorth"><code>CMB.Healpix.isnorth</code></a> and <a href="../lib/public.html#CMB.Healpix.issouth"><code>CMB.Healpix.issouth</code></a> functions, respectively. Pixel 103 is actually the last pixel in the northern hemisphere, so</p><pre><code class="language-julia-repl">julia&gt; isnorth(nside, 103)
true

julia&gt; isnorth(nside, 104)
false

julia&gt; issouth(nside, 104)
true</code></pre><p>In fact, each hemisphere is further composed of a so-called <em>polar cap</em> and <em>equatorial belt</em> region of pixels (a property derived from the mathematical details of the <code>HEALPix</code> grid&#39;s definition). According to the ring-ordered definition, pixel 0 should be in the polar cap (tested via <a href="../lib/public.html#CMB.Healpix.iscap"><code>CMB.Healpix.iscap</code></a>), while pixel 103 in the equatorial ring is expected to be part of the equitorial belt (tested via <a href="../lib/public.html#CMB.Healpix.isequbelt"><code>CMB.Healpix.isequbelt</code></a>).</p><pre><code class="language-julia-repl">julia&gt; iscap.(nside, pix)
(true, false)

julia&gt; isequbelt.(nside, pix)
(false, true)</code></pre><p>Membership in a particular hemisphere&#39;s polar cap or equatorial belt is accomplished with variants inserting <code>north</code> and <code>south</code> into the function names, i.e. polar caps are distinguished by <a href="../lib/public.html#CMB.Healpix.isnorthcap"><code>CMB.Healpix.isnorthcap</code></a> and <a href="../lib/public.html#CMB.Healpix.issouthcap"><code>CMB.Healpix.issouthcap</code></a>, and the halves of the equatorial belt are distinguished by <a href="../lib/public.html#CMB.Healpix.isnorthequbelt"><code>CMB.Healpix.isnorthequbelt</code></a> and <a href="../lib/public.html#CMB.Healpix.issouthequbelt"><code>CMB.Healpix.issouthequbelt</code></a>.</p><pre><code class="language-julia-repl">julia&gt; pix = (0, 103, 104, 191);

julia&gt; isnorthcap.(nside, pix)
(true, false, false, false)

julia&gt; isnorthequbelt.(nside, pix)
(false, true, false, false)

julia&gt; issouthequbelt.(nside, pix)
(false, false, true, false)

julia&gt; issouthcap.(nside, pix)
(false, false, false, true)</code></pre><h2><a class="nav-anchor" id="Working-with-spherical-coordinates-1" href="#Working-with-spherical-coordinates-1">Working with spherical coordinates</a></h2><p>Up to now, all the features shown have concerned working with properties of the pixelization scheme, but the utility of the <code>HEALPix</code> grid is its ability to describe the surface of a sphere. Using spherical coordinates is more useful and more natural for more algorithms than the <code>HEALPix</code>-specific indexing scheme.</p><p>The first method of describing the location of a particular <code>HEALPix</code> pixel is as a colatitude/azimuth pair of angles on the surface of the sphere identifying the pixel center. Colatitude measures the angle (in radians) south of the North Pole, and azimuth measures the angle (in radians) east of the Prime Meridian. To get the colatitude, use <a href="../lib/public.html#CMB.Healpix.pix2theta-Tuple{Any,Any}"><code>CMB.Healpix.pix2theta</code></a>,</p><pre><code class="language-julia-repl">julia&gt; pix2theta(nside, 103)
1.5707963267948966</code></pre><p>and to get the azimuth, use <a href="../lib/public.html#CMB.Healpix.pix2phi-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer"><code>CMB.Healpix.pix2phi</code></a></p><pre><code class="language-julia-repl">julia&gt; pix2phi(nside, 103)
6.086835766330224</code></pre><p>(both named to follow the mathematical convention that colatitude/azimuth pairs in spherical coordinates are the variable pair <span>$(θ, ϕ)$</span>). When the coordinate pair is required, the method <a href="../lib/public.html#CMB.Healpix.pix2ang-Tuple{Any,Any}"><code>CMB.Healpix.pix2ang</code></a> returns a 2-tuple with the coordinates:</p><pre><code class="language-julia-repl">julia&gt; pix2ang(nside, 103)
(1.5707963267948966, 6.086835766330224)

julia&gt; pix2ang(nside, 103) .|&gt; rad2deg
(90.0, 348.75)</code></pre><p>The other common way to represent coordinates on the sphere is via unit vectors. The corresponding vector for a given pixel is retrieved with <a href="../lib/public.html#CMB.Healpix.pix2vec-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer"><code>CMB.Healpix.pix2vec</code></a>.</p><pre><code class="language-julia-repl">julia&gt; pix2vec(nside, 103)
3-element SVector{3,Float64}:
  0.980785
 -0.19509
  0.0</code></pre><p>where the elements correspond to the typical <span>$(x, y, z)$</span> right-handed coordinates with the positive <span>$z$</span>-axis passing through the North Pole and the positive <span>$x$</span>-axis passing through the Prime Meridian.</p><p>In reverse, converting an arbitrary spherical coordinate to a pixel index... <em>...TO BE IMPLEMENTED...</em></p><h2><a class="nav-anchor" id="Input-validation-and-error-handling-1" href="#Input-validation-and-error-handling-1">Input validation and error handling</a></h2><p>As stated earlier, the <code>HEALPix</code> <span>$\Nside$</span> parameter takes on values which are powers of two and by convention of the official <code>HEALPix</code> <a href="#footnote-1">[1]</a> source is limited to the range <span>$1$</span> to <span>$2^29$</span>. Validity of any <code>nside</code> parameter can be checked with the <a href="../lib/public.html#CMB.Healpix.ishealpixok-Tuple{Any}"><code>CMB.Healpix.ishealpixok</code></a> function.</p><pre><code class="language-julia-repl">julia&gt; ishealpixok(4)
true

julia&gt; ishealpixok.((5, 2^30))
(false, false)</code></pre><p>Likewise, once given an <span>$\Nside$</span> value, the pixel indices are bounded in <span>$0$</span> to <code>nside2npix(nside) - 1</code>; the two-argument form of <a href="../lib/public.html#CMB.Healpix.ishealpixok-Tuple{Any,Any}"><code>ishealpixok</code></a> returns whether a pixel is valid for the specified <code>nside</code> or not:</p><pre><code class="language-julia-repl">julia&gt; nside2npix(4)
192

julia&gt; ishealpixok(4, 191)
true

julia&gt; ishealpixok(4, 192)
false</code></pre><p>Variants which throw a <a href="../lib/public.html#CMB.Healpix.InvalidNside"><code>CMB.Healpix.InvalidNside</code></a> or <a href="../lib/public.html#CMB.Healpix.InvalidPixel"><code>CMB.Healpix.InvalidPixel</code></a> error are provided by <a href="../lib/public.html#CMB.Healpix.checkhealpix-Tuple{Any,Any}"><code>CMB.Healpix.checkhealpix</code></a>:</p><pre><code class="language-julia-repl">julia&gt; checkhealpix(5)
ERROR: 5 is not a valid Nside parameter (must be power of 2)
[...]

julia&gt; checkhealpix(4, 192)
ERROR: 192 is not a valid pixel index for Nside = 4 (must be from 0 to 191)
[...]</code></pre><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>Only the functions working with spherical coordinates validate their inputs. The pixel indexing and classification functions are considered low-level routines and assume valid inputs. For example,</p><pre><code class="language-julia-repl">julia&gt; nside2npix(5)
300

julia&gt; pix2ring(5, 0)
1

julia&gt; pix2theta(5, 0)
ERROR: 5 is not a valid Nside parameter (must be power of 2)
[...]

julia&gt; isnorth(4, -1)
true

julia&gt; pix2ringidx(4, -1)
0

julia&gt; pix2phi(4, -1)
ERROR: -1 is not a valid pixel index for Nside = 4 (must be from 0 to 191)
[...]</code></pre><p>This choise was made for the sake of computational efficiency — the low-level pixel indexing/classification functions are used internally to compute the spherical coordinates.</p></div></div><hr/><h3><a class="nav-anchor" id="Footnotes:-1" href="#Footnotes:-1">Footnotes:</a></h3><div class="footnote" id="footnote-1"><a href="#footnote-1"><strong>[1]</strong></a><p>Official <code>HEALPix</code> package: <a href="http://healpix.sourceforge.net/">http://healpix.sourceforge.net/</a></p></div><footer><hr/><a class="previous" href="../index.html"><span class="direction">Previous</span><span class="title">CMB.jl Documentation</span></a><a class="next" href="legendre.html"><span class="direction">Next</span><span class="title">Legendre Polynomials</span></a></footer></article></body></html>

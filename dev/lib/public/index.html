<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public · CMB Analysis</title><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">CMB Analysis</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">CMB.jl Documentation</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/external/">Re-exported Packages</a></li><li><a class="tocitem" href="../../man/sphere/">Spherical Functions</a></li><li><a class="tocitem" href="../../man/obsmat/">Observing Matrices</a></li><li><a class="tocitem" href="../../man/pixelcov/">Pixel-pixel Covariance</a></li><li><a class="tocitem" href="../../man/references/">References</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li class="is-active"><a class="tocitem" href>Public</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Sphere-Functions"><span>Sphere Functions</span></a></li><li><a class="tocitem" href="#Pixelizations"><span>Pixelizations</span></a></li><li><a class="tocitem" href="#File-I/O"><span>File I/O</span></a></li><li><a class="tocitem" href="#Pixel-Covariance"><span>Pixel Covariance</span></a></li></ul></li><li><a class="tocitem" href="../private/">Private</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Public</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jmert/CMB.jl/blob/master/docs/src/lib/public.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-Documentation"><a class="docs-heading-anchor" href="#Public-Documentation">Public Documentation</a><a id="Public-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Public-Documentation" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Public-Documentation">Public Documentation</a></li><li class="no-marker"><ul><li><a href="#Contents">Contents</a></li><li><a href="#Sphere-Functions">Sphere Functions</a></li><li><a href="#Pixelizations">Pixelizations</a></li><li><a href="#File-I/O">File I/O</a></li><li><a href="#Pixel-Covariance">Pixel Covariance</a></li></ul></li></ul><h2 id="Sphere-Functions"><a class="docs-heading-anchor" href="#Sphere-Functions">Sphere Functions</a><a id="Sphere-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Sphere-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere" href="#CMB.Sphere"><code>CMB.Sphere</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Collection of routines for working with coordinates on the sphere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/sphere.jl#LL1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.bearing" href="#CMB.Sphere.bearing"><code>CMB.Sphere.bearing</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculates the bearing angle (<span>$α$</span>), defined as the angle between the meridian (at the first coordinate) and the great circle connecting the first coordinate to the second. Angles are measured eastward of north and will be in the range <span>$[-π,π]$</span>. See also <a href="#CMB.Sphere.bearing2"><code>bearing2</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/sphere.jl#LL115-L120">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.bearing-NTuple{4, Any}" href="#CMB.Sphere.bearing-NTuple{4, Any}"><code>CMB.Sphere.bearing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">α = bearing(θ₁, ϕ₁, θ₂, ϕ₂)</code></pre><p>Points on the sphere are given as coordinate pairs <span>$(θ₁,ϕ₁)$</span> and <span>$(θ₂,ϕ₂)$</span> where <span>$θ$</span> is the colatitude angle from the North Pole and <span>$ϕ$</span> is the azimuthal angle, both in radians.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bearing(π/2, 0.0, π/4, π/4)
0.6154797086703873</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/sphere.jl#LL123-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.bearing-Tuple{AbstractVector, AbstractVector}" href="#CMB.Sphere.bearing-Tuple{AbstractVector, AbstractVector}"><code>CMB.Sphere.bearing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">α = bearing(r₁, r₂)</code></pre><p>Points on the sphere are given as unit vectors <span>$r₁$</span> and <span>$r₂$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bearing([1.0, 0.0, 0.0], [0.5, 0.5, sqrt(2)/2])
0.6154797086703873</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/sphere.jl#LL142-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.bearing2" href="#CMB.Sphere.bearing2"><code>CMB.Sphere.bearing2</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculates the north/east vector components of the bearing angle (i.e. <span>$δn = \cos(α), δe = \sin(α)$</span>), defined as the angle between the meridian (at the first coordinate) and the great circle connecting the first coordinate to the second. See also <a href="#CMB.Sphere.bearing"><code>bearing</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/sphere.jl#LL167-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.bearing2-NTuple{4, Any}" href="#CMB.Sphere.bearing2-NTuple{4, Any}"><code>CMB.Sphere.bearing2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(δn, δe) = bearing2(θ₁, ϕ₁, θ₂, ϕ₂)</code></pre><p>Points on the sphere are given as coordinate pairs <span>$(θ₁,ϕ₁)$</span> and <span>$(θ₂,ϕ₂)$</span> where <span>$θ$</span> is the colatitude angle from the North Pole and <span>$ϕ$</span> is the azimuthal angle, both in radians.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bearing2(π/2, 0.0, π/4, π/4)
(0.8164965809277261, 0.5773502691896257)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/sphere.jl#LL175-L187">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.bearing2-Tuple{AbstractVector, AbstractVector}" href="#CMB.Sphere.bearing2-Tuple{AbstractVector, AbstractVector}"><code>CMB.Sphere.bearing2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(δn, δe) = bearing2(r₁, r₂)</code></pre><p>Points on the sphere are given as unit vectors <span>$r₁$</span> and <span>$r₂$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; bearing2([1.0, 0.0, 0.0], [0.5, 0.5, sqrt(2)/2])
(0.816496580927726, 0.5773502691896257)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/sphere.jl#LL194-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.cosdistance" href="#CMB.Sphere.cosdistance"><code>CMB.Sphere.cosdistance</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculates the cosine of the inner angle (<span>$z$</span>) between unit vectors pointing from the center of the sphere to two points on its surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/sphere.jl#LL262-L265">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.cosdistance-NTuple{4, Any}" href="#CMB.Sphere.cosdistance-NTuple{4, Any}"><code>CMB.Sphere.cosdistance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">z = cosdistance(θ₁, ϕ₁, θ₂, ϕ₂)</code></pre><p>Points on the sphere are given as coordinate pairs <span>$(θ₁,ϕ₁)$</span> and <span>$(θ₂,ϕ₂)$</span> where <span>$θ$</span> is the colatitude angle from the North Pole and <span>$ϕ$</span> is the azimuthal angle, both in radians.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cosdistance(π/2, 0.0, π/4, π/4)
0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/sphere.jl#LL268-L280">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.cosdistance-Tuple{AbstractVector, AbstractVector}" href="#CMB.Sphere.cosdistance-Tuple{AbstractVector, AbstractVector}"><code>CMB.Sphere.cosdistance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">z = cosdistance(r₁, r₂)</code></pre><p>Points on the sphere are given as unit vectors <span>$r₁$</span> and <span>$r₂$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cosdistance([1.,0.,0.], [0.5,0.5,sqrt(2)/2])
0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/sphere.jl#LL287-L297">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.distance" href="#CMB.Sphere.distance"><code>CMB.Sphere.distance</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculates the inner angle (<span>$σ$</span>) between unit vectors pointing from the center of the sphere to two points on its surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/sphere.jl#LL219-L222">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.distance-NTuple{4, Any}" href="#CMB.Sphere.distance-NTuple{4, Any}"><code>CMB.Sphere.distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">σ = distance(θ₁, ϕ₁, θ₂, ϕ₂)</code></pre><p>Points on the sphere are given as coordinate pairs <span>$(θ₁,ϕ₁)$</span> and <span>$(θ₂,ϕ₂)$</span> where <span>$θ$</span> is the colatitude angle from the North Pole and <span>$ϕ$</span> is the azimuthal angle, both in radians.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; distance(π/2, 0.0, π/4, π/4)
1.0471975511965979</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/sphere.jl#LL225-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.distance-Tuple{AbstractVector, AbstractVector}" href="#CMB.Sphere.distance-Tuple{AbstractVector, AbstractVector}"><code>CMB.Sphere.distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">σ = distance(r₁, r₂)</code></pre><p>Points on the sphere are given as unit vectors <span>$r₁$</span> and <span>$r₂$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; distance([1.,0.,0.], [0.5,0.5,sqrt(2)/2])
1.0471975511965979</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/sphere.jl#LL244-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.reckon" href="#CMB.Sphere.reckon"><code>CMB.Sphere.reckon</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculates a position on the sphere a given <a href="#CMB.Sphere.distance"><code>distance</code></a> (<span>$σ$</span>, in radians) and relative <a href="#CMB.Sphere.bearing"><code>bearing</code></a> angle (<span>$α$</span>, in radians) away from a given point (measuring the eastward-of-north orientation of the great circle connecting the source and destination points with respect to the merdian passing through the source).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/sphere.jl#LL305-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.reckon-NTuple{4, Any}" href="#CMB.Sphere.reckon-NTuple{4, Any}"><code>CMB.Sphere.reckon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">(θ′, ϕ′) = reckon(θ, ϕ, σ, α)</code></pre><p>The point on the sphere is given by the colatitude-azimuth pair <span>$(θ, ϕ)$</span>, both given in radians.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When <span>$r$</span> points to either the north or south pole, the meridian is defined to be <strong><span>$θ$</span> meridian</strong>, and the bearing angle <span>$α$</span> is oriented with respect to it.</p><p>For example, moving a distance <span>$π/2$</span> with no bearing goes to the equator, with the longitude dependent on the input longitude:</p><pre><code class="language-julia-repl hljs">julia&gt; reckon(0.0, 0.0, π/2, 0.0)
(1.5707963267948966, 3.141592653589793)

julia&gt; reckon(0.0, π/2, π/2, 0.0)
(1.5707963267948966, 4.71238898038469)</code></pre></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/sphere.jl#LL349-L368">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.reckon-Tuple{AbstractVector, Any, Any}" href="#CMB.Sphere.reckon-Tuple{AbstractVector, Any, Any}"><code>CMB.Sphere.reckon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">r′ = reckon(r::AbstractVector, σ, α)</code></pre><p>The point on the sphere is given as a unit vector <span>$r$</span>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When <span>$r$</span> points to either the north or south pole, the meridian is defined to be <strong>prime meridian</strong> and the bearing angle <span>$α$</span> is oriented with respect to it.</p><p>For example, moving a distance <span>$π/2$</span> with no bearing goes to the negative <span>$x$</span> axis (i.e. 0° N, 180° W):</p><pre><code class="language-julia-repl hljs">julia&gt; reckon([0.0, 0.0, 1.0], π/2, 0.0)
3-element SVector{3, Float64} with indices SOneTo(3):
 -1.0
  0.0
  6.123233995736766e-17</code></pre></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/sphere.jl#LL313-L331">source</a></section></article><h2 id="Pixelizations"><a class="docs-heading-anchor" href="#Pixelizations">Pixelizations</a><a id="Pixelizations-1"></a><a class="docs-heading-anchor-permalink" href="#Pixelizations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CMB.Pixelizations.AbstractPixelization" href="#CMB.Pixelizations.AbstractPixelization"><code>CMB.Pixelizations.AbstractPixelization</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractPixelization</code></pre><p>The supertype of various pixelization formats.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/pixelizations.jl#LL16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Pixelizations.ArbitraryPixelization" href="#CMB.Pixelizations.ArbitraryPixelization"><code>CMB.Pixelizations.ArbitraryPixelization</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ArbitraryPixelization &lt;: AbstractPixelization</code></pre><p>An arbitrary pixelization format (i.e. one without any implied structure) where pixel centers are given as a vector of unit vectors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/pixelizations.jl#LL23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Pixelizations.HealpixPixelization" href="#CMB.Pixelizations.HealpixPixelization"><code>CMB.Pixelizations.HealpixPixelization</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct HealpixPixelization &lt;: AbstractPixelization</code></pre><p>A HEALPix pixelization of a particular resolution (<span>$N_\mathrm{side}$</span>). May optionally also describe a subset of the sphere, containing an explicit list of pixels to subset.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/pixelizations.jl#LL38-L43">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Pixelizations.RADecPixelization" href="#CMB.Pixelizations.RADecPixelization"><code>CMB.Pixelizations.RADecPixelization</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RADecPixelization &lt;: AbstractPixelization</code></pre><p>An equidistant cylindrical projection described in terms of a square grid of pixels by their right ascension (RA) and declination (Dec) coordinates (in degrees).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/pixelizations.jl#LL67-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Pixelizations.export_pixelization" href="#CMB.Pixelizations.export_pixelization"><code>CMB.Pixelizations.export_pixelization</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Exports a given instance of <a href="#CMB.Pixelizations.AbstractPixelization"><code>AbstractPixelization</code></a> to a &quot;simple&quot; data type representation suitable for export to disk.</p><p>See also <a href="#CMB.Pixelizations.parse_pixelization"><code>parse_pixelization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/pixelizations.jl#LL110-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Pixelizations.export_pixelization-Tuple{ArbitraryPixelization}" href="#CMB.Pixelizations.export_pixelization-Tuple{ArbitraryPixelization}"><code>CMB.Pixelizations.export_pixelization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">export_pixelization(pix::ArbitraryPixelization)</code></pre><p>Returns a 3×N matrix that describes the given set of arbitrary pixel centers, <code>pix</code>. See also <a href="#CMB.Pixelizations.parse_pixelization-Tuple{AbstractMatrix}"><code>parse_pixelization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/pixelizations.jl#LL139-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Pixelizations.export_pixelization-Tuple{HealpixPixelization}" href="#CMB.Pixelizations.export_pixelization-Tuple{HealpixPixelization}"><code>CMB.Pixelizations.export_pixelization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">export_pixelization(pix::HealpixPixelization)</code></pre><p>Returns a <code>Dict{String}</code> appropriate for serializing to disk that describes the given HEALPix pixelization, <code>pix</code>. See also <a href="#CMB.Pixelizations.parse_pixelization-Tuple{Val{:healpix}, AbstractDict{String}}"><code>parse_pixelization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/pixelizations.jl#LL192-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Pixelizations.export_pixelization-Tuple{RADecPixelization}" href="#CMB.Pixelizations.export_pixelization-Tuple{RADecPixelization}"><code>CMB.Pixelizations.export_pixelization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">export_pixelization(pix::RADecPixelization)</code></pre><p>Returns a <code>Dict{String}</code> appropriate for serializing to disk that describes the given RA/Dec pixelization, <code>pix</code>. See also <a href="#CMB.Pixelizations.parse_pixelization-Tuple{Val{:radec}, AbstractDict{String}}"><code>parse_pixelization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/pixelizations.jl#LL243-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Pixelizations.parse_pixelization" href="#CMB.Pixelizations.parse_pixelization"><code>CMB.Pixelizations.parse_pixelization</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Parses a number of recognizable pixelization specifications, returning a subtype of <a href="#CMB.Pixelizations.AbstractPixelization"><code>CMB.AbstractPixelization</code></a>.</p><p>See also <a href="#CMB.Pixelizations.export_pixelization"><code>export_pixelization</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/pixelizations.jl#LL102-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Pixelizations.parse_pixelization-Tuple{AbstractDict{String}}" href="#CMB.Pixelizations.parse_pixelization-Tuple{AbstractDict{String}}"><code>CMB.Pixelizations.parse_pixelization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parse_pixelization(pixelspec::AbstractDict{String})</code></pre><p>Attempts to parse an <code>AbstractDict</code> containing a pixelization description.  The dictionary is expected to contain a field <code>&quot;type&quot;</code> which specifies the pixelization scheme name, which is used to dispatch for further format-specific processing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/pixelizations.jl#LL152-L158">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Pixelizations.parse_pixelization-Tuple{AbstractMatrix}" href="#CMB.Pixelizations.parse_pixelization-Tuple{AbstractMatrix}"><code>CMB.Pixelizations.parse_pixelization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parse_pixelization(pixelspec::AbstractMatrix)
parse_pixelization(pixelspec::AbstractVector{SVector{3,&lt;:Any}}})</code></pre><p>Interprets a collection of unit 3-vectors as a set of arbitrary pixels on the sphere, returning an instance of <a href="#CMB.Pixelizations.ArbitraryPixelization"><code>ArbitraryPixelization</code></a>. The input may be either a vector of <code>SVector{3}</code> unit vectors or a 3×N matrix where each column is interpreted as a single unit vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/pixelizations.jl#LL122-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Pixelizations.parse_pixelization-Tuple{Val{:healpix}, AbstractDict{String}}" href="#CMB.Pixelizations.parse_pixelization-Tuple{Val{:healpix}, AbstractDict{String}}"><code>CMB.Pixelizations.parse_pixelization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parse_pixelization(::Val{:healpix}, pixelspec::AbstractDict{String,&lt;:Any})</code></pre><p>Parses a dictionary describing a HEALPix pixelization, returning an instance of <a href="#CMB.Pixelizations.HealpixPixelization"><code>HealpixPixelization</code></a>.</p><p><code>pixelspec</code> is must conform to the following format to be parsed:</p><pre><code class="language-julia hljs">Dict(&quot;type&quot; =&gt; &quot;healpix&quot;,
     &quot;nside&quot; =&gt; #= Nside value =#,
     &quot;pixels&quot; =&gt; #= vector of HEALPix pixel indices, or if not provided implied to be a
                    full-sky grid spanning pixels `0:nside2npix(nside)-1` =#
    )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/pixelizations.jl#LL167-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Pixelizations.parse_pixelization-Tuple{Val{:radec}, AbstractDict{String}}" href="#CMB.Pixelizations.parse_pixelization-Tuple{Val{:radec}, AbstractDict{String}}"><code>CMB.Pixelizations.parse_pixelization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parse_pixelization(::Val{:radec}, pixelspec::AbstractDict{String})</code></pre><p>Parses a dictionary describing an equidistance cylindrical projection given in terms of right ascension (RA) and declination (Dec) coordinates, returning an instance of <a href="#CMB.Pixelizations.RADecPixelization"><code>RADecPixelization</code></a>.</p><p><code>pixelspec</code> is must conform to the following format to be parsed:</p><pre><code class="language-julia hljs">Dict(&quot;type&quot; =&gt; &quot;radec&quot;,
     &quot;ra&quot; =&gt; #= vector of uniformly-spaced pixel centers along the RA axis, in degrees =#,
     &quot;dec&quot; =&gt; #= vector of uniformly-spaced pixel centers along the Dec axis, in degrees =#,
     &quot;order&quot; =&gt; #= either &quot;row&quot; or &quot;col&quot; for row/column-major unravelling =#,
    )</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/pixelizations.jl#LL211-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Pixelizations.pointing" href="#CMB.Pixelizations.pointing"><code>CMB.Pixelizations.pointing</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pointing(pix::AbstractPixelization)</code></pre><p>Returns a <code>Vector</code> of <code>SVector{3}</code> unit-vectors pointing to the centers of the pixels described by <code>pix</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/pixelizations.jl#LL258-L263">source</a></section></article><h2 id="File-I/O"><a class="docs-heading-anchor" href="#File-I/O">File I/O</a><a id="File-I/O-1"></a><a class="docs-heading-anchor-permalink" href="#File-I/O" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CMB.Files.read_obsmat" href="#CMB.Files.read_obsmat"><code>CMB.Files.read_obsmat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">R, metadata = read_obsmat(filename::String; keywords...)</code></pre><p>Read a sparse observing matrix <code>R</code> and the corresponding metadata <code>metadata</code> from <code>filename</code>. The metadata data will include the following fields:</p><ul><li><code>fields</code>: a description of the Stokes fields for which the observing matrix applies — e.g. the value &quot;QU&quot; signals that <code>R</code> is the block matrix <code>[R_QQ R_QU; R_UQ R_UU]</code>.</li><li><code>pixels_right</code>: a description of the &quot;right-hand side&quot; pixelization format of the observing matrix — i.e. the pixelization of a map vector <span>$v$</span> for which the matrix-vector multiplication <span>$R v$</span> is defined.</li><li><code>pixels_left</code>: a description of the &quot;left-hand side&quot; pixelication format of the observing matrix — i.e. the pixelization of a map vector <span>$w$</span> which results from the matrix-vector multiplication <span>$w = R v$</span>.</li></ul><p>The metadata fields are loaded from datasets named by keyword arguments of the same name. Any keyword set to <code>nothing</code> indicates that the corresponding data should not be loaded. The data types are format- and situation-specific. It is not an error for the named dataset to not exist, and if the dataset does not exist, the field of the metadata named tuple will be filled with the value <code>missing</code>.</p><p>The observing matrix dataset within the data file is given by the keyword <code>name</code> and defaults to <code>&quot;R&quot;</code>. It is an error for the named dataset to not exist (if not <code>nothing</code>).</p><p><strong>See also:</strong> <a href="#CMB.Files.write_obsmat"><code>write_obsmat</code></a></p><p><strong>Extended help</strong></p><p><strong>Backends</strong></p><p>The <code>HDF5.jl</code> storage backend is always loaded with <code>CMB.jl</code> and is considered the native storage format. See <a href="#CMB.Files.write_obsmat"><code>write_obsmat</code></a> for writing a native HDF5 file to disk.</p><p>Importing observing matrices from the following additional data formats is supported via <code>Requires.jl</code>, which requires the user to first load the extra backend of choice.</p><ul><li><code>JLD</code> and <code>JLD2</code>-flavored HDF5 files with <code>JLD.jl</code> (v0.12+) and <code>JLD2.jl</code>, respectively.</li><li>MATLAB v5, v6, v7, and v7.3 save files with <code>MAT.jl</code> (v0.10+).</li><li><code>scipy.sparse</code> CSC and CSR matrices saved to HDF5 files with <code>h5sparse</code>. This case is supported without needing to load any extra packages.</li></ul><p>The pixelization descriptions are imported as data format specific types. For instance, all formats support loading strings and simple numerical scalars or arrays. Additionally, JLD and JLD2 formats can load named datasets as arbitrary Julia types, MATLAB structs are deserialized as <code>Dict</code>s, and named HDF5 groups are read as (nested) <code>Dict</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/fileio.jl#LL12-L58">source</a></section><section><div><pre><code class="nohighlight hljs">read_obsmat(file::FileIO.File{format&quot;HDF5&quot;};
            mmap::Union{Bool,Val{true},Val{false}} = READ_OBSMAT_MMAP[],
            keywords...)</code></pre><p>Reads an observing matrix and pixelization descriptors from an HDF5 file. The native format as written by <a href="#CMB.Files.write_obsmat"><code>write_obsmat</code></a> as well as <code>h5sparse</code>-formatted data structures are supported.</p><p>With HDF5 files in the native format, the additional keyword <code>mmap</code> argument controls whether the observing matrix arrays are loaded via memory-mapping or not. If memory-mapped on Unix systems, the <code>MADV_WILLNEED</code> advice will be applied to the arrays. Additionally, on Linux systems, the memory mapping includes the <code>MAP_POPULATE</code> flag to pre-fault the data pages into active RAM. The default behavior is controlled by the global <code>Ref</code> <a href="#CMB.Files.READ_OBSMAT_MMAP"><code>READ_OBSMAT_MMAP</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/fileio_hdf5.jl#LL34-L49">source</a></section><section><div><pre><code class="nohighlight hljs">read_obsmat(file::FileIO.File{format&quot;JLD&quot;}; keywords...)</code></pre><p>Reads an observing matrix and pixelization descriptors from a JLD-formatted HDF5 file. This function is conditionally included via <code>Requires.jl</code> and requires the user to <code>import JLD</code> or <code>using JLD</code> first.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/fileio.jl#LL73-L79">source</a></section><section><div><pre><code class="nohighlight hljs">read_obsmat(file::FileIO.File{format&quot;JLD2&quot;}; keywords...)</code></pre><p>Reads an observing matrix and pixelization descriptors from a JLD2-formatted HDF5 file. This function is conditionally included via <code>Requires.jl</code> and requires the user to <code>import JLD2</code> or <code>using JLD2</code> first.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/fileio.jl#LL111-L117">source</a></section><section><div><pre><code class="nohighlight hljs">read_obsmat(file::FileIO.File{format&quot;MAT&quot;}; keywords...)</code></pre><p>Reads an observing matrix and pixelization descriptors from a MATLAB save file in v5, v6, v7, or v7.3 format. This function is conditionally included via <code>Requires.jl</code> and requires the user to <code>import MAT</code> or <code>using MAT</code> first.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/fileio.jl#LL165-L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Files.READ_OBSMAT_MMAP" href="#CMB.Files.READ_OBSMAT_MMAP"><code>CMB.Files.READ_OBSMAT_MMAP</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">READ_OBSMAT_MMAP = Ref{Bool}(true)</code></pre><p>Controls the default memory mapping behavior of <a href="#CMB.Files.read_obsmat"><code>read_obsmat</code></a>. Defaults to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/fileio_hdf5.jl#LL17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Files.READ_OBSMAT_MMAP_FLAGS" href="#CMB.Files.READ_OBSMAT_MMAP_FLAGS"><code>CMB.Files.READ_OBSMAT_MMAP_FLAGS</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">READ_OBSMAT_MMAP_FLAGS = Ref{UnixMmap.MmapFlags}(MAP_SHARED)</code></pre><p>Controls the flags passed to <code>mmap</code> when <a href="#CMB.Files.read_obsmat"><code>read_obsmat</code></a> memory maps the observing matrix arrays. Defaults to <code>MAP_SHARED</code> on all systems, with Linux also including <code>MAP_POPULATE</code> by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/fileio_hdf5.jl#LL25-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Files.write_obsmat" href="#CMB.Files.write_obsmat"><code>CMB.Files.write_obsmat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">write_obsmat(filename::String, obsmat::SparseMatrixCSC;
             obsmat_name::String = &quot;R&quot;,
             fields = missing, fields_name::String = &quot;fields&quot;,
             pixels_right = missing, pixels_right_name::String = &quot;pixels_right&quot;,
             pixels_left  = missing, pixels_left_name::String  = &quot;pixels_left&quot;)</code></pre><p>Write an observing matrix <code>obsmat</code> to the HDF5 file <code>filename</code>. If the file exists, it will be overwritten completely (to ensure proper data alignment required for memory mapping), otherwise it will be created.</p><p>Additional metadata — pixelization descriptions <code>pixels_right</code> and <code>pixels_left</code> and an annotation of the Stokes field the observing matrix applies to <code>fields</code> —  may also be provided; for a <code>missing</code> value, the description will not be written to disk.</p><p>The HDF5 dataset and group names of the observing matrix and metadata can be changed from their defaults by setting the associated <code>*_name</code> keywords which effect.</p><p><strong>See also:</strong> <a href="#CMB.Files.read_obsmat"><code>read_obsmat</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/fileio_hdf5.jl#LL204-L223">source</a></section></article><h2 id="Pixel-Covariance"><a class="docs-heading-anchor" href="#Pixel-Covariance">Pixel Covariance</a><a id="Pixel-Covariance-1"></a><a class="docs-heading-anchor-permalink" href="#Pixel-Covariance" title="Permalink"></a></h2><p>The following enums/bit flags are not exported globally, but all of the named values can be imported into a scope by <code>using</code> the parent module (e.g. to access all of the covariance field constants, use <code>using CMB.PixelCovariance.CovarianceFields</code>.</p><article class="docstring"><header><a class="docstring-binding" id="CMB.PolarizationConventions.Convention" href="#CMB.PolarizationConventions.Convention"><code>CMB.PolarizationConventions.Convention</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@enum Convention IAUConv HealpixConv</code></pre><p>An enumeration to specify the two types of polarization conventions used to describe Stokes Q/U coordinate systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/conventions.jl#LL6-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.StokesCrossFields.Field" href="#CMB.StokesCrossFields.Field"><code>CMB.StokesCrossFields.Field</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">@bitflag Field TT QT UT TQ QQ UQ TU QU UU NO_FIELD=0</code></pre><p>A bitfield for identifying combinations of Stokes fields. There are 9 subblocks, named as the Cartesian product of elements T, Q, and U:</p><pre><code class="nohighlight hljs">TT  TQ  TU
QT  QQ  QU
UT  UQ  UU</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/conventions.jl#LL19-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.StokesCrossFields.TPol" href="#CMB.StokesCrossFields.TPol"><code>CMB.StokesCrossFields.TPol</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const TPol = QT | UT | TQ | TU</code></pre><p>An alias for the temperature-cross-polarization Stokes field combinations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/conventions.jl#LL32-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.StokesCrossFields.Pol" href="#CMB.StokesCrossFields.Pol"><code>CMB.StokesCrossFields.Pol</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia hljs">const Pol  = QQ | UQ | QU | UU</code></pre><p>An alias for the polarization-only sub-blocks Stokes field combinations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/9b057a6d5207e8030c0d287f83f2b9bc22072123/src/conventions.jl#LL39-L43">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/references/">« References</a><a class="docs-footer-nextpage" href="../private/">Private »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Sunday 23 October 2022 19:56">Sunday 23 October 2022</span>. Using Julia version 1.8.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

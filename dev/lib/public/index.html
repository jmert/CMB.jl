<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public · CMB Analysis</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CMB Analysis</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">CMB.jl Documentation</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/healpix/">HEALPix Pixelization</a></li><li><a class="tocitem" href="../../man/sphere/">Spherical Functions</a></li><li><a class="tocitem" href="../../man/obsmat/">Observing Matrices</a></li><li><a class="tocitem" href="../../man/pixelcov/">Pixel-pixel Covariance</a></li><li><a class="tocitem" href="../../man/references/">References</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li class="is-active"><a class="tocitem" href>Public</a><ul class="internal"><li><a class="tocitem" href="#Contents"><span>Contents</span></a></li><li><a class="tocitem" href="#Sphere-Functions"><span>Sphere Functions</span></a></li><li><a class="tocitem" href="#Healpix"><span>Healpix</span></a></li><li><a class="tocitem" href="#File-I/O"><span>File I/O</span></a></li><li><a class="tocitem" href="#Pixel-Covariance"><span>Pixel Covariance</span></a></li></ul></li><li><a class="tocitem" href="../private/">Private</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Public</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jmert/CMB.jl/blob/master/docs/src/lib/public.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-Documentation"><a class="docs-heading-anchor" href="#Public-Documentation">Public Documentation</a><a id="Public-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Public-Documentation" title="Permalink"></a></h1><h2 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h2><ul><li><a href="#Public-Documentation">Public Documentation</a></li><ul><li><a href="#Contents">Contents</a></li><li><a href="#Sphere-Functions">Sphere Functions</a></li><li><a href="#Healpix">Healpix</a></li><li><a href="#File-I/O">File I/O</a></li><li><a href="#Pixel-Covariance">Pixel Covariance</a></li></ul></ul><h2 id="Sphere-Functions"><a class="docs-heading-anchor" href="#Sphere-Functions">Sphere Functions</a><a id="Sphere-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Sphere-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere" href="#CMB.Sphere"><code>CMB.Sphere</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Collection of routines for working with coordinates on the sphere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/sphere.jl#LL1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.bearing" href="#CMB.Sphere.bearing"><code>CMB.Sphere.bearing</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculates the bearing angle (<span>$α$</span>), defined as the angle between the meridian (at the first coordinate) and the great circle connecting the first coordinate to the second. Angles are measured eastward of north and will be in the range <span>$[-π,π]$</span>. See also <a href="#CMB.Sphere.bearing2"><code>bearing2</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/sphere.jl#LL110-L115">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.bearing-NTuple{4,Any}" href="#CMB.Sphere.bearing-NTuple{4,Any}"><code>CMB.Sphere.bearing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">α = bearing(θ₁, ϕ₁, θ₂, ϕ₂)</code></pre><p>Points on the sphere are given as coordinate pairs <span>$(θ₁,ϕ₁)$</span> and <span>$(θ₂,ϕ₂)$</span> where <span>$θ$</span> is the colatitude angle from the North Pole and <span>$ϕ$</span> is the azimuthal angle, both in radians.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; bearing(π/2, 0.0, π/4, π/4)
0.6154797086703873</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/sphere.jl#LL118-L130">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.bearing-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#CMB.Sphere.bearing-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>CMB.Sphere.bearing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">α = bearing(r₁, r₂)</code></pre><p>Points on the sphere are given as unit vectors <span>$r₁$</span> and <span>$r₂$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; bearing([1.0, 0.0, 0.0], [0.5, 0.5, sqrt(2)/2])
0.6154797086703873</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/sphere.jl#LL137-L147">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.bearing2" href="#CMB.Sphere.bearing2"><code>CMB.Sphere.bearing2</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculates the north/east vector components of the bearing angle (i.e. <span>$δn = \cos(α), δe = \sin(α)$</span>), defined as the angle between the meridian (at the first coordinate) and the great circle connecting the first coordinate to the second. See also <a href="#CMB.Sphere.bearing"><code>bearing</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/sphere.jl#LL162-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.bearing2-NTuple{4,Any}" href="#CMB.Sphere.bearing2-NTuple{4,Any}"><code>CMB.Sphere.bearing2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(δn, δe) = bearing2(θ₁, ϕ₁, θ₂, ϕ₂)</code></pre><p>Points on the sphere are given as coordinate pairs <span>$(θ₁,ϕ₁)$</span> and <span>$(θ₂,ϕ₂)$</span> where <span>$θ$</span> is the colatitude angle from the North Pole and <span>$ϕ$</span> is the azimuthal angle, both in radians.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; bearing2(π/2, 0.0, π/4, π/4)
(0.8164965809277261, 0.5773502691896257)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/sphere.jl#LL170-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.bearing2-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#CMB.Sphere.bearing2-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>CMB.Sphere.bearing2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(δn, δe) = bearing2(r₁, r₂)</code></pre><p>Points on the sphere are given as unit vectors <span>$r₁$</span> and <span>$r₂$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; bearing2([1.0, 0.0, 0.0], [0.5, 0.5, sqrt(2)/2])
(0.816496580927726, 0.5773502691896257)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/sphere.jl#LL189-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.cosdistance" href="#CMB.Sphere.cosdistance"><code>CMB.Sphere.cosdistance</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculates the cosine of the inner angle (<span>$z$</span>) between unit vectors pointing from the center of the sphere to two points on its surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/sphere.jl#LL257-L260">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.cosdistance-NTuple{4,Any}" href="#CMB.Sphere.cosdistance-NTuple{4,Any}"><code>CMB.Sphere.cosdistance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">z = cosdistance(θ₁, ϕ₁, θ₂, ϕ₂)</code></pre><p>Points on the sphere are given as coordinate pairs <span>$(θ₁,ϕ₁)$</span> and <span>$(θ₂,ϕ₂)$</span> where <span>$θ$</span> is the colatitude angle from the North Pole and <span>$ϕ$</span> is the azimuthal angle, both in radians.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; cosdistance(π/2, 0.0, π/4, π/4)
0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/sphere.jl#LL263-L275">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.cosdistance-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#CMB.Sphere.cosdistance-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>CMB.Sphere.cosdistance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">z = cosdistance(r₁, r₂)</code></pre><p>Points on the sphere are given as unit vectors <span>$r₁$</span> and <span>$r₂$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; cosdistance([1.,0.,0.], [0.5,0.5,sqrt(2)/2])
0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/sphere.jl#LL282-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.distance" href="#CMB.Sphere.distance"><code>CMB.Sphere.distance</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculates the inner angle (<span>$σ$</span>) between unit vectors pointing from the center of the sphere to two points on its surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/sphere.jl#LL214-L217">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.distance-NTuple{4,Any}" href="#CMB.Sphere.distance-NTuple{4,Any}"><code>CMB.Sphere.distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">σ = distance(θ₁, ϕ₁, θ₂, ϕ₂)</code></pre><p>Points on the sphere are given as coordinate pairs <span>$(θ₁,ϕ₁)$</span> and <span>$(θ₂,ϕ₂)$</span> where <span>$θ$</span> is the colatitude angle from the North Pole and <span>$ϕ$</span> is the azimuthal angle, both in radians.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; distance(π/2, 0.0, π/4, π/4)
1.0471975511965979</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/sphere.jl#LL220-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.distance-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#CMB.Sphere.distance-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>CMB.Sphere.distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">σ = distance(r₁, r₂)</code></pre><p>Points on the sphere are given as unit vectors <span>$r₁$</span> and <span>$r₂$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; distance([1.,0.,0.], [0.5,0.5,sqrt(2)/2])
1.0471975511965979</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/sphere.jl#LL239-L249">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.reckon" href="#CMB.Sphere.reckon"><code>CMB.Sphere.reckon</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculates a position on the sphere a given <a href="#CMB.Sphere.distance"><code>distance</code></a> (<code>σ</code>, in radians) and relative <a href="#CMB.Sphere.bearing"><code>bearing</code></a> angle (<code>α</code>, in radians) away from a given point (measuring the eastward-of-north orientation of the great circle connecting the source and destination points with respect to the merdian passing through the source).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/sphere.jl#LL300-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.reckon-NTuple{4,Any}" href="#CMB.Sphere.reckon-NTuple{4,Any}"><code>CMB.Sphere.reckon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(θ′, ϕ′) = reckon(θ, ϕ, σ, α)</code></pre><p>The point on the sphere is given by the colatitude-azimuth pair (<code>θ</code>, <code>ϕ</code>), both given in radians.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When <code>r</code> points to either the north or south pole, the meridian is defined to be <strong><code>θ</code> meridian</strong>, and the bearing angle <code>α</code> is oriented with respect to it.</p><p>For example, moving a distance <span>$π/2$</span> with no bearing goes to the equator, with the longitude dependent on the input longitude:</p><pre><code class="language-julia-repl">julia&gt; reckon(0.0, 0.0, π/2, 0.0)
(1.5707963267948966, 3.141592653589793)

julia&gt; reckon(0.0, π/2, π/2, 0.0)
(1.5707963267948966, 4.71238898038469)</code></pre></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/sphere.jl#LL344-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.reckon-Tuple{AbstractArray{T,1} where T,Any,Any}" href="#CMB.Sphere.reckon-Tuple{AbstractArray{T,1} where T,Any,Any}"><code>CMB.Sphere.reckon</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">r′ = reckon(r::AbstractVector, σ, α)</code></pre><p>The point on the sphere is given as a unit vector <code>r</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>When <code>r</code> points to either the north or south pole, the meridian is defined to be <strong>prime meridian</strong> and the bearing angle <code>α</code> is oriented with respect to it.</p><p>For example, moving a distance <span>$π/2$</span> with no bearing goes to the negative <span>$x$</span> axis (i.e. 0° N, 180° W):</p><pre><code class="language-julia-repl">julia&gt; reckon([0.0, 0.0, 1.0], π/2, 0.0)
3-element StaticArrays.SArray{Tuple{3},Float64,1,3} with indices SOneTo(3):
 -1.0
  0.0
  6.123233995736766e-17</code></pre></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/sphere.jl#LL308-L326">source</a></section></article><h2 id="Healpix"><a class="docs-heading-anchor" href="#Healpix">Healpix</a><a id="Healpix-1"></a><a class="docs-heading-anchor-permalink" href="#Healpix" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix" href="#CMB.Healpix"><code>CMB.Healpix</code></a> — <span class="docstring-category">Module</span></header><section><div><p>A module of functions implementing function which interact with the HEALPix pixel definitions. In most cases, only the RING ordering functions are being provided.</p><p>See &quot;HEALPix: A Framework for High-Resolution Discretization and Fast Analysis of Data Distributed on the Sphere&quot; Górski, Hivon, &amp; Banday et al (2005) ApJ 622:759–771 arXiv: astro-ph/0409513</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.UNSEEN" href="#CMB.Healpix.UNSEEN"><code>CMB.Healpix.UNSEEN</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">const UNSEEN = -1.6375e+30</code></pre><p>Special value recognized by the libhealpix/healpy routines as an unobserved/masked pixel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL25-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.InvalidNside" href="#CMB.Healpix.InvalidNside"><code>CMB.Healpix.InvalidNside</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InvalidNside(nside)</code></pre><p>An invalid <code>nside</code> value was provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL40-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.InvalidPixel" href="#CMB.Healpix.InvalidPixel"><code>CMB.Healpix.InvalidPixel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InvalidPixel(nside, pix)</code></pre><p>An invalid pixel index <code>pix</code> was provided for the given <code>nside</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.ang2pix-Union{Tuple{F}, Tuple{Integer,F,F}} where F" href="#CMB.Healpix.ang2pix-Union{Tuple{F}, Tuple{Integer,F,F}} where F"><code>CMB.Healpix.ang2pix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">p = ang2pix(nside, θ, ϕ)</code></pre><p>Computes the HEALPix pixel index <code>p</code> which contains the point <span>$(θ,ϕ)$</span> given by the colatitude <code>θ</code> and azimuth <code>ϕ</code>, where <code>nside</code> is the Nside resolution factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL461-L466">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.checkhealpix-Tuple{Any,Any}" href="#CMB.Healpix.checkhealpix-Tuple{Any,Any}"><code>CMB.Healpix.checkhealpix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">checkhealpix(nside, pix)</code></pre><p>Throws an <a href="#CMB.Healpix.InvalidNside"><code>InvalidNside</code></a> exception if <code>nside</code> is not a valid value or an <a href="#CMB.Healpix.InvalidPixel"><code>InvalidPixel</code></a> exception if <code>pix</code> is out of range for the given <span>$N_\mathrm{side}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL99-L105">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.checkhealpix-Tuple{Any}" href="#CMB.Healpix.checkhealpix-Tuple{Any}"><code>CMB.Healpix.checkhealpix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">checkhealpix(nside)</code></pre><p>Throws an <a href="#CMB.Healpix.InvalidNside"><code>InvalidNside</code></a> exception if <code>nside</code> is not a valid value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.iscap" href="#CMB.Healpix.iscap"><code>CMB.Healpix.iscap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">iscap(nside, pix)</code></pre><p>Test for whether the given pixel <code>pix</code> is in either polar cap for an <code>nside</code> HEALPix map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL197-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.isequbelt" href="#CMB.Healpix.isequbelt"><code>CMB.Healpix.isequbelt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isequbelt(nside, pix)</code></pre><p>Test for whether the given pixel <code>pix</code> is in the equatorial belt for an <code>nside</code> HEALPix map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL218-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.ishealpixok-Tuple{Any,Any}" href="#CMB.Healpix.ishealpixok-Tuple{Any,Any}"><code>CMB.Healpix.ishealpixok</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isheapixok(nside, pix)</code></pre><p>Returns <code>true</code> if <code>nside</code> is valid and <code>pix</code> is in the range <code>0</code> to <code>nside2npix(nside) - 1</code>, otherwise <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL81-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.ishealpixok-Tuple{Any}" href="#CMB.Healpix.ishealpixok-Tuple{Any}"><code>CMB.Healpix.ishealpixok</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ishealpixok(nside)</code></pre><p>Returns <code>true</code> if <code>nside</code> is a power of two in the range <code>1</code> to <code>2^29</code>, otherwise <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL73-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.isnorth" href="#CMB.Healpix.isnorth"><code>CMB.Healpix.isnorth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isnorth(nside, pix)</code></pre><p>Test for whether the given pixel <code>pix</code> is in the northern hemisphere (including the equatorial ring) for an <code>nside</code> HEALPix map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL225-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.isnorthcap" href="#CMB.Healpix.isnorthcap"><code>CMB.Healpix.isnorthcap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isnorthcap(nside, pix)</code></pre><p>Test for whether the given pixel <code>pix</code> is in the northern polar cap for an <code>nside</code> HEALPix map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL183-L188">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.isnorthequbelt" href="#CMB.Healpix.isnorthequbelt"><code>CMB.Healpix.isnorthequbelt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isnorthequbelt(nside, pix)</code></pre><p>Test for whether the given pixel <code>pix</code> is in the northern equatorial belt (including the equatorial ring) for an <code>nside</code> HEALPix map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL204-L209">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.issouth" href="#CMB.Healpix.issouth"><code>CMB.Healpix.issouth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">issouth(nside, pix)</code></pre><p>Test for whether the given pixel <code>pix</code> is in the southern hemisphere (excluding the equatorial ring) for an <code>nside</code> HEALPix map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL232-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.issouthcap" href="#CMB.Healpix.issouthcap"><code>CMB.Healpix.issouthcap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">issouthcap(nside, pix)</code></pre><p>Test for whether the given pixel <code>pix</code> is in the southern polar cap for an <code>nside</code> HEALPix map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL190-L195">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.issouthequbelt" href="#CMB.Healpix.issouthequbelt"><code>CMB.Healpix.issouthequbelt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">issouthequbelt(nside, pix)</code></pre><p>Test for whether the given pixel <code>pix</code> is in the southern equatorial belt (excluding the equatorial ring) for an <code>nside</code> HEALPix map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL211-L216">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.npix2nside-Tuple{Any}" href="#CMB.Healpix.npix2nside-Tuple{Any}"><code>CMB.Healpix.npix2nside</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Nisde = npix2nside(npix)</code></pre><p>Returns the equivalent <code>Nside</code> corresponding to the number of pixels <code>npix</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL138-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.nring2nside-Tuple{Any}" href="#CMB.Healpix.nring2nside-Tuple{Any}"><code>CMB.Healpix.nring2nside</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Nside = nring2nside(nring)</code></pre><p>Returns the equivalent <code>Nside</code> corresponding to the number of iso-latitude rings <code>nring</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL144-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.nside2npix" href="#CMB.Healpix.nside2npix"><code>CMB.Healpix.nside2npix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Npix = nside2npix(nside)</code></pre><p>Returns the total number of pixels <code>Npix</code> in an <code>nside</code> HEALPix map. Note that <code>HEALPix</code> pixel indexing is 0-based, so valid pixel values are in the range <code>0</code> to <code>Npix - 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL150-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.nside2npixcap" href="#CMB.Healpix.nside2npixcap"><code>CMB.Healpix.nside2npixcap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Npix = nside2npixcap(nside)</code></pre><p>Returns the number of pixels <code>Npix</code> in the polar caps for the given <code>nside</code> HEALPix map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL163-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.nside2npixequ" href="#CMB.Healpix.nside2npixequ"><code>CMB.Healpix.nside2npixequ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Npix = nside2npixequ(nside)</code></pre><p>Returns the number of pixels <code>Npix</code> in the northern hemisphere, including the equatorial ring, for the given <code>nside</code> HEALPix map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL169-L174">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.nside2nring" href="#CMB.Healpix.nside2nring"><code>CMB.Healpix.nside2nring</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Nring = nside2nring(nside)</code></pre><p>Returns the number of iso-latitude rings <code>Nring</code> in the <code>nside</code> HEALPix map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL157-L161">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.nside2pixarea" href="#CMB.Healpix.nside2pixarea"><code>CMB.Healpix.nside2pixarea</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">σ = nside2pixarea(nside)</code></pre><p>Returns the surface area <code>σ</code> (in steradians) of each pixel in the given <code>nside</code> HEALPix map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL176-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.pix2ang-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer" href="#CMB.Healpix.pix2ang-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer"><code>CMB.Healpix.pix2ang</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(θ,ϕ) = pix2ang(nside, p)</code></pre><p>Computes the colatitude and azimuth pair <code>(θ,ϕ)</code> for the given pixel <code>p</code>, where <code>nside</code> is the Nside resolution factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL406-L411">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.pix2phi-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer" href="#CMB.Healpix.pix2phi-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer"><code>CMB.Healpix.pix2phi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ϕ = pix2phi(nside, p)</code></pre><p>Computes the azimuth <code>ϕ</code> for the given pixel <code>p</code>, where <code>nside</code> is the Nside resolution factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL358-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.pix2ring-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer" href="#CMB.Healpix.pix2ring-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer"><code>CMB.Healpix.pix2ring</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">i = pix2ring(nside, p)</code></pre><p>Computes the ring index <code>i</code> for the given pixel <code>p</code>, where <code>nside</code> is the Nside resolution factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL249-L254">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.pix2ringidx-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer" href="#CMB.Healpix.pix2ringidx-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer"><code>CMB.Healpix.pix2ringidx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">j = pix2ringidx(nside, p)</code></pre><p>Computes the index <code>j</code> within the ring for the given pixel <code>p</code>, where <code>nside</code> is the Nside resolution factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL267-L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.pix2theta-Tuple{Any,Any}" href="#CMB.Healpix.pix2theta-Tuple{Any,Any}"><code>CMB.Healpix.pix2theta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">θ = pix2theta(nside, p)</code></pre><p>Computes the colatitude <code>θ</code> for the given pixel <code>p</code>, where <code>nside</code> is the Nside resolution factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL342-L347">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.pix2vec-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer" href="#CMB.Healpix.pix2vec-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer"><code>CMB.Healpix.pix2vec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">r = pix2vec(nside, p)</code></pre><p>Computes the unit vector <code>r</code> pointing to the pixel center of the given pixel <code>p</code>, where <code>nside</code> is the Nside resolution factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL430-L435">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.pix2z-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer" href="#CMB.Healpix.pix2z-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer"><code>CMB.Healpix.pix2z</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">z = pix2z(nside, p)</code></pre><p>Computes the cosine of the colatitude <code>z</code> for the given pixel <code>p</code>, where <code>nside</code> is the Nside resolution factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL288-L293">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.vec2pix-Tuple{Integer,Any}" href="#CMB.Healpix.vec2pix-Tuple{Integer,Any}"><code>CMB.Healpix.vec2pix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">p = vec2pix(nside, r)</code></pre><p>Computes the HEALPix pixel index <code>p</code> which contains the point at the end of the unit vector <code>r</code>, where <code>nside</code> is the Nside resolution factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/healpix.jl#LL475-L480">source</a></section></article><h2 id="File-I/O"><a class="docs-heading-anchor" href="#File-I/O">File I/O</a><a id="File-I/O-1"></a><a class="docs-heading-anchor-permalink" href="#File-I/O" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CMB.Files.read_obsmat" href="#CMB.Files.read_obsmat"><code>CMB.Files.read_obsmat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">read_obsmat(filename::String; keywords...)</code></pre><p>Read a sparse observing matrix and the corresponding pixelization descriptors from <code>filename</code>. The return value is a <code>NamedTuple</code> with the following fields:</p><ul><li><code>R</code>: the sparse observing matrix <span>$R$</span>.</li><li><code>pixr</code>: either <code>missing</code> or a description of the &quot;right-hand side&quot; pixelization format of the observing matrix — i.e. the pixelization of a map vector <span>$v$</span> for which the matrix-vector multiplication <span>$R v$</span> is defined.</li><li><code>pixl</code>: either <code>missing</code> or a description of the &quot;left-hand side&quot; pixelication format of the observing matrix — i.e. the pixelization of a map vector <span>$w$</span> which results from the matrix-vector multiplication <span>$w = R v$</span>.</li></ul><p>The pixel descriptions <code>pixr</code> and <code>pixl</code> are loaded from the datasets named by the keyword arguments of the same name, if available. If the named dataset exists, then it is loaded and returned. (The data type is format- and situation-specific.) It is not an error for the named dataset to not exist, and the field will be returned with the value <code>missing</code>.</p><p><strong>See also:</strong> <a href="#CMB.Files.write_obsmat"><code>write_obsmat</code></a></p><p><strong>Extended help</strong></p><p><strong>Keywords</strong></p><p>The following keywords identify the specific data structures or fields within the given data file that correspond to the observing matrix and pixelization data structures or fields, and they are available on all backends. Additional keywords may be supported on a backend-specific basis.</p><ul><li><code>name</code>: Name of the observing matrix <span>$R$</span>. Defaults to <code>&quot;R&quot;</code>.</li><li><code>pixr</code>: Name of the data structure or field describing the right-hand side pixelization format. Defaults to <code>&quot;pixels_right&quot;</code>.</li><li><code>pixl</code>: Name of the data structure or field describing the &quot;left-hand side&quot; pixelization format. Defaults to <code>&quot;pixels_right&quot;</code>.</li></ul><p>In all cases, the field names may be <code>nothing</code> to indicate the corresponding data should not be loaded, and the corresponding field in the returned named tuple will have the value <code>missing</code>. It is an error for <code>name</code> to point to a non-existent field, whereas the pixel descriptions will silently ignore an invalid name and just return <code>missing</code> instead.</p><p><strong>Backends</strong></p><p>The <code>HDF5.jl</code> storage backend is always loaded with <code>CMB.jl</code> and is considered the native storage format. See <a href="#CMB.Files.write_obsmat"><code>write_obsmat</code></a> for writing a native HDF5 file to disk.</p><p>Importing observing matrices from the following additional data formats is supported via <code>Requires.jl</code>, which requires the user to first load the extra backend of choice.</p><ul><li><code>JLD</code> and <code>JLD2</code>-flavored HDF5 files with <code>JLD.jl</code> and <code>JLD2.jl</code>, respectively.</li><li>MATLAB v5, v6, v7, and v7.3 save files with <code>MAT.jl</code>.</li><li><code>scipy.sparse</code> CSC and CSR matrices saved to HDF5 files with <code>h5sparse</code>. This case is supported without needing to load any extra packages.</li></ul><p>The pixelization descriptions are imported as data format specific types. For instance, all formats support loading strings and simple numerical scalars or arrays. Additionally, JLD and JLD2 formats can load named datasets as arbitrary Julia types, MATLAB structs are deserialized as <code>Dict</code>s, and named HDF5 groups are read as (nested) <code>Dict</code>s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/fileio.jl#LL12-L71">source</a></section><section><div><pre><code class="language-none">read_obsmat(file::FileIO.File{format&quot;HDF5&quot;};
            mmap::Union{Bool,Val{true},Val{false}} = READ_OBSMAT_MMAP[],
            keywords...)</code></pre><p>Reads an observing matrix and pixelization descriptors from an HDF5 file. The native format as written by <a href="#CMB.Files.write_obsmat"><code>write_obsmat</code></a> as well as <code>h5sparse</code>-formatted data structures are supported.</p><p>With HDF5 files in the native format, the additional keyword <code>mmap</code> argument controls whether the observing matrix arrays are loaded via memory-mapping or not. If memory-mapped on Unix systems, the <code>MADV_WILLNEED</code> advice will be applied to the arrays. Additionally, on Linux systems, the memory mapping includes the <code>MAP_POPULATE</code> flag to pre-fault the data pages into active RAM. The default behavior is controlled by the global <code>Ref</code> <a href="#CMB.Files.READ_OBSMAT_MMAP"><code>READ_OBSMAT_MMAP</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/fileio_hdf5.jl#LL34-L49">source</a></section><section><div><pre><code class="language-none">read_obsmat(file::FileIO.File{format&quot;JLD&quot;}; keywords...)</code></pre><p>Reads an observing matrix and pixelization descriptors from a JLD-formatted HDF5 file. This function is conditionally included via <code>Requires.jl</code> and requires the user to <code>import JLD</code> or <code>using JLD</code> first.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/fileio.jl#LL86-L92">source</a></section><section><div><pre><code class="language-none">read_obsmat(file::FileIO.File{format&quot;JLD2&quot;}; keywords...)</code></pre><p>Reads an observing matrix and pixelization descriptors from a JLD2-formatted HDF5 file. This function is conditionally included via <code>Requires.jl</code> and requires the user to <code>import JLD2</code> or <code>using JLD2</code> first.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/fileio.jl#LL112-L118">source</a></section><section><div><pre><code class="language-none">read_obsmat(file::FileIO.File{format&quot;MAT&quot;}; keywords...)</code></pre><p>Reads an observing matrix and pixelization descriptors from a MATLAB save file in v5, v6, v7, or v7.3 format. This function is conditionally included via <code>Requires.jl</code> and requires the user to <code>import MAT</code> or <code>using MAT</code> first.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/fileio.jl#LL141-L148">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Files.READ_OBSMAT_MMAP" href="#CMB.Files.READ_OBSMAT_MMAP"><code>CMB.Files.READ_OBSMAT_MMAP</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">READ_OBSMAT_MMAP = Ref{Bool}(true)</code></pre><p>Controls the default memory mapping behavior of <a href="#CMB.Files.read_obsmat"><code>read_obsmat</code></a>. Defaults to <code>true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/fileio_hdf5.jl#LL17-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Files.READ_OBSMAT_MMAP_FLAGS" href="#CMB.Files.READ_OBSMAT_MMAP_FLAGS"><code>CMB.Files.READ_OBSMAT_MMAP_FLAGS</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">READ_OBSMAT_MMAP_FLAGS = Ref{UnixMmap.MmapFlags}(MAP_SHARED)</code></pre><p>Controls the flags passed to <code>mmap</code> when <a href="#CMB.Files.read_obsmat"><code>read_obsmat</code></a> memory maps the observing matrix arrays. Defaults to <code>MAP_SHARED</code> on all systems, with Linux also including <code>MAP_POPULATE</code> by default.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/fileio_hdf5.jl#LL25-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Files.write_obsmat" href="#CMB.Files.write_obsmat"><code>CMB.Files.write_obsmat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">write_obsmat(filename::String, obsmat::SparseMatrixCSC, pixr = missing, pixl = missing;
             obsmat_name::String = &quot;R&quot;, pixr_name::String = &quot;pixels_right&quot;,
             pixl_name::String = &quot;pixels_left&quot;)</code></pre><p>Write an observing matrix <code>obsmat</code> to the HDF5 file <code>filename</code>. If the file exists, it will be overwritten completely (to ensure proper data alignment required for memory mapping), otherwise it will be created. Pixelization descriptions <code>pixr</code> and <code>pixl</code> may also be provided; for a <code>missing</code> value, the description will not be written to disk.</p><p>The HDF5 dataset and group names of the observing matrix and pixelization descriptions can be changed from their defaults by setting the <code>obsmat_name</code>, <code>pixr_name</code>, and <code>pixl_name</code> keywords which effect the <code>obsmat</code>, <code>pixr</code>, and <code>pixl</code> storage locations, respectively.</p><p><strong>See also:</strong> <a href="#CMB.Files.read_obsmat"><code>read_obsmat</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/fileio_hdf5.jl#LL197-L212">source</a></section></article><h2 id="Pixel-Covariance"><a class="docs-heading-anchor" href="#Pixel-Covariance">Pixel Covariance</a><a id="Pixel-Covariance-1"></a><a class="docs-heading-anchor-permalink" href="#Pixel-Covariance" title="Permalink"></a></h2><p>The following enums/bit flags are not exported globally, but all of the named values can be imported into a scope by <code>using</code> the parent module (e.g. to access all of the covariance field constants, use <code>using CMB.PixelCovariance.CovarianceFields</code>.</p><article class="docstring"><header><a class="docstring-binding" id="CMB.PixelCovariance.PolarizationConventions.Convention" href="#CMB.PixelCovariance.PolarizationConventions.Convention"><code>CMB.PixelCovariance.PolarizationConventions.Convention</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">@enum Convention IAUConv HealpixConv</code></pre><p>An enumeration to specify the two types of polarization conventions used to describe Stokes Q/U coordinate systems.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.PixelCovariance.CovarianceFields.Field" href="#CMB.PixelCovariance.CovarianceFields.Field"><code>CMB.PixelCovariance.CovarianceFields.Field</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">@bitflag Field TT QT UT TQ QQ UQ TU QU UU NO_FIELD=0</code></pre><p>A bitfield for identifying subblocks of the pixel-pixel covariance matrix. There are 9 subblocks, named as the Cartesian product of elements T, Q, and U:</p><pre><code class="language-none">TT  TQ  TU
QT  QQ  QU
UT  UQ  UU</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/2d5741174ce3e6a394010d2e470e4269ca54607f/base/#L0-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.PixelCovariance.CovarianceFields.TPol" href="#CMB.PixelCovariance.CovarianceFields.TPol"><code>CMB.PixelCovariance.CovarianceFields.TPol</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">const TPol = QT | UT | TQ | TU</code></pre><p>An alias for the temperature-cross-polarization sub-blocks of the full covariance matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/pixelcovariance.jl#LL66-L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.PixelCovariance.CovarianceFields.Pol" href="#CMB.PixelCovariance.CovarianceFields.Pol"><code>CMB.PixelCovariance.CovarianceFields.Pol</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">const Pol  = QQ | UQ | QU | UU</code></pre><p>An alias for the polarization-only sub-blocks of the full covariance matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl/blob/c38a9b02411f34628c4686ec9770be63680934d4/src/pixelcovariance.jl#LL74-L78">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/references/">« References</a><a class="docs-footer-nextpage" href="../private/">Private »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 22 October 2020 03:45">Thursday 22 October 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

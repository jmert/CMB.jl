<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Public · CMB Analysis</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CMB Analysis</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">CMB.jl Documentation</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../man/healpix/">HEALPix Pixelization</a></li><li><a class="tocitem" href="../../man/legendre/">Legendre Polynomials</a></li><li><a class="tocitem" href="../../man/references/">References</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li class="is-active"><a class="tocitem" href>Public</a><ul class="internal"><li><a class="tocitem" href="#Contents-1"><span>Contents</span></a></li><li><a class="tocitem" href="#Sphere-Functions-1"><span>Sphere Functions</span></a></li><li><a class="tocitem" href="#Legendre-Functions-1"><span>Legendre Functions</span></a></li><li><a class="tocitem" href="#Healpix-1"><span>Healpix</span></a></li><li><a class="tocitem" href="#Pixel-Covariance-1"><span>Pixel Covariance</span></a></li><li><a class="tocitem" href="#Miscellaneous-Utilities-1"><span>Miscellaneous Utilities</span></a></li></ul></li><li><a class="tocitem" href="../private/">Private</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Public</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Public</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jmert/CMB.jl.git/blob/master/docs/src/lib/public.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Public-Documentation-1"><a class="docs-heading-anchor" href="#Public-Documentation-1">Public Documentation</a><a class="docs-heading-anchor-permalink" href="#Public-Documentation-1" title="Permalink"></a></h1><h2 id="Contents-1"><a class="docs-heading-anchor" href="#Contents-1">Contents</a><a class="docs-heading-anchor-permalink" href="#Contents-1" title="Permalink"></a></h2><ul><li><a href="#Public-Documentation-1">Public Documentation</a></li><ul><li><a href="#Contents-1">Contents</a></li><li><a href="#Sphere-Functions-1">Sphere Functions</a></li><li><a href="#Legendre-Functions-1">Legendre Functions</a></li><li><a href="#Healpix-1">Healpix</a></li><li><a href="#Pixel-Covariance-1">Pixel Covariance</a></li><li><a href="#Miscellaneous-Utilities-1">Miscellaneous Utilities</a></li></ul></ul><h2 id="Sphere-Functions-1"><a class="docs-heading-anchor" href="#Sphere-Functions-1">Sphere Functions</a><a class="docs-heading-anchor-permalink" href="#Sphere-Functions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere" href="#CMB.Sphere"><code>CMB.Sphere</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Collection of routines for working with coordinates on the sphere.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/sphere.jl#LL1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.bearing" href="#CMB.Sphere.bearing"><code>CMB.Sphere.bearing</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculates the bearing angle (<span>$α$</span>), defined as the angle between the meridian (at the first coordinate) and the great circle connecting the first coordinate to the second. Angles are measured clockwise and will be in the range <span>$[0,π)$</span>. See also <a href="#CMB.Sphere.bearing2"><code>bearing2</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/sphere.jl#LL50-L54">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.bearing-NTuple{4,Any}" href="#CMB.Sphere.bearing-NTuple{4,Any}"><code>CMB.Sphere.bearing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">α = bearing(θ₁, ϕ₁, θ₂, ϕ₂)</code></pre><p>Points on the sphere are given as coordinate pairs <span>$(θ₁,ϕ₁)$</span> and <span>$(θ₂,ϕ₂)$</span> where <span>$θ$</span> is the colatitude angle from the North Pole and <span>$ϕ$</span> is the azimuthal angle, both in radians.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; bearing(π/2, 0.0, π/4, π/4)
0.6154797086703873</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/sphere.jl#LL57-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.bearing-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#CMB.Sphere.bearing-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>CMB.Sphere.bearing</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">α = bearing(r₁, r₂)</code></pre><p>Points on the sphere are given as unit vectors <span>$r₁$</span> and <span>$r₂$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; bearing([1.0, 0.0, 0.0], [0.5, 0.5, sqrt(2)/2])
0.6154797086703873</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/sphere.jl#LL78-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.bearing2" href="#CMB.Sphere.bearing2"><code>CMB.Sphere.bearing2</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculates the latitude/longitude vector components of the bearing angle (i.e. <span>$δθ = \cos(α), δϕ = \sin(α)$</span>), defined as the angle between the meridian (at the first coordinate) and the great circle connecting the first coordinate to the second. See also <a href="#CMB.Sphere.bearing"><code>bearing</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/sphere.jl#LL105-L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.bearing2-NTuple{4,Any}" href="#CMB.Sphere.bearing2-NTuple{4,Any}"><code>CMB.Sphere.bearing2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(δθ, δϕ) = bearing2(θ₁, ϕ₁, θ₂, ϕ₂)</code></pre><p>Points on the sphere are given as coordinate pairs <span>$(θ₁,ϕ₁)$</span> and <span>$(θ₂,ϕ₂)$</span> where <span>$θ$</span> is the colatitude angle from the North Pole and <span>$ϕ$</span> is the azimuthal angle, both in radians.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; bearing2(π/2, 0.0, π/4, π/4)
(0.8164965809277261, 0.5773502691896257)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/sphere.jl#LL113-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.bearing2-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#CMB.Sphere.bearing2-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>CMB.Sphere.bearing2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(δθ, δϕ) = bearing2(r₁, r₂)</code></pre><p>Points on the sphere are given as unit vectors <span>$r₁$</span> and <span>$r₂$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; bearing2([1.0, 0.0, 0.0], [0.5, 0.5, sqrt(2)/2])
(0.816496580927726, 0.5773502691896257)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/sphere.jl#LL134-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.cosdistance" href="#CMB.Sphere.cosdistance"><code>CMB.Sphere.cosdistance</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculates the cosine of the inner angle (<span>$z$</span>) between unit vectors pointing from the center of the sphere to two points on its surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/sphere.jl#LL203-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.cosdistance-NTuple{4,Any}" href="#CMB.Sphere.cosdistance-NTuple{4,Any}"><code>CMB.Sphere.cosdistance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">z = cosdistance(θ₁, ϕ₁, θ₂, ϕ₂)</code></pre><p>Points on the sphere are given as coordinate pairs <span>$(θ₁,ϕ₁)$</span> and <span>$(θ₂,ϕ₂)$</span> where <span>$θ$</span> is the colatitude angle from the North Pole and <span>$ϕ$</span> is the azimuthal angle, both in radians.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; cosdistance(π/2, 0.0, π/4, π/4)
0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/sphere.jl#LL209-L221">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.cosdistance-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#CMB.Sphere.cosdistance-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>CMB.Sphere.cosdistance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">z = cosdistance(r₁, r₂)</code></pre><p>Points on the sphere are given as unit vectors <span>$r₁$</span> and <span>$r₂$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; cosdistance([1.,0.,0.], [0.5,0.5,sqrt(2)/2])
0.5</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/sphere.jl#LL230-L240">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.distance" href="#CMB.Sphere.distance"><code>CMB.Sphere.distance</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Calculates the inner angle (<span>$σ$</span>) between unit vectors pointing from the center of the sphere to two points on its surface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/sphere.jl#LL161-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.distance-NTuple{4,Any}" href="#CMB.Sphere.distance-NTuple{4,Any}"><code>CMB.Sphere.distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">σ = distance(θ₁, ϕ₁, θ₂, ϕ₂)</code></pre><p>Points on the sphere are given as coordinate pairs <span>$(θ₁,ϕ₁)$</span> and <span>$(θ₂,ϕ₂)$</span> where <span>$θ$</span> is the colatitude angle from the North Pole and <span>$ϕ$</span> is the azimuthal angle, both in radians.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; distance(π/2, 0.0, π/4, π/4)
1.0471975511965979</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/sphere.jl#LL167-L179">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Sphere.distance-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}" href="#CMB.Sphere.distance-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}"><code>CMB.Sphere.distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">σ = distance(r₁, r₂)</code></pre><p>Points on the sphere are given as unit vectors <span>$r₁$</span> and <span>$r₂$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; distance([1.,0.,0.], [0.5,0.5,sqrt(2)/2])
1.0471975511965979</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/sphere.jl#LL188-L198">source</a></section></article><h2 id="Legendre-Functions-1"><a class="docs-heading-anchor" href="#Legendre-Functions-1">Legendre Functions</a><a class="docs-heading-anchor-permalink" href="#Legendre-Functions-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CMB.Legendre" href="#CMB.Legendre"><code>CMB.Legendre</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Collections of functions which compute the associated Legendre functions.</p><p>Based on implementation described in Limpanuparb and Milthorpe (2014) <em>“Associated Legendre Polynomials and Spherical Harmonics Computation for Chemistry Applications”</em> arXiv:1410.1748v1</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/legendre.jl#LL1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Legendre.AbstractLegendreNorm" href="#CMB.Legendre.AbstractLegendreNorm"><code>CMB.Legendre.AbstractLegendreNorm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">abstract type AbstractLegendreNorm end</code></pre><p>Abstract supertype for normalization conditions of the Associated Legendre polynomials.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; using InteractiveUtils; subtypes(AbstractLegendreNorm)
3-element Array{Any,1}:
 LegendreNormCoeff
 LegendreSphereNorm
 LegendreUnitNorm</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/legendre.jl#LL50-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Legendre.LegendreNormCoeff" href="#CMB.Legendre.LegendreNormCoeff"><code>CMB.Legendre.LegendreNormCoeff</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct LegendreNormCoeff{N&lt;:AbstractLegendreNorm,T&lt;:Real} &lt;: AbstractLegendreNorm</code></pre><p>Precomputed recursion relation coefficients for the normalization <code>N</code> and value type <code>T</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; LegendreNormCoeff{LegendreSphereNorm,Float64}(1)
LegendreNormCoeff{LegendreSphereNorm,Float64} for lmax = 1, mmax = 1 with coefficients:
    μ: [0.0, 1.22474]
    ν: [1.73205, 2.23607]
    α: [0.0 0.0; 1.73205 0.0]
    β: [0.0 0.0; -0.0 0.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/legendre.jl#LL81-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Legendre.LegendreSphereCoeff" href="#CMB.Legendre.LegendreSphereCoeff"><code>CMB.Legendre.LegendreSphereCoeff</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LegendreSphereCoeff{T}</code></pre><p>Table type of precomputed recursion relation coefficients for the spherical harmonic normalization. Alias for <code>LegendreNormCoeff{LegendreSphereNorm,T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/legendre.jl#LL147-L152">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Legendre.LegendreSphereNorm" href="#CMB.Legendre.LegendreSphereNorm"><code>CMB.Legendre.LegendreSphereNorm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct LegendreSphereNorm &lt;: AbstractLegendreNorm end</code></pre><p>Trait type denoting the spherical-harmonic normalization of the associated Legendre polynomials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/legendre.jl#LL73-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Legendre.LegendreUnitCoeff" href="#CMB.Legendre.LegendreUnitCoeff"><code>CMB.Legendre.LegendreUnitCoeff</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LegendreUnitCoeff{T}</code></pre><p>Precomputed recursion relation coefficients for the standard unit normalization. Alias for <code>LegendreNormCoeff{LegendreUnitNorm,T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/legendre.jl#LL139-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Legendre.LegendreUnitNorm" href="#CMB.Legendre.LegendreUnitNorm"><code>CMB.Legendre.LegendreUnitNorm</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct LegendreUnitNorm &lt;: AbstractLegendreNorm end</code></pre><p>Trait type denoting the unit normalization of the associated Legendre polynomials.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/legendre.jl#LL66-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Legendre.Nlm-Union{Tuple{T}, Tuple{Type{T},Integer,Integer}} where T" href="#CMB.Legendre.Nlm-Union{Tuple{T}, Tuple{Type{T},Integer,Integer}} where T"><code>CMB.Legendre.Nlm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">N = Nlm([T=Float64], l, m)</code></pre><p>Computes the normalization constant</p><div>\[    N_ℓ^m ≡ \sqrt{\frac{2ℓ+1}{4π} \frac{(ℓ-m)!}{(ℓ+m)!}}\]</div><p>which defines the Spherical Harmonic normalized functions <span>$λ_ℓ^m(x)$</span> in terms of the standard unit normalized <span>$P_ℓ^m(x)$</span></p><div>\[    λ_ℓ^m(x) ≡ N_ℓ^m P_ℓ^m(x)\]</div><p>using numbers of type <code>T</code>.</p><p>See also <a href="#CMB.Legendre.Plm-Tuple{Integer,Integer,Number}"><code>Plm</code></a> and <a href="#CMB.Legendre.λlm-Tuple{Integer,Integer,Number}"><code>λlm</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/legendre.jl#LL672-L687">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Legendre.Pl!-Tuple{Any,Integer,Any}" href="#CMB.Legendre.Pl!-Tuple{Any,Integer,Any}"><code>CMB.Legendre.Pl!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Pl!(P, l::Integer, x)</code></pre><p>Fills the array <code>P</code> with the unit-normalized Legendre polynomial values <span>$P_ℓ(x)$</span> for fixed order <span>$m = 0$</span>; equivalent to <code>legendre!(LegendreUnitNorm(), P, l, 0, x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/legendre.jl#LL599-L605">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Legendre.Pl-Tuple{Integer,Number}" href="#CMB.Legendre.Pl-Tuple{Integer,Number}"><code>CMB.Legendre.Pl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">p = Pl(l::Integer, x::Number)</code></pre><p>Computes the Legendre polynomials using unit normalization and for degree <span>$m = 0$</span>; equivalent to <code>p = legendre(LegendreUnitNorm(), l, 0, x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/legendre.jl#LL575-L580">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Legendre.Plm!-Tuple{Any,Integer,Integer,Any}" href="#CMB.Legendre.Plm!-Tuple{Any,Integer,Integer,Any}"><code>CMB.Legendre.Plm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Plm!(P, l::Integer, m::Integer, x)</code></pre><p>Fills the array <code>P</code> with the unit-normalized associated Legendre polynomial values <span>$P_ℓ^m(x)$</span>; equivalent to <code>legendre!(LegendreUnitNorm(), P, l, m, x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/legendre.jl#LL609-L615">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Legendre.Plm-Tuple{Integer,Integer,Number}" href="#CMB.Legendre.Plm-Tuple{Integer,Integer,Number}"><code>CMB.Legendre.Plm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">p = Plm(l::Integer, m::Integer, x::Number)</code></pre><p>Computes the associated Legendre polynomials using unit normalization; equivalent to <code>p = legendre(LegendreUnitNorm(), l, m, x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/legendre.jl#LL583-L588">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Legendre.legendre!-Tuple{AbstractLegendreNorm,Any,Integer,Integer,Any}" href="#CMB.Legendre.legendre!-Tuple{AbstractLegendreNorm,Any,Integer,Integer,Any}"><code>CMB.Legendre.legendre!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">legendre!(norm::AbstractLegendreNorm, Λ, l::Integer, m::Integer, x)</code></pre><p>Fills the array <code>Λ</code> with the Legendre polynomial values <span>$N_ℓ^m P_ℓ^m(x)$</span> up to/of degree <code>l</code> and order <code>m</code> for the normalization scheme <code>norm</code>. <code>Λ</code> must be an array with between 0 and 2 more dimensions than <code>x</code>, with the leading dimensions having the same shape as <code>x</code>.</p><ul><li>If <code>ndims(Λ) == ndims(x)</code>, then <code>Λ</code> is filled with the polynomial values at <code>x</code> for degree <code>l</code> and order <code>m</code>.</li><li>If <code>ndims(Λ) == ndims(x) + 1</code>, then <code>l</code> is interpreted as <code>lmax</code>, and <code>Λ</code> filled with polynomial values for all degrees <code>0 ≤ l ≤ lmax</code> of order <code>m</code>.</li><li>If <code>ndims(Λ) == ndims(x) + 2</code>, then <code>l</code> is interpreted as <code>lmax</code> and <code>m</code> as <code>mmax</code>, and <code>Λ</code> is filled with polynomial values for all degrees <code>0 ≤ l ≤ lmax</code> and orders <code>0 ≤ m ≤ min(mmax, l)</code>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/legendre.jl#LL536-L551">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Legendre.legendre-Tuple{AbstractLegendreNorm,Integer,Integer,Number}" href="#CMB.Legendre.legendre-Tuple{AbstractLegendreNorm,Integer,Integer,Number}"><code>CMB.Legendre.legendre</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">p = legendre(norm::AbstractLegendreNorm, l::Integer, m::Integer, x::Number)
P = legendre.(norm::AbstractLegendreNorm, l, m, x)</code></pre><p>Computes the associated Legendre polynomial <span>$N_ℓ^m P_ℓ^m(x)$</span> of degree <code>l</code> and order <code>m</code> at <code>x</code> for the normalization scheme <code>norm</code>.</p><p>With broadcasting syntax, the polynomials can be computed over any iterable <code>x</code>. Furthermore,</p><ul><li>If <code>l isa Integer &amp;&amp; m isa Integer</code>, then the output <code>P</code> has the same shape as <code>x</code> and is filled with the polynomial values of order <code>l</code> and degree <code>m</code>.</li><li>If <code>l isa UnitRange &amp;&amp; m isa Integer</code>, then <code>l</code> is interpreted as <code>lmax</code>, and the output <code>P</code> has one more dimension than <code>x</code> with the trailing dimension spanning the degrees <code>0 ≤ l ≤ lmax</code>.</li><li>If <code>l isa UnitRange &amp;&amp; m isa UnitRange</code>, then <code>l</code> is interpreted as <code>lmax</code> and <code>m</code> as <code>mmax</code>, and the output <code>P</code> has two more dimensions than <code>x</code> with the trailing dimensions spanning the degrees <code>0 ≤ l ≤ lmax</code> and orders <code>0 ≤ m ≤ mmax</code>, respectively.</li></ul><p>Note that in second and third case, the <code>UnitRange</code>s must satisify <code>first(l) == 0</code> and <code>first(m) == 0</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/legendre.jl#LL507-L527">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Legendre.legendre-Tuple{AbstractLegendreNorm,Integer,Number}" href="#CMB.Legendre.legendre-Tuple{AbstractLegendreNorm,Integer,Number}"><code>CMB.Legendre.legendre</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">p = legendre(norm::AbstractLegendreNorm, l::Integer, x::Number)
P = legendre.(norm::AbstractLegendreNorm, l, x)</code></pre><p>Computes the associated Legendre polynomial assuming the order <span>$m = 0$</span>; equivalent to <code>legendre(norm, l, 0, x)</code> and <code>legendre.(norm, l, 0, x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/legendre.jl#LL496-L502">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Legendre.λlm!-Tuple{Any,Integer,Integer,Any}" href="#CMB.Legendre.λlm!-Tuple{Any,Integer,Integer,Any}"><code>CMB.Legendre.λlm!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">λlm!(Λ, l::Integer, m::Integer, x)</code></pre><p>Fills the array <code>Λ</code> with the spherical-harmonic normalized associated Legendre polynomial values <span>$λ_ℓ^m(x)$</span>; equivalent to <code>legendre!(LegendreSphereNorm(), P, l, m, x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/legendre.jl#LL620-L626">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Legendre.λlm-Tuple{Integer,Integer,Number}" href="#CMB.Legendre.λlm-Tuple{Integer,Integer,Number}"><code>CMB.Legendre.λlm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">λ = λlm(l::Integer, m::Integer, x::Number)</code></pre><p>Computes the associated Legendre polynomials using spherical-harmonic normalization; equivalent to <code>λ = legendre(LegendreSphereNorm(), l, m, x)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/legendre.jl#LL591-L596">source</a></section></article><h2 id="Healpix-1"><a class="docs-heading-anchor" href="#Healpix-1">Healpix</a><a class="docs-heading-anchor-permalink" href="#Healpix-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix" href="#CMB.Healpix"><code>CMB.Healpix</code></a> — <span class="docstring-category">Module</span></header><section><div><p>A module of functions implementing function which interact with the HEALPix pixel definitions. In most cases, only the RING ordering functions are being provided.</p><p>See &quot;HEALPix: A Framework for High-Resolution Discretization and Fast Analysis of Data Distributed on the Sphere&quot; Górski, Hivon, &amp; Banday et al (2005) ApJ 622:759–771 arXiv: astro-ph/0409513</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.UNSEEN" href="#CMB.Healpix.UNSEEN"><code>CMB.Healpix.UNSEEN</code></a> — <span class="docstring-category">Constant</span></header><section><div><pre><code class="language-julia">const UNSEEN = -1.6375e+30</code></pre><p>Special value recognized by the libhealpix/healpy routines as an unobserved/masked pixel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL22-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.InvalidNside" href="#CMB.Healpix.InvalidNside"><code>CMB.Healpix.InvalidNside</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InvalidNside(nside)</code></pre><p>An invalid <code>nside</code> value was provided.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL37-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.InvalidPixel" href="#CMB.Healpix.InvalidPixel"><code>CMB.Healpix.InvalidPixel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InvalidPixel(nside, pix)</code></pre><p>An invalid pixel index <code>pix</code> was provided for the given <code>nside</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.checkhealpix-Tuple{Any,Any}" href="#CMB.Healpix.checkhealpix-Tuple{Any,Any}"><code>CMB.Healpix.checkhealpix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">checkhealpix(nside, pix)</code></pre><p>Throws an <a href="#CMB.Healpix.InvalidNside"><code>InvalidNside</code></a> exception if <code>nside</code> is not a valid value or an <a href="#CMB.Healpix.InvalidPixel"><code>InvalidPixel</code></a> exception if <code>pix</code> is out of range for the given <span>$N_\mathrm{side}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL90-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.checkhealpix-Tuple{Any}" href="#CMB.Healpix.checkhealpix-Tuple{Any}"><code>CMB.Healpix.checkhealpix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">checkhealpix(nside)</code></pre><p>Throws an <a href="#CMB.Healpix.InvalidNside"><code>InvalidNside</code></a> exception if <code>nside</code> is not a valid value.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL80-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.iscap" href="#CMB.Healpix.iscap"><code>CMB.Healpix.iscap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">iscap(nside, pix)</code></pre><p>Test for whether the given pixel <code>pix</code> is in either polar cap for an <code>nside</code> HEALPix map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL187-L192">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.isequbelt" href="#CMB.Healpix.isequbelt"><code>CMB.Healpix.isequbelt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isequbelt(nside, pix)</code></pre><p>Test for whether the given pixel <code>pix</code> is in the equatorial belt for an <code>nside</code> HEALPix map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL208-L213">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.ishealpixok-Tuple{Any,Any}" href="#CMB.Healpix.ishealpixok-Tuple{Any,Any}"><code>CMB.Healpix.ishealpixok</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isheapixok(nside, pix)</code></pre><p>Returns <code>true</code> if <code>nside</code> is valid and <code>pix</code> is in the range <code>0</code> to <code>nside2npix(nside) - 1</code>, otherwise <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL72-L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.ishealpixok-Tuple{Any}" href="#CMB.Healpix.ishealpixok-Tuple{Any}"><code>CMB.Healpix.ishealpixok</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ishealpixok(nside)</code></pre><p>Returns <code>true</code> if <code>nside</code> is a power of two in the range <code>1</code> to <code>2^29</code>, otherwise <code>false</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL64-L69">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.isnorth" href="#CMB.Healpix.isnorth"><code>CMB.Healpix.isnorth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isnorth(nside, pix)</code></pre><p>Test for whether the given pixel <code>pix</code> is in the northern hemisphere (including the equatorial ring) for an <code>nside</code> HEALPix map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL215-L220">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.isnorthcap" href="#CMB.Healpix.isnorthcap"><code>CMB.Healpix.isnorthcap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isnorthcap(nside, pix)</code></pre><p>Test for whether the given pixel <code>pix</code> is in the northern polar cap for an <code>nside</code> HEALPix map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL173-L178">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.isnorthequbelt" href="#CMB.Healpix.isnorthequbelt"><code>CMB.Healpix.isnorthequbelt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">isnorthequbelt(nside, pix)</code></pre><p>Test for whether the given pixel <code>pix</code> is in the northern equatorial belt (including the equatorial ring) for an <code>nside</code> HEALPix map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL194-L199">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.issouth" href="#CMB.Healpix.issouth"><code>CMB.Healpix.issouth</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">issouth(nside, pix)</code></pre><p>Test for whether the given pixel <code>pix</code> is in the southern hemisphere (excluding the equatorial ring) for an <code>nside</code> HEALPix map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL222-L227">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.issouthcap" href="#CMB.Healpix.issouthcap"><code>CMB.Healpix.issouthcap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">issouthcap(nside, pix)</code></pre><p>Test for whether the given pixel <code>pix</code> is in the southern polar cap for an <code>nside</code> HEALPix map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL180-L185">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.issouthequbelt" href="#CMB.Healpix.issouthequbelt"><code>CMB.Healpix.issouthequbelt</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">issouthequbelt(nside, pix)</code></pre><p>Test for whether the given pixel <code>pix</code> is in the southern equatorial belt (excluding the equatorial ring) for an <code>nside</code> HEALPix map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL201-L206">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.npix2nside-Tuple{Any}" href="#CMB.Healpix.npix2nside-Tuple{Any}"><code>CMB.Healpix.npix2nside</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Nisde = npix2nside(npix)</code></pre><p>Returns the equivalent <code>Nside</code> corresponding to the number of pixels <code>npix</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL128-L132">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.nring2nside-Tuple{Any}" href="#CMB.Healpix.nring2nside-Tuple{Any}"><code>CMB.Healpix.nring2nside</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Nside = nring2nside(nring)</code></pre><p>Returns the equivalent <code>Nside</code> corresponding to the number of iso-latitude rings <code>nring</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL134-L138">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.nside2npix" href="#CMB.Healpix.nside2npix"><code>CMB.Healpix.nside2npix</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Npix = nside2npix(nside)</code></pre><p>Returns the total number of pixels <code>Npix</code> in an <code>nside</code> HEALPix map. Note that <code>HEALPix</code> pixel indexing is 0-based, so valid pixel values are in the range <code>0</code> to <code>Npix - 1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL140-L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.nside2npixcap" href="#CMB.Healpix.nside2npixcap"><code>CMB.Healpix.nside2npixcap</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Npix = nside2npixcap(nside)</code></pre><p>Returns the number of pixels <code>Npix</code> in the polar caps for the given <code>nside</code> HEALPix map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL153-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.nside2npixequ" href="#CMB.Healpix.nside2npixequ"><code>CMB.Healpix.nside2npixequ</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Npix = nside2npixequ(nside)</code></pre><p>Returns the number of pixels <code>Npix</code> in the northern hemisphere, including the equatorial ring, for the given <code>nside</code> HEALPix map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL159-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.nside2nring" href="#CMB.Healpix.nside2nring"><code>CMB.Healpix.nside2nring</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">Nring = nside2nring(nside)</code></pre><p>Returns the number of iso-latitude rings <code>Nring</code> in the <code>nside</code> HEALPix map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL147-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.nside2pixarea" href="#CMB.Healpix.nside2pixarea"><code>CMB.Healpix.nside2pixarea</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">σ = nside2pixarea(nside)</code></pre><p>Returns the surface area <code>σ</code> (in steradians) of each pixel in the given <code>nside</code> HEALPix map.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL166-L171">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.pix2ang-Tuple{Any,Any}" href="#CMB.Healpix.pix2ang-Tuple{Any,Any}"><code>CMB.Healpix.pix2ang</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">(θ,ϕ) = pix2ang(nside, p)</code></pre><p>Computes the colatitude and azimuth pair <code>(θ,ϕ)</code> for the given pixel <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL359-L363">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.pix2phi-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer" href="#CMB.Healpix.pix2phi-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer"><code>CMB.Healpix.pix2phi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">ϕ = pix2phi(nside, p)</code></pre><p>Computes the azimuth <code>ϕ</code> for the given pixel <code>p</code>. <code>nside</code> is the Nside resolution factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL320-L325">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.pix2ring-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer" href="#CMB.Healpix.pix2ring-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer"><code>CMB.Healpix.pix2ring</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">i = pix2ring(nside, p)</code></pre><p>Computes the ring index <code>i</code> for the given pixel <code>p</code>. <code>nside</code> is the Nside resolution factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL231-L236">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.pix2ringidx-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer" href="#CMB.Healpix.pix2ringidx-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer"><code>CMB.Healpix.pix2ringidx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">j = pix2ringidx(nside, p)</code></pre><p>Computes the index <code>j</code> within the ring for the given pixel <code>p</code>. <code>nside</code> is the Nside resolution factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL250-L255">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.pix2theta-Tuple{Any,Any}" href="#CMB.Healpix.pix2theta-Tuple{Any,Any}"><code>CMB.Healpix.pix2theta</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">θ = pix2theta(nside, p)</code></pre><p>Computes the colatitude <code>θ</code> for the given pixel <code>p</code>. <code>nside</code> is the Nside resolution factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL304-L309">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.pix2vec-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer" href="#CMB.Healpix.pix2vec-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer"><code>CMB.Healpix.pix2vec</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">r::SVector{3} = pix2vec(nside, p)</code></pre><p>Computes the unit vector <code>r</code> pointing to the pixel center of the given pixel <code>p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL374-L378">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Healpix.pix2z-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer" href="#CMB.Healpix.pix2z-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer"><code>CMB.Healpix.pix2z</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">z = pix2z(nside, p)</code></pre><p>Computes the cosine of the colatitude <code>z</code> for the given pixel <code>p</code>. <code>nside</code> is the Nside resolution factor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/healpix.jl#LL272-L277">source</a></section></article><h2 id="Pixel-Covariance-1"><a class="docs-heading-anchor" href="#Pixel-Covariance-1">Pixel Covariance</a><a class="docs-heading-anchor-permalink" href="#Pixel-Covariance-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CMB.PixelCovariance" href="#CMB.PixelCovariance"><code>CMB.PixelCovariance</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Collection of functions which compute the pixel-pixel covariance of the CMB sky.</p><p>Based on equations given in Tegmark and de Oliveira-Costa (2001) <em>“How to measure CMB polarization power spectra without losing information”</em> arXiv:astro-ph/0012120v3</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/pixelcovariance.jl#LL1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.PixelCovariance.PixelCovarianceCache" href="#CMB.PixelCovariance.PixelCovarianceCache"><code>CMB.PixelCovariance.PixelCovarianceCache</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct PixelCovarianceCache</code></pre><p>Data structure which contains all the information and buffers required to compute the pixel-pixel covariance terms for a given pixel with respect to all other pixels.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/pixelcovariance.jl#LL198-L203">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.PixelCovariance.PixelCovarianceCoeff" href="#CMB.PixelCovariance.PixelCovarianceCoeff"><code>CMB.PixelCovariance.PixelCovarianceCoeff</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">struct PixelCovarianceCoeff{T&lt;:Real}</code></pre><p>Precomputed recursion relation coefficients for computing the pixel-pixel covariance.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; PixelCovarianceCoeff{Float64}(2)
PixelCovarianceCoeff{Float64} for lmax = 2 with coefficients:
    λ: LegendreNormCoeff{LegendreUnitNorm,Float64}
    η: [0.0795775, 0.238732, 0.397887]
    α: [0.0, 0.0, 0.324874]
    β: [0.0, 0.0, 0.0331573]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/pixelcovariance.jl#LL27-L41">source</a></section></article><h2 id="Miscellaneous-Utilities-1"><a class="docs-heading-anchor" href="#Miscellaneous-Utilities-1">Miscellaneous Utilities</a><a class="docs-heading-anchor-permalink" href="#Miscellaneous-Utilities-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="CMB.Util" href="#CMB.Util"><code>CMB.Util</code></a> — <span class="docstring-category">Module</span></header><section><div><p>Miscellaneous utility functions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/util.jl#LL1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Util.outer" href="#CMB.Util.outer"><code>CMB.Util.outer</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Computes the outer product between a given column of a sparse matrix and a vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/sparse.jl#LL5-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Util.outer-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AbstractArray{Tv,1},SparseArrays.SparseMatrixCSC{Tv,Ti},Integer}} where Ti where Tv" href="#CMB.Util.outer-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AbstractArray{Tv,1},SparseArrays.SparseMatrixCSC{Tv,Ti},Integer}} where Ti where Tv"><code>CMB.Util.outer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">outer(w::AbstractVector, A::SparseMatrixCSC, n::Integer)</code></pre><p>Performs the equivalent of <span>$\vec w \vec{a}_n^\dagger$</span> where <span>$\vec a_n$</span> is the column <code>A[:,n]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/sparse.jl#LL46-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Util.outer-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Integer,AbstractArray{Tv,1}}} where Ti where Tv" href="#CMB.Util.outer-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Integer,AbstractArray{Tv,1}}} where Ti where Tv"><code>CMB.Util.outer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">outer(A::SparseMatrixCSC, n::Integer, w::AbstractVector)</code></pre><p>Performs the equivalent of <span>$\vec a_n \vec w^\dagger$</span> where <span>$\vec a_n$</span> is the column <code>A[:,n]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/sparse.jl#LL10-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CMB.Util.quadprod" href="#CMB.Util.quadprod"><code>CMB.Util.quadprod</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">quadprod(A, b, n, dir=:col)</code></pre><p>Computes the quadratic product <span>$ABA^T$</span> efficiently for the case where <span>$B$</span> is all zero except for the <code>n</code>th column or row vector <code>b</code>, for <code>dir = :col</code> or <code>dir = :row</code>, respectively.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jmert/CMB.jl.git/blob/81ede49a912269f0af565e146bdd3fa9dc16ac7d/src/sparse.jl#LL86-L92">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../man/references/">« References</a><a class="docs-footer-nextpage" href="../private/">Private »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 7 January 2020 21:56">Tuesday 7 January 2020</span>. Using Julia version 1.2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

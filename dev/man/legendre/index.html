<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Legendre Polynomials · CMB Analysis</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CMB Analysis</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">CMB.jl Documentation</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../healpix/">HEALPix Pixelization</a></li><li class="is-active"><a class="tocitem" href>Legendre Polynomials</a><ul class="internal"><li><a class="tocitem" href="#legendre_defn-1"><span>Definition and Properties</span></a></li><li><a class="tocitem" href="#legendre_usage-1"><span>Usage</span></a></li><li><a class="tocitem" href="#legendre_customnorm-1"><span>Custom normalizations</span></a></li></ul></li><li><a class="tocitem" href="../references/">References</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../../lib/public/">Public</a></li><li><a class="tocitem" href="../../lib/private/">Private</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Legendre Polynomials</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Legendre Polynomials</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jmert/CMB.jl.git/blob/master/docs/src/man/legendre.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Legendre-Polynomials-1"><a class="docs-heading-anchor" href="#Legendre-Polynomials-1">Legendre Polynomials</a><a class="docs-heading-anchor-permalink" href="#Legendre-Polynomials-1" title="Permalink"></a></h1><ul><li><a href="#Legendre-Polynomials-1">Legendre Polynomials</a></li><ul><li><a href="#legendre_defn-1">Definition and Properties</a></li><li><a href="#legendre_usage-1">Usage</a></li><li><a href="#legendre_customnorm-1">Custom normalizations</a></li></ul></ul><p>The <a href="../../lib/public/#CMB.Legendre"><code>Legendre</code></a> module implementation has been largely based on the approach of <a href="../references/#bib-legendre-1">Limpanuparb and Milthorpe (2014)</a>.</p><h2 id="legendre_defn-1"><a class="docs-heading-anchor" href="#legendre_defn-1">Definition and Properties</a><a class="docs-heading-anchor-permalink" href="#legendre_defn-1" title="Permalink"></a></h2><p>The associated Legendre polynomials <span>$P_ℓ^m(x)$</span> are the solution to the differential equation</p><div>\[\begin{align}
    (1-x^2) \frac{d^2}{dx^2}P_ℓ^m(x) - 2x \frac{d}{dx}P_ℓ^m(x) + \left[ ℓ(ℓ+1) -
        \frac{m^2}{1-x^2} \right] P_ℓ^m(x) = 0
\end{align}\]</div><p>which arises as the colatitude <span>$θ$</span> part of solving Laplace&#39;s equation <span>$∇^2 ψ + λψ = 0$</span> in spherical coordinates (where <span>$x = \cos(θ)$</span>).</p><p>There are several different conventions used to define <span>$P_ℓ^m$</span> that provide different properties, but the convention used here is typical of quantum mechanics and obeys the following properties:</p><ul><li><p>Solutions only exist for integer <span>$ℓ$</span> and <span>$m$</span>, where <span>$ℓ ≤ 0$</span> and <span>$|m| ≤ ℓ$</span>.</p></li><li><p>The associated Legendre functions are normalized such that <span>$P_0^0$</span> is unity and have orthogonality conditions,</p><div>\[\begin{align}
    \int_{-1}^1 P_ℓ^m(x) P_{ℓ&#39;}^{m}(x)\,\mathrm{d}x
        = \frac{2}{2ℓ+1} \frac{(ℓ+m)!}{(ℓ-m)!}
        \delta_{ℓℓ&#39;}
\end{align}\]</div><p>for constant <span>$m$</span> and</p><div>\[\begin{align}
    \int_{-1}^1 \frac{P_ℓ^m(x) P_{ℓ}^{m&#39;}(x)}{1-x^2}\,\mathrm{d}x
        = \frac{1}{m} \frac{(ℓ+m)!}{(ℓ-m)!} \delta_{mm&#39;}
\end{align}\]</div><p>for constant <span>$ℓ$</span>, where <span>$δ$</span> is the Kronecker delta.</p></li><li><p>The phase convention for the Legendre functions is chosen such that the negative orders are related to positive orders according to,</p><div>\[\begin{align}
    P_ℓ^{-m}(x) = (-1)^m \frac{(ℓ-m)!}{(ℓ+m)!} P_ℓ^m(x)
\end{align}\]</div></li><li><p>The Legendre functions can be enumerated for non-negative <span>$m$</span> using the three following recursion relations (given the initial condition <span>$P_0^0(x)$</span>):</p><div>\[\begin{align}
    (ℓ - m + 1)P_{ℓ+1}^m(x) &amp;= (2ℓ+1)xP_ℓ^m(x) - (ℓ+m)P_{ℓ-1}^m(x)
    \label{eqn:std_rr_2term}
    \\
    P_{ℓ+1}^{ℓ+1}(x) &amp;= -(2ℓ+1)\sqrt{1-x^2} P_ℓ^ℓ(x)
    \label{eqn:std_rr_1term_lm}
    \\
    P_{ℓ+1}^ℓ(x) &amp;= x(2ℓ+1)P_ℓ^ℓ(x)
    \label{eqn:std_rr_1term_l}
\end{align}\]</div></li></ul><h2 id="legendre_usage-1"><a class="docs-heading-anchor" href="#legendre_usage-1">Usage</a><a class="docs-heading-anchor-permalink" href="#legendre_usage-1" title="Permalink"></a></h2><h3 id="Calculating-scalar-values-1"><a class="docs-heading-anchor" href="#Calculating-scalar-values-1">Calculating scalar values</a><a class="docs-heading-anchor-permalink" href="#Calculating-scalar-values-1" title="Permalink"></a></h3><p>At the most basic, the associated Legendre polynomial <span>$P_ℓ^m(x)$</span> is computed by calling <a href="../../lib/public/#CMB.Legendre.Plm-Tuple{Integer,Integer,Any}"><code>CMB.Legendre.Plm</code></a>. For example, to compute <span>$P_2^1(0.5)$</span>,</p><pre><code class="language-julia-repl">julia&gt; using CMB.Legendre

julia&gt; Plm(2, 1, 0.5)
-1.299038105676658</code></pre><p>When <span>$m = 0$</span> and only the Legendre polynomial <span>$P_ℓ(x)$</span> is needed, <a href="../../lib/public/#CMB.Legendre.Pl-Tuple{Integer,Any}"><code>CMB.Legendre.Pl</code></a> can be used instead:</p><pre><code class="language-julia-repl">julia&gt; Plm(2, 0, 0.5)
-0.125

julia&gt; Pl(2, 0.5)
-0.125

julia&gt; Pl(2, 0.5) == Plm(2, 0, 0.5)
true</code></pre><p>In the context of CMB analysis, a common use of the associated Legendre polynomials is to compute the spherical harmonics <span>$Y_{ℓm}(θ,ϕ)$</span>:</p><div>\[\begin{align}
    \begin{aligned}
    Y_{ℓm}(θ,ϕ) &amp;≡ (-1)^m N_ℓ^m P_ℓ^m(\cos θ) e^{imϕ} \\
    &amp;\text{where } N_ℓ^m ≡ \sqrt{\frac{2ℓ+1}{4π} \frac{(ℓ-m)!}{(ℓ+m)!}}
    \end{aligned}
\end{align}\]</div><p>The function <a href="../../lib/public/#CMB.Legendre.Nlm-Union{Tuple{T}, Tuple{Type{T},Integer,Integer}} where T"><code>CMB.Legendre.Nlm</code></a> calculates the normalization factor <span>$N_ℓ^m$</span>:</p><pre><code class="language-julia-repl">julia&gt; Nlm(2, 0)
0.6307831305050401

julia&gt; Nlm(2, 0) * Plm(2, 0, 0.5)
-0.07884789131313001</code></pre><p>An important fact about the associated Legendre polynomials is that for <span>$m &gt; 0$</span>, <span>$P_ℓ^m(x)$</span> diverges to <span>$∞$</span> as <span>$ℓ → ∞$</span> <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup>. For even moderately large pairs of <span>$(ℓ,m)$</span>, numerical underflow and overflow make computing the spherical harmonics impossible this way:</p><pre><code class="language-julia-repl">julia&gt; n = Nlm(157, 150)      # Underflows
0.0

julia&gt; p = Plm(157, 150, 0.5) # Overflows
Inf

julia&gt; n * p                  # Undefined
NaN</code></pre><p>One way around this would be to just use extended precision arithmetic</p><pre><code class="language-julia-repl">julia&gt; n = Nlm(BigFloat, 157, 150)
4.14800666209481424285411223457923933542541063872695815968861285171699012214351e-314

julia&gt; p = Plm(157, 150, big&quot;0.5&quot;)
4.768286486602206390406601862422168575170463348990958242752608686436785229641202e+308

julia&gt; Float64(n * p)
1.9778884113202627e-5</code></pre><p>but at the expense of much more computationally expensive calculations.</p><p>An alternative way forward is to directly calculate the spherical harmonic normalized associated Legendre polynomials <span>$λ_ℓ^m(x)$</span> so that the spherical harmonics are defined as</p><div>\[\begin{align}
    \begin{aligned}
    Y_{ℓm}(θ,ϕ) &amp;= (-1)^m λ_ℓ^m(\cos θ) e^{imϕ} \\
    &amp; \text{where } λ_ℓ^m(x) ≡ N_ℓ^m P_ℓ^m(x)
    \end{aligned}
\end{align}\]</div><p><a href="../../lib/public/#CMB.Legendre.λlm-Tuple{Integer,Integer,Any}"><code>CMB.Legendre.λlm</code></a> implements this scheme and avoids the under/overflow of computing the normalization separately from the function:</p><pre><code class="language-julia-repl">julia&gt; λlm(157, 150, 0.5)
1.977888411320241e-5</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>We are not just limited to efficient and numerically stable computation of <span>$λ_ℓ^m(x)$</span>; the package supports arbitrary normalizations.  For further information on implementing custom Legendre normalizations, see the <a href="#legendre_customnorm-1">Custom normalizations</a> section.</p></div></div><h3 id="Calculating-all-values-up-to-a-given-ℓ_\\mathrm{max}-1"><a class="docs-heading-anchor" href="#Calculating-all-values-up-to-a-given-ℓ_\\mathrm{max}-1">Calculating all values up to a given <span>$ℓ_\mathrm{max}$</span></a><a class="docs-heading-anchor-permalink" href="#Calculating-all-values-up-to-a-given-ℓ_\\mathrm{max}-1" title="Permalink"></a></h3><p>Because calculating a particular Legendre polynomial value is the end result of running a recurrence relation, using Julia&#39;s dot broadcasting to compute <span>$P_ℓ^m(x)$</span> for all <span>$ℓ$</span> is inefficient and redoes a lot of work:</p><pre><code class="language-julia-repl">julia&gt; λ = zeros(701);

julia&gt; @time λ[3:701] .= λlm.(2:700, 2, 0.5);
  0.042107 seconds (4.61 k allocations: 257.940 KiB)</code></pre><p>It&#39;s far more efficient to incrementally calculate the <span>$ℓ+1$</span> term directly from the <span>$ℓ$</span> term. Both of <code>Plm</code> and <code>λlm</code> have modifying counterparts, <a href="../../lib/public/#CMB.Legendre.Plm!-Tuple{AbstractArray{T,1} where T,Integer,Integer,Any}"><code>Plm!</code></a> and <a href="../../lib/public/#CMB.Legendre.λlm!-Tuple{AbstractArray{T,1} where T,Integer,Integer,Any}"><code>λlm!</code></a> respectively, which fill an appropriately sized vector for a specified <span>$ℓ_\mathrm{max}$</span>.</p><pre><code class="language-julia-repl">julia&gt; @time λlm!(λ, 700, 2, 0.5);
  0.000036 seconds (4 allocations: 160 bytes)</code></pre><p>On my machine, this ends up being roughly 1000 times faster!</p><p>If all Legendre polynomial values for some <span>$x$</span> over all <span>$ℓ ∈ [0,ℓ_\mathrm{max}]$</span> and <span>$m ∈ [0,ℓ]$</span> are required, there are also methods of <a href="../../lib/public/#CMB.Legendre.Plm!-Tuple{AbstractArray{T,2} where T,Integer,Integer,Any}"><code>Plm!</code></a> and <a href="../../lib/public/#CMB.Legendre.λlm!-Tuple{AbstractArray{T,2} where T,Integer,Integer,Any}"><code>λlm!</code></a> which fill the entire [lower triangular] matrix of values:</p><pre><code class="language-julia-repl">julia&gt; Λ = zeros(701, 701);

julia&gt; λlm!(Λ, 700, 700, 0.5);

julia&gt; Λ[701,3] == λlm(700, 2, 0.5)   # N.B. 1-based indexing of the array!
true</code></pre><h3 id="Precomputed-recursion-factors-1"><a class="docs-heading-anchor" href="#Precomputed-recursion-factors-1">Precomputed recursion factors</a><a class="docs-heading-anchor-permalink" href="#Precomputed-recursion-factors-1" title="Permalink"></a></h3><p>A final trick to accelerating calculation of any normalization of the associated Legendre polynomials is to pre-compute the appropriate recursion relation coefficients.</p><p>At a low level, <code>Plm</code>/<code>Plm!</code> and <code>λlm</code>/<code>λlm!</code> are simple wrappers around the general <a href="../../lib/public/#CMB.Legendre.legendre-Tuple{AbstractLegendreNorm,Integer,Any}"><code>legendre</code></a>/<a href="../../lib/public/#CMB.Legendre.legendre!-Tuple{AbstractLegendreNorm,AbstractArray{T,2} where T,Integer,Integer,Any}"><code>legendre!</code></a> functions. The trait type <a href="../../lib/public/#CMB.Legendre.LegendreUnitNorm"><code>LegendreUnitNorm</code></a> dispatches internal functions to compute <span>$P_ℓ^m(x)$</span>:</p><pre><code class="language-julia-repl">julia&gt; legendre(LegendreUnitNorm(), 5, 2, 0.5) == Plm(5, 2, 0.5)
true</code></pre><p>and <a href="../../lib/public/#CMB.Legendre.LegendreSphereNorm"><code>LegendreSphereNorm</code></a> does the same for <span>$λ_ℓ^m(x)$</span>:</p><pre><code class="language-julia-repl">julia&gt; legendre(LegendreSphereNorm(), 5, 2, 0.5) == λlm(5, 2, 0.5)
true</code></pre><p>The type <a href="../../lib/public/#CMB.Legendre.LegendreNormCoeff"><code>LegendreNormCoeff</code></a> stores the coefficients for a particular normalization (and value type) so that the coefficients must only be calculated once. Aliases for the unit and spherical normalizations are provided by default, <a href="../../lib/public/#CMB.Legendre.LegendreUnitCoeff"><code>LegendreUnitCoeff</code></a> and <a href="../../lib/public/#CMB.Legendre.LegendreSphereCoeff"><code>LegendreSphereCoeff</code></a> respectively.</p><pre><code class="language-julia-repl">julia&gt; coeff = LegendreSphereCoeff{Float64}(700);

julia&gt; legendre(coeff, 5, 2, 0.5)
-0.15888479843070935</code></pre><p>On my machine, this results in a further ~50% decrease in computation time compared to <code>λlm!</code>:</p><pre><code class="language-julia-repl">julia&gt; @time legendre!(coeff, λ, 700, 2, 0.5);
  0.000020 seconds (4 allocations: 160 bytes)</code></pre><p>Notice that due to its flexibility, <code>legendre!</code> requires explicit <code>lmax</code> and <code>mmax</code> arguments even though the <code>LegendreNormCoeff</code> has a <code>lmax</code> and <code>mmax</code> set during construction. This allows us to pass both a coefficient cache and output array which are larger than the computed set of coefficients. For example, the output matrix and cache used above each support computing the Legendre polynomials up to <span>$\ell = 700$</span>, but if we only need <span>$\ell \le 2$</span>, we can avoid computing terms beyond our required problem size.</p><pre><code class="language-julia-repl">julia&gt; fill!(Λ, 0);

julia&gt; legendre!(coeff, Λ, 2, 2, 0.5);

julia&gt; Λ[1:5, 1:5]
5×5 Array{Float64,2}:
  0.282095    0.0       0.0       0.0  0.0
  0.244301   -0.299207  0.0       0.0  0.0
 -0.0788479  -0.334523  0.289706  0.0  0.0
  0.0         0.0       0.0       0.0  0.0
  0.0         0.0       0.0       0.0  0.0</code></pre><p>In most situations, though, it&#39;ll probably be most convenient to use the functor interface attached to the coefficient cache object which assumes the <code>lmax</code> it was constructed with. The coefficient table itself is callable with forms similar to <code>legendre</code> and <code>legendre!</code> except that the <code>norm</code> and <code>lmax</code> arguments are implicit/not necessary.</p><pre><code class="language-julia-repl">julia&gt; coeff(20, 0.5)    # == legendre(coeff, 20, 0.5)
-0.08734916334699527

julia&gt; coeff(20, 2, 0.5) # == legendre(coeff, 20, 2, 0.5)
0.10617507806374693

julia&gt; leg! = coeff;    # alias to clarify that leg! modifies

julia&gt; leg!(λ, 2, 0.5); # same as legendre!(coeff, λ, size(coeff.α, 1) - 1, 2, 0.5)

julia&gt; leg!(Λ, 0.5);    # same as legendre!(coeff, Λ, (size(coeff.α) .- 1)..., 0.5)</code></pre><h2 id="legendre_customnorm-1"><a class="docs-heading-anchor" href="#legendre_customnorm-1">Custom normalizations</a><a class="docs-heading-anchor-permalink" href="#legendre_customnorm-1" title="Permalink"></a></h2><p><code>CMB.Legendre</code> provides the standard and spherical harmonic normalizations by default, but arbitrary normalizations are also supported. The mile-high overview is that the initial condition and recurrence relation (r.r.) coefficients are all methods which dispatch on a normalization trait type, so a new normalization is added by simply extending appropriate types and methods. The following table lists all of the types to extend and method specialization to implement.</p><table><tr><th style="text-align: left">Interfaces to extend/implement</th><th style="text-align: left">Brief description</th></tr><tr><td style="text-align: left"><a href="../../lib/public/#CMB.Legendre.AbstractLegendreNorm"><code>CMB.Legendre.AbstractLegendreNorm</code></a></td><td style="text-align: left">Supertype of normalization trait types</td></tr><tr><td style="text-align: left"><a href="../../lib/private/#CMB.Legendre.Plm_00"><code>CMB.Legendre.Plm_00()</code></a></td><td style="text-align: left">Value of <span>$N_0^0 P_0^0(x)$</span> for the given normalization</td></tr><tr><td style="text-align: left"><a href="../../lib/private/#CMB.Legendre.Plm_μ"><code>CMB.Legendre.Plm_μ()</code></a></td><td style="text-align: left">Coefficient <span>$μ_m$</span> for the 1-term r.r. boosting <span>$ℓ → ℓ+1$</span> and <span>$m → m+1$</span></td></tr><tr><td style="text-align: left"><a href="../../lib/private/#CMB.Legendre.Plm_ν"><code>CMB.Legendre.Plm_ν()</code></a></td><td style="text-align: left">Coefficient <span>$ν_m$</span> for the 1-term r.r. boosting <span>$ℓ → ℓ+1$</span></td></tr><tr><td style="text-align: left"><a href="../../lib/private/#CMB.Legendre.Plm_α"><code>CMB.Legendre.Plm_α()</code></a></td><td style="text-align: left">Coefficient <span>$α_ℓ^m$</span> for the 2-term r.r. acting on the <span>$(ℓ,m)$</span> term</td></tr><tr><td style="text-align: left"><a href="../../lib/private/#CMB.Legendre.Plm_β"><code>CMB.Legendre.Plm_β()</code></a></td><td style="text-align: left">Coefficient <span>$β_ℓ^m$</span> for the 2-term r.r. acting on the <span>$(ℓ-1,m)$</span> term</td></tr></table><p>As a concrete example, we&#39;ll walk through how <span>$λ_ℓ^m(x)$</span> is defined to have the spherical harmonic normalization baked in.</p><div>\[\begin{align}
    λ_ℓ^m(x) &amp;≡ N_ℓ^m P_ℓ^m(x)
    \\
    N_ℓ^m &amp;= \sqrt{\frac{2ℓ+1}{4π} \frac{(ℓ-m)!}{(ℓ+m)!}}
\end{align}\]</div><p>Baking in the normalization happens by changing the coefficients in the recursion relations given in the <a href="#legendre_defn-1">Definitions and Properties</a> section. For our purposes, they take on the form:</p><div>\[\begin{align}
    P_{\ell+1}^m(x) &amp;= \alpha_{\ell+1}^m x P_\ell^m(x)
        - \beta_{\ell+1}^m P_{\ell-1}^m(x)
        \label{eqn:cus_rr_2term}
    \\
    P_{m+1}^{m+1}(x) &amp;= \mu_{m+1} \sqrt{1-x^2} P_m^m(x)
        \label{eqn:cus_rr_1term_lm}
    \\
    P_{m+1}^m(x) &amp;= \nu_m x P_m^m(x)
        \label{eqn:cus_rr_1term_l}
\end{align}\]</div><p>The normalization is encoded in the coefficients <span>$α_ℓ^m$</span>, <span>$β_ℓ^m$</span>, <span>$μ_m$</span>, and <span>$ν_m$</span>. For the standard (unity) normalization, these take on the values</p><div>\[\begin{align}
    α_ℓ^m &amp;= \frac{2ℓ - 1}{ℓ - m} \\
    β_ℓ^m &amp;= \frac{ℓ + m - 1}{ℓ - m} \\
    μ_m &amp;= 2ℓ - 1 \\
    ν_m &amp;= 2ℓ + 1
\end{align}\]</div><p>by simply identifying the coefficients from Eqns. <span>$\ref{eqn:std_rr_2term}$</span>–<span>$\ref{eqn:std_rr_1term_l}$</span> on each of the <span>$P_ℓ^m(x)$</span> terms on the right hand side. For other normalizations, we multiply through by the normalization factor appropriate for the left-hand side of the equations, rearrange terms to correctly normalize the terms on the right, and identify the coefficients left over. For example, <span>$α_ℓ^m$</span> and <span>$β_ℓ^m$</span> for <span>$λ_ℓ^m(x)$</span> are determined by starting with Eq. <span>$\ref{eqn:std_rr_2term}$</span> and multiply through by <span>$N_{ℓ+1}^m$</span>. The left-hand side by definition is <span>$λ_{ℓ+1}^m$</span>, leaving us with</p><div>\[\begin{align}
    \begin{split}
        λ_{ℓ+1}^m &amp;= \frac{2ℓ + 1}{ℓ - m + 1} x
            \sqrt{\frac{2ℓ+3}{4π} \frac{(ℓ-m+1)!}{(ℓ+m+1)!}} P_ℓ^m(x) -
            \\
            &amp;\quad\quad \frac{ℓ+m}{ℓ-m+1} \sqrt{\frac{2ℓ+3}{4π}
            \frac{(ℓ-m+1)!}{(ℓ+m+1)!}} P_{ℓ-1}^m(x)
    \end{split}
\end{align}\]</div><p>Through judicious use of algebra, the terms on the right-hand side can be manipulated to gather terms of the form <span>$N_ℓ^m P_ℓ^m(x)$</span> and <span>$N_{ℓ-1}^m P_{ℓ-1}^m(x)$</span>, leaving us with</p><div>\[\begin{align}
    λ_{ℓ+1}^m &amp;= \sqrt{\frac{2ℓ+3}{2ℓ-1} \frac{4ℓ^2 - 1}{(ℓ+1)^2 - m^2}} x
        λ_ℓ^m(x) -
        \sqrt{\frac{2ℓ+3}{2ℓ-1} \frac{ℓ^2 - m^2}{(ℓ+1)^2 - m^2}}
        λ_{ℓ-1}^m(x)
\end{align}\]</div><p>We identify each of the two square root terms as <span>$α_{ℓ+1}^m$</span> and <span>$β_{ℓ+1}^m$</span> since they are the cofficients appropriate for generating <span>$λ_{ℓ+1}^m(x)$</span>. Doing so with the other two recurrence relation equations, we obtain:</p><div>\[\begin{align}
    α_ℓ^m &amp;= \sqrt{\frac{2ℓ+1}{2ℓ-3} \frac{4(ℓ-1)^2 - 1}{ℓ^2 - m^2}} \\
    β_ℓ^m &amp;= \sqrt{\frac{2ℓ+1}{2ℓ-3} \frac{(ℓ-1)^2 - m^2}{ℓ^2 - m^2}} \\
    μ_m &amp;= \sqrt{1 + \frac{1}{2m}} \\
    ν_m &amp;= \sqrt{2m + 3}
\end{align}\]</div><p>The final math required is to define the initial condition <span>$λ_0^0(x)$</span>. This is straight forward given the definition:</p><div>\[\begin{align}
    λ_0^0(x) &amp;= N_0^0 P_0^0(x) = \sqrt{\frac{1}{4π}} × 1 \\
    λ_0^0(x) &amp;= \sqrt{\frac{1}{4π}}
\end{align}\]</div><p>We now have all the information required to define a custom Legendre normalization. Begin by importing the types and methods which will need to be extended:</p><pre><code class="language-julia-repl">julia&gt; using CMB.Legendre

julia&gt; import CMB.Legendre: AbstractLegendreNorm, Plm_00, Plm_μ, Plm_ν, Plm_α, Plm_β</code></pre><p>We&#39;ll call our new normalization <code>λNorm</code>, which must be a subclass of <code>AbstractLegendreNorm</code>.</p><pre><code class="language-julia-repl">julia&gt; struct λNorm &lt;: AbstractLegendreNorm end</code></pre><p>The initial condition is specified by providing a method of <code>Plm_00</code> which takes our normalization trait type as the first argument. (The second argument can be useful if some extra type information is required to set up a type-stable algorithm.)</p><pre><code class="language-julia-repl">julia&gt; Plm_00(::λNorm, T::Type) = sqrt(1 / 4π)
Plm_00 (generic function with 4 methods)</code></pre><p>Finally, we provide methods which encode the cofficients as well:</p><pre><code class="language-julia-repl">julia&gt; function Plm_α(::λNorm, T::Type, l::Integer, m::Integer)
           fac1 = (2l + 1) / ((2l - 3) * (l^2 - m^2))
           fac2 = 4*(l-1)^2 - 1
           return sqrt(fac1 * fac2)
       end
Plm_α (generic function with 4 methods)

julia&gt; function Plm_β(::λNorm, T::Type, l::Integer, m::Integer)
           fac1 = (2l + 1) / ((2l - 3) * (l^2 - m^2))
           fac2 = (l-1)^2 - m^2
           return sqrt(fac1 * fac2)
       end
Plm_β (generic function with 4 methods)

julia&gt; Plm_μ(::λNorm, T::Type, m::Integer) = sqrt(1 + 1 / 2m)
Plm_μ (generic function with 4 methods)

julia&gt; Plm_ν(::λNorm, T::Type, m::Integer) = sqrt(3 + 2m)
Plm_ν (generic function with 4 methods)</code></pre><p>With just those 5 methods provided, the full Legendre framework is available, including precomputing the coefficients.</p><pre><code class="language-julia-repl">julia&gt; legendre(λNorm(), 700, 500, 0.4)
0.35366224602810997

julia&gt; coeff = LegendreNormCoeff{λNorm,Float64}(700);

julia&gt; legendre(coeff, 700, 500, 0.4)
0.35366224602810997</code></pre><hr/><h3 id="Footnotes-1"><a class="docs-heading-anchor" href="#Footnotes-1">Footnotes</a><a class="docs-heading-anchor-permalink" href="#Footnotes-1" title="Permalink"></a></h3><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a><p>Specifically, the envelope of <span>$P_ℓ^m(x)$</span> which bounds the local extrema for all values of <span>$x$</span> can be shown to be</p><div>\[    \left| P_ℓ^m(\cos θ) \right| ≤ \frac{Γ(ℓ+m+1)}{Γ(ℓ+\frac{3}{2})}
        \left( \frac{2}{π \sin θ} \right)^{1/2}\]</div><p>(see Eq. 8.10.7 (p336) of Abramowitz and Stegun, “Handbook of Mathematical Functions” 10th printing (1972)). For fixed <span>$m$</span> and any <span>$x$</span>, we take the asymptotic limit as <span>$ℓ → ∞$</span> and simplify <span>$Γ(z)$</span> via Stirling&#39;s approximation to get the scaling of the associated Legendre polynomial envelope</p><div>\[    \DeclareMathOperator*{\env}{env}
    \env_{ℓ→∞}\left( P_ℓ^m \right) ∝ ℓ^{m - 1/2} \text{ .}\]</div><p>In contrast, the normalization factor <span>$N_ℓ^m$</span> scales as <span>$ℓ^{1/2 - m}$</span>, exactly canceling the scaling of <span>$\env\left(P_ℓ^m\right)$</span>, so overall the spherical harmonic normalized Legendre polynomials <span>$λ_ℓ^m(x)$</span> asymptote to some constant envelope:</p><div>\[    \env_{ℓ→∞} \left( λ_ℓ^m \right) ∝ ℓ^0 = \text{constant .}\]</div></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../healpix/">« HEALPix Pixelization</a><a class="docs-footer-nextpage" href="../references/">References »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 20 December 2019 00:13">Friday 20 December 2019</span>. Using Julia version 1.2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

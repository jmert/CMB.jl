var documenterSearchIndex = {"docs":
[{"location":"man/external/#Re-exported-Packages","page":"Re-exported Packages","title":"Re-exported Packages","text":"","category":"section"},{"location":"man/external/","page":"Re-exported Packages","title":"Re-exported Packages","text":"Some features are simply re-exported functions from other, external packages. These packages have (typically) been extracted from this package since they can be used in a self-contained manner, independently of their application to CMB analysis.","category":"page"},{"location":"man/external/","page":"Re-exported Packages","title":"Re-exported Packages","text":"For more information, see the documentation provided by each of the following packages:","category":"page"},{"location":"man/external/#[AssociatedLegendrePolynomials.jl](https://github.com/jmert/AssociatedLegendrePolynomials.jl)","page":"Re-exported Packages","title":"AssociatedLegendrePolynomials.jl","text":"","category":"section"},{"location":"man/external/","page":"Re-exported Packages","title":"Re-exported Packages","text":"The associated Legendre polynomials (ALPs)constructs part of the eigenfunction basis for functions on the sphere and plays a very important role in analysis of signals on the sphere. In addition, the ALPs are required for the computation of pixel-pixel covariance matrices that this package uniquely provides.","category":"page"},{"location":"man/external/","page":"Re-exported Packages","title":"Re-exported Packages","text":"Note that this package re-exports the AssociatedLegendrePolynomials module under the name Legendre for both backwards compatibility with earlier versions of this package as well as for brevity.","category":"page"},{"location":"man/external/#[SphericalHarmonics.jl](https://github.com/jmert/SphericalHarmonicTransforms.jl)","page":"Re-exported Packages","title":"SphericalHarmonics.jl","text":"","category":"section"},{"location":"man/external/","page":"Re-exported Packages","title":"Re-exported Packages","text":"The spherical harmonic transforms are a key analytical techniques used in analysis of the CMB. They are built on top of the associated Legendre polynomials.","category":"page"},{"location":"man/external/#[Healpix.jl](https://github.com/jmert/Healpix.jl)","page":"Re-exported Packages","title":"Healpix.jl","text":"","category":"section"},{"location":"man/external/","page":"Re-exported Packages","title":"Re-exported Packages","text":"The HEALPix pixelization is a very common mapping format used in CMB (and other fields of astronomy more generally). For instance, this package provides the necessary glue to perform spherical harmonic transforms on a (scalar, i.e. temperature field) map in the HEALPix format.","category":"page"},{"location":"man/pixelcov/#man_pixelcov","page":"Pixel-pixel Covariance","title":"Pixel-Pixel Covariance","text":"","category":"section"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"DocTestFilters = Regex[\n        r\"Ptr{0x[0-9a-f]+}\",\n        r\"[0-9\\.]+ seconds( \\(.*\\))?\",\n        ]","category":"page"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"Pages = [\"pixelcov.md\"]\nDepth = 2","category":"page"},{"location":"man/pixelcov/#pixelcov_defn","page":"Pixel-pixel Covariance","title":"Definition","text":"","category":"section"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"The following definitions are a lightly-modified reproduction of Appendix A of Tegmark & Oliveira-Costa (2001).","category":"page"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"\\providecommand{\\mat}[1]{\\symbf{#1}}\n\\providecommand{\\expv}[1]{\\left\\langle #1\\right\\rangle}\n\\providecommand{\\covF}[1]{F_\\ell^{#1}(z_{ij})}\n\\providecommand{\\covTT}{\\expv{T_i T_j}}\n\\providecommand{\\covTQ}{\\expv{T_i Q_j}}\n\\providecommand{\\covTU}{\\expv{T_i U_j}}\n\\providecommand{\\covQQ}{\\expv{Q_i Q_j}}\n\\providecommand{\\covQU}{\\expv{Q_i U_j}}\n\\providecommand{\\covUU}{\\expv{U_i U_j}}\n\\providecommand{\\cij}{c_{ij}}\n\\providecommand{\\sij}{s_{ij}}\n\\providecommand{\\cji}{c_{ji}}\n\\providecommand{\\sji}{s_{ji}}","category":"page"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"<div style=\"display:none;\">\n\\(\n\\newcommand{\\mat}[1]{\\mathbf{#1}}\n\\newcommand{\\expv}[1]{\\left\\langle #1\\right\\rangle}\n\\newcommand{\\covF}[1]{F_\\ell^{#1}(z_{ij})}\n\\newcommand{\\covTT}{\\expv{T_i T_j}}\n\\newcommand{\\covTQ}{\\expv{T_i Q_j}}\n\\newcommand{\\covTU}{\\expv{T_i U_j}}\n\\newcommand{\\covQQ}{\\expv{Q_i Q_j}}\n\\newcommand{\\covQU}{\\expv{Q_i U_j}}\n\\newcommand{\\covUU}{\\expv{U_i U_j}}\n\\newcommand{\\cij}{c_{ij}}\n\\newcommand{\\sij}{s_{ij}}\n\\newcommand{\\cji}{c_{ji}}\n\\newcommand{\\sji}{s_{ji}}\n\\)\n</div>","category":"page"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"The pixel-pixel covariance is best constructed in stages. We start by defining the covariance langle X_i Y_jrangle between any two Stokes fields X and Y at pixels i and j for a local coordinate system where the Q axis is pointed along the great circle connection pixel i to pixel j. In this simplified case, the 6 unique covariances are","category":"page"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"beginalign\n    covTT equiv frac14pi sum_ell C_ell^TT covF00\n        labeleqntheorycovtt\n    \n    covTQ equiv -frac14pi sum_ell C_ell^TE covF10\n        labeleqntheorycovtq\n    \n    covTU equiv -frac14pi sum_ell C_ell^TB covF10\n        labeleqntheorycovtu\n    \n    covQQ equiv frac14pi sum_ell\n        left C_ell^EE covF12 - C_ell^BB covF22 right\n        labeleqntheorycovqq\n    \n    covUU equiv frac14pi sum_ell\n        left C_ell^BB covF12 - C_ell^EE covF22 right\n        labeleqntheorycovuu\n    \n    covQU equiv frac14pi sum_ell\n        C_ell^EB left covF12 + covF22 right\n        labeleqntheorycovqu\nendalign","category":"page"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"for z_ij = cos(sigma_ij) and some fiducial spectrum C_ell. The polarization weighting functions are simple functions of the P_ell and P_ell^2 associated Legendre polynomials,","category":"page"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"beginalign\n    covF00 equiv (2ell + 1) P_ell(z_ij)\n        labeleqntheorycovF00\n    \n    covF10 equiv chi_ell\n        left\n        fracz_ij1-z_ij^2 P_ell-1(z_ij) - left(\n        frac11-z_ij^2 + fracell-12 right)P_ell(z_ij)\n        right\n        labeleqntheorycovF10\n    \n    covF12 equiv gamma_ell\n        left\n        fracell+21-z_ij^2 z_ij P^2_ell-1(z_ij) - left(\n        fracell-41-z_ij^2 + fracell(ell-1)2 right)\n        P^2_ell(z_ij)\n        right\n        labeleqntheorycovF12\n    \n    covF22 equiv 2gamma_ell\n        left\n        fracell+21-z_ij^2 P^2_ell-1(z_ij) -\n        fracell-11-z_ij^2 z_ij P^2_ell(z_ij)\n        right\n        labeleqntheorycovF22\nendalign","category":"page"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"where[1]","category":"page"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"beginalign\n    chi_ell equiv frac2ell (2ell + 1)\n        sqrt(ell-1)ell(ell+1)(ell+2)\n    \n    gamma_ell equiv frac2(2ell + 1)\n        (ell-1)ell(ell+1)(ell+2)\nendalign","category":"page"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"For a single pixel-pixel pair, the covariance terms form a symmetric 3 times 3 matrix mat M","category":"page"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"beginalign\n    mat M(z_ij) = beginbmatrix\n        covTT  covTQ  covTU \n        covTQ  covQQ  covQU \n        covTU  covQU  covUU\n    endbmatrix\nendalign","category":"page"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"which is rotated from the local to a global Stokes coordinate system by application of the rotation matrix","category":"page"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"beginalign\n    mat R(alpha) = beginbmatrix\n        1  0  0 \n        0  cos(2alpha)  -sin(2alpha) \n        0  sin(2alpha)   cos(2alpha)\n    endbmatrix\nendalign","category":"page"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"where alpha are bearing angles, such that the pixel-pixel covariance mat C_ij in global coordinates is defined by","category":"page"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"beginalign\n    mat C_ij = mat R(alpha_ij) mat M(z_ij) mat R(alpha_ji)^top\n        labeleqntheorycovrotate\nendalign","category":"page"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"Pay attention to the fact that the left-hand mat R uses the bearing angle alpha_ij at pixel i whereas the right-hand mat R uses the bearing angle alpha_ji at pixel j. Also note that these rotations move the covariances into the IAU polarization convention — to move into the HEALPix polarization convention, the rotations both need to be reversed, i.e. mat R leftrightarrow mat R^top.","category":"page"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"The pixel-pixel covariance matrix mat C for some set of pixels is constructed by calculating the terms in mat C_ij for each pair of pixels and filling in the 9 values as the (ij)-th entries of the covariance blocks in mat C. By blocks, we refer to the fact that mat C can be block-decomposed as","category":"page"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"beginalign\n    mat C = beginbmatrix\n        mat C^TT  mat C^TQ  mat C^TU \n        mat C^QT  mat C^QQ  mat C^QU \n        mat C^UT  mat C^UQ  mat C^UU\n    endbmatrix\nendalign","category":"page"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"For example, if one holds j constant and varies i in P across all pixels, then one would form 3 columns of mat C, one in each of the block-columns.","category":"page"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"It is also convenient to define the polarization-only block decompositions of the total covariance matrix as","category":"page"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"beginalign\n    mat C^mathrmPol equiv beginbmatrix\n        mat C^QQ  mat C^QU \n        mat C^UQ  mat C^UU endbmatrix\nendalign","category":"page"},{"location":"man/pixelcov/#pixelcov_theory","page":"Pixel-pixel Covariance","title":"Ideal Pixel-Pixel Covariance","text":"","category":"section"},{"location":"man/pixelcov/#pixelcov_reobs","page":"Pixel-pixel Covariance","title":"Reobserved Pixel-Pixel Covariance","text":"","category":"section"},{"location":"man/pixelcov/#pixelcov_properties","page":"Pixel-pixel Covariance","title":"Properties and Symmetries","text":"","category":"section"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"The entire covariance matrix mat C is symmetric. Therefore the on-diagonal sub-blocks mat C^TT, mat C^QQ, and mat C^UU are individually symmetric as well, and the off-diagonal blocks must be related to one another as\nbeginalign*\n    mat C^TQ = left(mat C^QTright)^top \n    mat C^TU = left(mat C^UTright)^top \n    mat C^QU = left(mat C^UQright)^top\nendalign*\nThis directly implies the polarization-only matrix mat C^mathrmPol is symmetric as well.\nThe covariance matrices mat C, mat C^TT, and mat C^mathrmPol are at least positive-semidefinite for appropriate non-zero fiducial input spectra. Positive-definiteness only occurs when there are at least as many non-zero harmonic modes (C_ell^XY neq 0 over all spectra XY) as there are diagonal elements in the matrix (the number of pixels in the map(s) that the covariance describes).\nThe covariance matrices are linear in the fiducial spectra. For example, an EE-only covariance matrix mat C^EE (wherein all C_ell = 0 except for C_ell^EE which is non-zero somewhere) and an EB-only covariance matrix mat C^EB can be summed to define\nbeginalign*\n    mat C^EEEB = mat C^EE + mat C^EB\nendalign*\nwhich is equivalent to the covariance matrix which would have been produced if the fiducial spectrum had included the both of the C_ell^EE and C_ell^EB spectra from the start.\nSince the IAU and HEALPix polarization conventions differ by the direction of rotation in mat R(alpha) which corresponds to a change in the sign of the sin terms (sij and sji), the cosmologically-interesting case where C_ell^EB = 0 and C_ell^TB = 0 also simplifies such that the following are also true:\nbeginalign*\n    mat C_ijmathrmHealpix^TU = -mat C_ijmathrmIAU^TU \n    mat C_ijmathrmHealpix^UT = -mat C_ijmathrmIAU^UT \n    mat C_ijmathrmHealpix^QU = -mat C_ijmathrmIAU^QU \n    mat C_ijmathrmHealpix^UQ = -mat C_ijmathrmIAU^UQ\nendalign*\nand the remaining block components are unchanged.","category":"page"},{"location":"man/pixelcov/#pixelcov_details","page":"Pixel-pixel Covariance","title":"Mathematical Details","text":"","category":"section"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"It is often useful to have the fully-expanded expressions for each of the pixel-pixel covariance terms after applying the local-to-global coordinate system rotations. If we define short-cut notation for each of the terms in the rotation matrices as","category":"page"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"beginalign*\n    mat R(alpha_ij) equiv beginbmatrix\n        1  0  0 \n        0  cij  -sij \n        0  sij   cij\n    endbmatrix\n    \n    mat R(alpha_ji)^top equiv beginbmatrix\n        1  0  0 \n        0   cji  sji \n        0  -sji  cji\n    endbmatrix\nendalign*","category":"page"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"then expanding Eqn. refeqntheorycovrotate explicitly (and grouping the terms by block-columns):","category":"page"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"beginalign*\n    beginbmatrix\n            mat C_ij^TT  mat C_ij^QT  mat C_ij^UT\n        endbmatrix = beginbmatrix\n            covTT \n            covTQcij - covTUsij \n            covTQsij + covTUcij\n        endbmatrix\n    \n    beginbmatrix\n            mat C_ij^TQ  mat C_ij^QQ  mat C_ij^UQ\n        endbmatrix = beginbmatrix\n            covTQcji - covTUsji \n            covQQcijcji - covQU(cijsji + sijcji) + covUUsijsji \n            covQQsijcji + covQU(cijcji - sijsji) - covUUcijsji\n        endbmatrix\n    \n    beginbmatrix\n            mat C_ij^TU  mat C_ij^QU  mat C_ij^UU\n        endbmatrix = beginbmatrix\n            covTQsji + covTUcji \n            covQQcijsji + covQU(cijcji - sijsji) - covUUsijcji \n            covQQsijsji + covQU(cijsji + sijcji) + covUUcijcji\n        endbmatrix\nendalign*","category":"page"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"","category":"page"},{"location":"man/pixelcov/#Footnotes","page":"Pixel-pixel Covariance","title":"Footnotes","text":"","category":"section"},{"location":"man/pixelcov/","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"[1]: In the limit as z rightarrow 1 (i.e. as the two points given by pointing vectors are [anti-]parallel), the left(1 - z^2right)^-1 terms diverge. The resolution is to special-case the numerical computation and make use of the mathematical limits,beginalign\n    covF10 = rlap0\n        hphantomleft (-1)^ell frac2ell+12 right\n        textas  z_ij to 1\n    \n    covF12 = begincases\n            frac2ell+12             textas  z_ij to +1 \n            frac2ell+12  (-1)^ell  textas  z_ij to -1\n        endcases\n    \n    covF22 = begincases\n            -frac2ell+12            textas  z_ij to +1 \n             frac2ell+12 (-1)^ell  textas  z_ij to -1\n        endcases\nendalignFurthermore, the bearing angle is not well defined for [anti-]parallel points. Thankfully, langle Q_i Q_jrangle = langle U_i U_j rangle and langle Q_i U_j rangle = 0, so the polarization weights are invariant under rotation; therefore we can take alpha = 0 without loss of generality. (See Tegmark & Oliveira-Costa (2001).)","category":"page"},{"location":"lib/private/#Private-Documentation","page":"Private","title":"Private Documentation","text":"","category":"section"},{"location":"lib/private/","page":"Private","title":"Private","text":"This page documents private functions which may be useful but which have no guarantee of stability across any change in versions of this package.","category":"page"},{"location":"lib/private/#Contents","page":"Private","title":"Contents","text":"","category":"section"},{"location":"lib/private/","page":"Private","title":"Private","text":"Pages = [\"private.md\"]","category":"page"},{"location":"lib/private/#Generic-utilities","page":"Private","title":"Generic utilities","text":"","category":"section"},{"location":"lib/private/","page":"Private","title":"Private","text":"Modules = [CMB]\nPublic = false","category":"page"},{"location":"lib/private/#CMB.quadprod-Tuple{SparseArrays.AbstractSparseMatrix, AbstractVecOrMat, Integer}","page":"Private","title":"CMB.quadprod","text":"quadprod(A::AbstractSparseMatrixCSC, b::AbstractVecOrMat, n::Integer)\n\nComputes the quadratic product ABA^top efficiently for the case where B is all zero except for a small number of columns b starting at the nth.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#Sphere-Functions","page":"Private","title":"Sphere Functions","text":"","category":"section"},{"location":"lib/private/","page":"Private","title":"Private","text":"Modules = [CMB.Sphere]\nPublic = false","category":"page"},{"location":"lib/private/#CMB.Sphere.x̂","page":"Private","title":"CMB.Sphere.x̂","text":"const x̂ = SVector(1, 0, 0)\nconst ŷ = SVector(0, 1, 0)\nconst ẑ = SVector(0, 0, 1)\n\nConstant unit vectors in the Cartesian directions.\n\n\n\n\n\n","category":"constant"},{"location":"lib/private/#CMB.Sphere.ŷ","page":"Private","title":"CMB.Sphere.ŷ","text":"const x̂ = SVector(1, 0, 0)\nconst ŷ = SVector(0, 1, 0)\nconst ẑ = SVector(0, 0, 1)\n\nConstant unit vectors in the Cartesian directions.\n\n\n\n\n\n","category":"constant"},{"location":"lib/private/#CMB.Sphere.ẑ","page":"Private","title":"CMB.Sphere.ẑ","text":"const x̂ = SVector(1, 0, 0)\nconst ŷ = SVector(0, 1, 0)\nconst ẑ = SVector(0, 0, 1)\n\nConstant unit vectors in the Cartesian directions.\n\n\n\n\n\n","category":"constant"},{"location":"lib/private/#CMB.Sphere.:∥-Tuple{Any, Any}","page":"Private","title":"CMB.Sphere.:∥","text":"∥(u, v) -> Bool\n\nTest whether vector u is parallel to vector v. Assumes that both are unit normalized.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#CMB.Sphere.cartvec-Tuple{Any, Any}","page":"Private","title":"CMB.Sphere.cartvec","text":"r = cartvec(θ, ϕ)\nr = cartvec((θ, ϕ))\n\nConverts the colatitude-azimuth pair (θ ϕ) to a Cartesian unit vector r.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#CMB.Sphere.colataz-Tuple{Any, Any}","page":"Private","title":"CMB.Sphere.colataz","text":"θ, ϕ = colataz(δ, λ)\nθ, ϕ = colataz((δ, λ))\n\nConverts the latitude-longitude pair (δ λ) in degrees to colatitude-azimuth (θ ϕ) in radians.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#CMB.Sphere.colataz-Tuple{StaticArraysCore.SVector{3}}","page":"Private","title":"CMB.Sphere.colataz","text":"θ, ϕ = colataz(r)\n\nConverts the Cartesian unit vector r to a colatitude-azimuth pair (θ ϕ) in radians.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#CMB.Sphere.latlon-Tuple{Any, Any}","page":"Private","title":"CMB.Sphere.latlon","text":"δ, λ = latlon(θ, ϕ)\nδ, λ = latlon((θ, ϕ))\n\nConverts the colatitude-azimuth pair (θ ϕ) in radians to latitude-longitude (δ λ) in radians.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#CMB.Sphere.latlon-Tuple{StaticArraysCore.SVector{3}}","page":"Private","title":"CMB.Sphere.latlon","text":"δ, λ = latlon(r)\n\nConverts the Cartesian unit vector r to a latitude-longitude pair (δ λ) in degrees.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#Pixel-Covariance","page":"Private","title":"Pixel Covariance","text":"","category":"section"},{"location":"lib/private/","page":"Private","title":"Private","text":"Modules = [CMB.PixelCovariance]\nPublic = false","category":"page"},{"location":"man/sphere/#man_sphere","page":"Spherical Functions","title":"Spherical Functions","text":"","category":"section"},{"location":"man/sphere/","page":"Spherical Functions","title":"Spherical Functions","text":"Pages = [\"sphere.md\"]\nDepth = 2","category":"page"},{"location":"man/sphere/","page":"Spherical Functions","title":"Spherical Functions","text":"A key aspect of computing pixel-pixel covariance is calculating relative orientations of the two pixels on the sphere. The Sphere module implements a few basic spherical functions.","category":"page"},{"location":"man/sphere/#sphere_defn","page":"Spherical Functions","title":"Definitions","text":"","category":"section"},{"location":"man/sphere/","page":"Spherical Functions","title":"Spherical Functions","text":"A colatitude-azimuth pair (theta phi) are coordinates on the sphere measuring the angular distance (in radians) from the North pole and east of the Prime Meridian, respectively. The coordinates will typically be normalized to the range theta in 0 pi and phi in 0 2pi).\nA latitude-longitude pair (delta lambda) are coordinates on the sphere measuring the angular distance (in degrees) north or south of the Equator and east or west of the Prime Meridian, respectively. The coordinates will typically be normalized to the range delta in -90 90 and lambda in -180 180.\nA Cartesian unit vector vec r centered at the origin of a sphere has its end-point at a location on the unit sphere. The coordinate system is right-handed, with the North Pole located at hat z = 0 0 1 and the intersection of the Prime Meridian and Equator located at hat x = 1 0 0.","category":"page"},{"location":"man/sphere/","page":"Spherical Functions","title":"Spherical Functions","text":"In general, the function throughout the CMB package will take either colatitude-azimuth or unit vector coordinates.","category":"page"},{"location":"man/sphere/#sphere_usage","page":"Spherical Functions","title":"Usage","text":"","category":"section"},{"location":"man/sphere/","page":"Spherical Functions","title":"Spherical Functions","text":"Conversion between colatitude-azimuth pairs, latitude-longitude pairs, and unit vectors can be accomplished via the unexported functions Sphere.colataz, Sphere.latlon, and Sphere.cartvec.","category":"page"},{"location":"man/sphere/","page":"Spherical Functions","title":"Spherical Functions","text":"julia> using CMB.Sphere\n\njulia> using CMB.Sphere: colataz, latlon, cartvec\n\njulia> δ, λ = 44.97531, -93.23471;  # Tate Lab @ Univ. of Minnesota\n\njulia> θ, ϕ = colataz(δ, λ)         # lat-lon to colat-az\n(0.7858290851897657, 4.655932640537504)\n\njulia> latlon(θ, ϕ)                 # colat-az to lat-lon\n(44.97531, -93.23471)\n\njulia> r = cartvec(θ, ϕ)            # colat-az to unit vector\n3-element SVector{3, Float64} with indices SOneTo(3):\n -0.03991664732478908\n -0.7062843499648845\n  0.7068020078218715\n\njulia> colataz(r)       # unit vector to colat-az\n(0.7858290851897657, 4.655932640537504)\n\njulia> latlon(r)        # unit vector to lat-lon\n(44.97531000000001, -93.23471000000002)","category":"page"},{"location":"man/sphere/","page":"Spherical Functions","title":"Spherical Functions","text":"Given two points on the sphere — represented as either a unit vector or a colatitude-azimuth pair — we can query for the angular distance between the two points with the distance function:","category":"page"},{"location":"man/sphere/","page":"Spherical Functions","title":"Spherical Functions","text":"julia> r₁ = cartvec(colataz(-0.18114, -78.46762)); # Quito, Ecuador\n\njulia> r₂ = cartvec(colataz(69.64906,  18.95454)); # Tromsø, Norway\n\njulia> σ = distance(r₁, r₂)\n1.6187031137492613","category":"page"},{"location":"man/sphere/","page":"Spherical Functions","title":"Spherical Functions","text":"In situations where the cosine of the separation is required instead — such as for Legendre polynomial calculations — it is more efficient to directly return the cosine of the angle with the cosdistance function:","category":"page"},{"location":"man/sphere/","page":"Spherical Functions","title":"Spherical Functions","text":"julia> cosdistance(r₁, r₂)\n-0.047888464230114274","category":"page"},{"location":"man/sphere/","page":"Spherical Functions","title":"Spherical Functions","text":"The angular separation alone is insufficient for describing the relative orientation of the two points; the orientation angle of the great circle connecting the two must be given with respect to some reference. A common choice is the bearing angle[1]. It measures the angle between the meridian (at one of the points) and the great circle connecting the two, as shown by the angle alpha_ij in Figure 1.","category":"page"},{"location":"man/sphere/","page":"Spherical Functions","title":"Spherical Functions","text":"![Diagram of a sphere with two red vectors pointing to places on the sphere (r_i and r_j).\nThe bearing angle α_ij is shown as a short purple arc spanning between the blue and\ngreen great circles where they intersect at r_i](sphereangles.svg)\n\nExample showing the angular separation ``\\sigma_{ij}`` and bearing\nangle ``\\alpha_{ij}`` between a pair of coordinates ``r_i`` and ``r_j``. The green\narc indicates the great circle path passing between both coordinates, and the\nblue arc is the meridian which passes through ``r_i``. Only the bearing angle\nat ``r_i`` is shown; a second bearing angle ``\\alpha_{ji}`` at ``r_j`` also exists\n(and is in general different than ``\\alpha_{ij}``) but is not shown.\nThe additional vectors ``\\hat{n}_i^*`` and ``\\hat{n}_{ij}`` are used to\nderive the distance and bearing angle calculations and can be ignored.\n\n*The figure is reproduced from Appendix E of [J. Willmert](@ref bib-bicepkeck).*","category":"page"},{"location":"man/sphere/","page":"Spherical Functions","title":"Spherical Functions","text":"The bearing function calculates the bearing angle at the first point for the great circle connecting the pair of points. Continuing with examples using r₁ and r₂ as defined above,","category":"page"},{"location":"man/sphere/","page":"Spherical Functions","title":"Spherical Functions","text":"julia> α₁ = bearing(r₁, r₂)\n0.35250686784416724","category":"page"},{"location":"man/sphere/","page":"Spherical Functions","title":"Spherical Functions","text":"Be careful to remember that the order of coordinates is important! The bearing angle at r₁ (in Ecuador near the equator) toward r₂ (in northern Norway) is north-northeast as expected. Reversing the coordinates,","category":"page"},{"location":"man/sphere/","page":"Spherical Functions","title":"Spherical Functions","text":"julia> α₂ = bearing(r₂, r₁)\n-1.4503517603957734","category":"page"},{"location":"man/sphere/","page":"Spherical Functions","title":"Spherical Functions","text":"the bearing at r₂ is almost directly west instead.","category":"page"},{"location":"man/sphere/","page":"Spherical Functions","title":"Spherical Functions","text":"Like with distance and cosdistance, the bearing angle itself is not always necessary, and the instead vector components (cosine and sine of the angle) are sufficient. In such a case, it is more efficient to forego the inverse trigonometric operations and instead use bearing2:","category":"page"},{"location":"man/sphere/","page":"Spherical Functions","title":"Spherical Functions","text":"julia> δn, δe = bearing2(r₁, r₂)\n(0.9385101625713766, 0.34525161078588545)","category":"page"},{"location":"man/sphere/","page":"Spherical Functions","title":"Spherical Functions","text":"For instance, calculating cos(2alpha) and sin(2alpha) can be calculated easily a couple of trigonometric identities and is faster.","category":"page"},{"location":"man/sphere/","page":"Spherical Functions","title":"Spherical Functions","text":"The inverse operation is reckon which calculates the coordinate of a point which is a given distance and direction away from a reference point. Given the angular distance σ and bearing α₁ from before, we can reconstruct r₂:","category":"page"},{"location":"man/sphere/","page":"Spherical Functions","title":"Spherical Functions","text":"julia> using LinearAlgebra: dot\n\njulia> reckon(r₁, σ, α₁)\n3-element SVector{3, Float64} with indices SOneTo(3):\n 0.3289121239720345\n 0.11296169792358199\n 0.937580113647056\n\njulia> dot(ans, r₂)     # == 1 if ans is parallel to r₂\n1.0","category":"page"},{"location":"man/sphere/","page":"Spherical Functions","title":"Spherical Functions","text":"[1]: The bearing angle is also sometimes called the azimuth angle, but to   avoid confusion with use of azimuth in colatitude-azimuth coordinates we   will exclusively use the term bearing.","category":"page"},{"location":"man/references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"man/references/#bib-bicepkeck","page":"References","title":"BICEP/Keck","text":"","category":"section"},{"location":"man/references/","page":"References","title":"References","text":"J. Tolan. “Testing Inflationary Cosmology with BICEP2 and the Keck Array”. PhD Thesis. Stanford University, Aug. 2014. URL: http://purl.stanford.edu/sr837cd9569\nThe BICEP/Keck Array Collaboration. “BICEP/Keck Array VII: Matrix Based E/B Separation Applied to BICEP2 and the Keck Array” In: The Astrophysical Journal 825, 66 (Jul 2016) DOI: 10.3847/0004-637X/825/1/66 arXiv: 1603.05976\nJ. Willmert. “Constraining Inflationary B-modes with the BICEP/Keck Array Telescopes”. PhD Thesis. University of Minnesota, Nov 2019. URL: http://hdl.handle.net/11299/211821","category":"page"},{"location":"man/references/#bib-coordinates","page":"References","title":"Coordinate systems and conventions","text":"","category":"section"},{"location":"man/references/","page":"References","title":"References","text":"J. P. Hamaker and J. D. Bregman. “Understanding radio polarimetry. III. Interpreting the IAU/IEEE definitions of the Stokes parameters.” In: Astronomy and Astrophysics, Supplement Series 117 (May 1996) pp. 161–165. DOI: 10.1051/aas:1996147","category":"page"},{"location":"man/references/#bib-pixelcovariance","page":"References","title":"Pixel Covariance","text":"","category":"section"},{"location":"man/references/","page":"References","title":"References","text":"M. Tegmark and A. de Oliveira-Costa. “How to measure CMB polarization power spectra without losing information” In: Physical Review D 64, 063001 (Sep 2001) DOI: 10.1103/PhysRevD.64.063001 arXiv: astro-ph/0012120","category":"page"},{"location":"lib/public/#Public-Documentation","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"lib/public/#Contents","page":"Public","title":"Contents","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"lib/public/#Sphere-Functions","page":"Public","title":"Sphere Functions","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Modules = [CMB.Sphere]\nPrivate = false","category":"page"},{"location":"lib/public/#CMB.Sphere","page":"Public","title":"CMB.Sphere","text":"Collection of routines for working with coordinates on the sphere.\n\n\n\n\n\n","category":"module"},{"location":"lib/public/#CMB.Sphere.bearing","page":"Public","title":"CMB.Sphere.bearing","text":"Calculates the bearing angle (α), defined as the angle between the meridian (at the first coordinate) and the great circle connecting the first coordinate to the second. Angles are measured eastward of north and will be in the range -ππ. See also bearing2.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Sphere.bearing-NTuple{4, Any}","page":"Public","title":"CMB.Sphere.bearing","text":"α = bearing(θ₁, ϕ₁, θ₂, ϕ₂)\n\nPoints on the sphere are given as coordinate pairs (θ₁ϕ₁) and (θ₂ϕ₂) where θ is the colatitude angle from the North Pole and ϕ is the azimuthal angle, both in radians.\n\nExamples\n\njulia> bearing(π/2, 0.0, π/4, π/4)\n0.6154797086703873\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Sphere.bearing-Tuple{AbstractVector, AbstractVector}","page":"Public","title":"CMB.Sphere.bearing","text":"α = bearing(r₁, r₂)\n\nPoints on the sphere are given as unit vectors r₁ and r₂.\n\nExamples\n\njulia> bearing([1.0, 0.0, 0.0], [0.5, 0.5, sqrt(2)/2])\n0.6154797086703873\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Sphere.bearing2","page":"Public","title":"CMB.Sphere.bearing2","text":"Calculates the north/east vector components of the bearing angle (i.e. δn = cos(α) δe = sin(α)), defined as the angle between the meridian (at the first coordinate) and the great circle connecting the first coordinate to the second. See also bearing.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Sphere.bearing2-NTuple{4, Any}","page":"Public","title":"CMB.Sphere.bearing2","text":"(δn, δe) = bearing2(θ₁, ϕ₁, θ₂, ϕ₂)\n\nPoints on the sphere are given as coordinate pairs (θ₁ϕ₁) and (θ₂ϕ₂) where θ is the colatitude angle from the North Pole and ϕ is the azimuthal angle, both in radians.\n\nExamples\n\njulia> bearing2(π/2, 0.0, π/4, π/4)\n(0.8164965809277261, 0.5773502691896257)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Sphere.bearing2-Tuple{AbstractVector, AbstractVector}","page":"Public","title":"CMB.Sphere.bearing2","text":"(δn, δe) = bearing2(r₁, r₂)\n\nPoints on the sphere are given as unit vectors r₁ and r₂.\n\nExamples\n\njulia> bearing2([1.0, 0.0, 0.0], [0.5, 0.5, sqrt(2)/2])\n(0.816496580927726, 0.5773502691896257)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Sphere.cosdistance","page":"Public","title":"CMB.Sphere.cosdistance","text":"Calculates the cosine of the inner angle (z) between unit vectors pointing from the center of the sphere to two points on its surface.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Sphere.cosdistance-NTuple{4, Any}","page":"Public","title":"CMB.Sphere.cosdistance","text":"z = cosdistance(θ₁, ϕ₁, θ₂, ϕ₂)\n\nPoints on the sphere are given as coordinate pairs (θ₁ϕ₁) and (θ₂ϕ₂) where θ is the colatitude angle from the North Pole and ϕ is the azimuthal angle, both in radians.\n\nExamples\n\njulia> cosdistance(π/2, 0.0, π/4, π/4)\n0.5\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Sphere.cosdistance-Tuple{AbstractVector, AbstractVector}","page":"Public","title":"CMB.Sphere.cosdistance","text":"z = cosdistance(r₁, r₂)\n\nPoints on the sphere are given as unit vectors r₁ and r₂.\n\nExamples\n\njulia> cosdistance([1.,0.,0.], [0.5,0.5,sqrt(2)/2])\n0.5\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Sphere.distance","page":"Public","title":"CMB.Sphere.distance","text":"Calculates the inner angle (σ) between unit vectors pointing from the center of the sphere to two points on its surface.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Sphere.distance-NTuple{4, Any}","page":"Public","title":"CMB.Sphere.distance","text":"σ = distance(θ₁, ϕ₁, θ₂, ϕ₂)\n\nPoints on the sphere are given as coordinate pairs (θ₁ϕ₁) and (θ₂ϕ₂) where θ is the colatitude angle from the North Pole and ϕ is the azimuthal angle, both in radians.\n\nExamples\n\njulia> distance(π/2, 0.0, π/4, π/4)\n1.0471975511965979\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Sphere.distance-Tuple{AbstractVector, AbstractVector}","page":"Public","title":"CMB.Sphere.distance","text":"σ = distance(r₁, r₂)\n\nPoints on the sphere are given as unit vectors r₁ and r₂.\n\nExamples\n\njulia> distance([1.,0.,0.], [0.5,0.5,sqrt(2)/2])\n1.0471975511965979\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Sphere.reckon","page":"Public","title":"CMB.Sphere.reckon","text":"Calculates a position on the sphere a given distance (σ, in radians) and relative bearing angle (α, in radians) away from a given point (measuring the eastward-of-north orientation of the great circle connecting the source and destination points with respect to the merdian passing through the source).\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Sphere.reckon-NTuple{4, Any}","page":"Public","title":"CMB.Sphere.reckon","text":"(θ′, ϕ′) = reckon(θ, ϕ, σ, α)\n\nThe point on the sphere is given by the colatitude-azimuth pair (θ ϕ), both given in radians.\n\nnote: Note\nWhen r points to either the north or south pole, the meridian is defined to be θ meridian, and the bearing angle α is oriented with respect to it.For example, moving a distance π2 with no bearing goes to the equator, with the longitude dependent on the input longitude:julia> reckon(0.0, 0.0, π/2, 0.0)\n(1.5707963267948966, 3.141592653589793)\n\njulia> reckon(0.0, π/2, π/2, 0.0)\n(1.5707963267948966, 4.71238898038469)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Sphere.reckon-Tuple{AbstractVector, Any, Any}","page":"Public","title":"CMB.Sphere.reckon","text":"r′ = reckon(r::AbstractVector, σ, α)\n\nThe point on the sphere is given as a unit vector r.\n\nnote: Note\nWhen r points to either the north or south pole, the meridian is defined to be prime meridian and the bearing angle α is oriented with respect to it.For example, moving a distance π2 with no bearing goes to the negative x axis (i.e. 0° N, 180° W):julia> reckon([0.0, 0.0, 1.0], π/2, 0.0)\n3-element SVector{3, Float64} with indices SOneTo(3):\n -1.0\n  0.0\n  6.123233995736766e-17\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Pixelizations","page":"Public","title":"Pixelizations","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Modules = [CMB.Pixelizations]\nPrivate = false","category":"page"},{"location":"lib/public/#CMB.Pixelizations.AbstractPixelization","page":"Public","title":"CMB.Pixelizations.AbstractPixelization","text":"AbstractPixelization\n\nThe supertype of various pixelization formats.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CMB.Pixelizations.ArbitraryPixelization","page":"Public","title":"CMB.Pixelizations.ArbitraryPixelization","text":"struct ArbitraryPixelization <: AbstractPixelization\n\nAn arbitrary pixelization format (i.e. one without any implied structure) where pixel centers are given as a vector of unit vectors.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CMB.Pixelizations.HealpixPixelization","page":"Public","title":"CMB.Pixelizations.HealpixPixelization","text":"struct HealpixPixelization <: AbstractPixelization\n\nA HEALPix pixelization of a particular resolution (N_mathrmside). May optionally also describe a subset of the sphere, containing an explicit list of pixels to subset.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CMB.Pixelizations.RADecPixelization","page":"Public","title":"CMB.Pixelizations.RADecPixelization","text":"struct RADecPixelization <: AbstractPixelization\n\nAn equidistant cylindrical projection described in terms of a square grid of pixels by their right ascension (RA) and declination (Dec) coordinates (in degrees).\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CMB.Pixelizations.export_pixelization","page":"Public","title":"CMB.Pixelizations.export_pixelization","text":"Exports a given instance of AbstractPixelization to a \"simple\" data type representation suitable for export to disk.\n\nSee also parse_pixelization.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Pixelizations.export_pixelization-Tuple{ArbitraryPixelization}","page":"Public","title":"CMB.Pixelizations.export_pixelization","text":"export_pixelization(pix::ArbitraryPixelization)\n\nReturns a 3×N matrix that describes the given set of arbitrary pixel centers, pix. See also parse_pixelization.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Pixelizations.export_pixelization-Tuple{HealpixPixelization}","page":"Public","title":"CMB.Pixelizations.export_pixelization","text":"export_pixelization(pix::HealpixPixelization)\n\nReturns a Dict{String} appropriate for serializing to disk that describes the given HEALPix pixelization, pix. See also parse_pixelization.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Pixelizations.export_pixelization-Tuple{RADecPixelization}","page":"Public","title":"CMB.Pixelizations.export_pixelization","text":"export_pixelization(pix::RADecPixelization)\n\nReturns a Dict{String} appropriate for serializing to disk that describes the given RA/Dec pixelization, pix. See also parse_pixelization.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Pixelizations.parse_pixelization","page":"Public","title":"CMB.Pixelizations.parse_pixelization","text":"Parses a number of recognizable pixelization specifications, returning a subtype of CMB.AbstractPixelization.\n\nSee also export_pixelization.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Pixelizations.parse_pixelization-Tuple{AbstractDict{String}}","page":"Public","title":"CMB.Pixelizations.parse_pixelization","text":"parse_pixelization(pixelspec::AbstractDict{String})\n\nAttempts to parse an AbstractDict containing a pixelization description.  The dictionary is expected to contain a field \"type\" which specifies the pixelization scheme name, which is used to dispatch for further format-specific processing.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Pixelizations.parse_pixelization-Tuple{AbstractMatrix}","page":"Public","title":"CMB.Pixelizations.parse_pixelization","text":"parse_pixelization(pixelspec::AbstractMatrix)\nparse_pixelization(pixelspec::AbstractVector{SVector{3,<:Any}}})\n\nInterprets a collection of unit 3-vectors as a set of arbitrary pixels on the sphere, returning an instance of ArbitraryPixelization. The input may be either a vector of SVector{3} unit vectors or a 3×N matrix where each column is interpreted as a single unit vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Pixelizations.parse_pixelization-Tuple{Val{:healpix}, AbstractDict{String}}","page":"Public","title":"CMB.Pixelizations.parse_pixelization","text":"parse_pixelization(::Val{:healpix}, pixelspec::AbstractDict{String,<:Any})\n\nParses a dictionary describing a HEALPix pixelization, returning an instance of HealpixPixelization.\n\npixelspec is must conform to the following format to be parsed:\n\nDict(\"type\" => \"healpix\",\n     \"nside\" => #= Nside value =#,\n     \"pixels\" => #= vector of HEALPix pixel indices, or if not provided implied to be a\n                    full-sky grid spanning pixels `0:nside2npix(nside)-1` =#\n    )\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Pixelizations.parse_pixelization-Tuple{Val{:radec}, AbstractDict{String}}","page":"Public","title":"CMB.Pixelizations.parse_pixelization","text":"parse_pixelization(::Val{:radec}, pixelspec::AbstractDict{String})\n\nParses a dictionary describing an equidistance cylindrical projection given in terms of right ascension (RA) and declination (Dec) coordinates, returning an instance of RADecPixelization.\n\npixelspec is must conform to the following format to be parsed:\n\nDict(\"type\" => \"radec\",\n     \"ra\" => #= vector of uniformly-spaced pixel centers along the RA axis, in degrees =#,\n     \"dec\" => #= vector of uniformly-spaced pixel centers along the Dec axis, in degrees =#,\n     \"order\" => #= either \"row\" or \"col\" for row/column-major unravelling =#,\n    )\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Pixelizations.pointing","page":"Public","title":"CMB.Pixelizations.pointing","text":"pointing(pix::AbstractPixelization)\n\nReturns a Vector of SVector{3} unit-vectors pointing to the centers of the pixels described by pix.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#File-I/O","page":"Public","title":"File I/O","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"CMB.Files.read_obsmat\nCMB.Files.READ_OBSMAT_MMAP\nCMB.Files.READ_OBSMAT_MMAP_FLAGS\nCMB.Files.write_obsmat","category":"page"},{"location":"lib/public/#CMB.Files.read_obsmat","page":"Public","title":"CMB.Files.read_obsmat","text":"R, metadata = read_obsmat(filename::String; keywords...)\n\nRead a sparse observing matrix R and the corresponding metadata metadata from filename. The metadata data will include the following fields:\n\nfields: a description of the Stokes fields for which the observing matrix applies — e.g. the value \"QU\" signals that R is the block matrix [R_QQ R_QU; R_UQ R_UU].\npixels_right: a description of the \"right-hand side\" pixelization format of the observing matrix — i.e. the pixelization of a map vector v for which the matrix-vector multiplication R v is defined.\npixels_left: a description of the \"left-hand side\" pixelication format of the observing matrix — i.e. the pixelization of a map vector w which results from the matrix-vector multiplication w = R v.\n\nThe metadata fields are loaded from datasets named by keyword arguments of the same name. Any keyword set to nothing indicates that the corresponding data should not be loaded. The data types are format- and situation-specific. It is not an error for the named dataset to not exist, and if the dataset does not exist, the field of the metadata named tuple will be filled with the value missing.\n\nThe observing matrix dataset within the data file is given by the keyword name and defaults to \"R\". It is an error for the named dataset to not exist (if not nothing).\n\nSee also: write_obsmat\n\nExtended help\n\nBackends\n\nThe HDF5.jl storage backend is always loaded with CMB.jl and is considered the native storage format. See write_obsmat for writing a native HDF5 file to disk.\n\nImporting observing matrices from the following additional data formats is supported via Requires.jl, which requires the user to first load the extra backend of choice.\n\nJLD and JLD2-flavored HDF5 files with JLD.jl (v0.12+) and JLD2.jl, respectively.\nMATLAB v5, v6, v7, and v7.3 save files with MAT.jl (v0.10+).\nscipy.sparse CSC and CSR matrices saved to HDF5 files with h5sparse. This case is supported without needing to load any extra packages.\n\nThe pixelization descriptions are imported as data format specific types. For instance, all formats support loading strings and simple numerical scalars or arrays. Additionally, JLD and JLD2 formats can load named datasets as arbitrary Julia types, MATLAB structs are deserialized as Dicts, and named HDF5 groups are read as (nested) Dicts.\n\n\n\n\n\nread_obsmat(file::FileIO.File{format\"HDF5\"};\n            mmap::Union{Bool,Val{true},Val{false}} = READ_OBSMAT_MMAP[],\n            keywords...)\n\nReads an observing matrix and pixelization descriptors from an HDF5 file. The native format as written by write_obsmat as well as h5sparse-formatted data structures are supported.\n\nWith HDF5 files in the native format, the additional keyword mmap argument controls whether the observing matrix arrays are loaded via memory-mapping or not. If memory-mapped on Unix systems, the MADV_WILLNEED advice will be applied to the arrays. Additionally, on Linux systems, the memory mapping includes the MAP_POPULATE flag to pre-fault the data pages into active RAM. The default behavior is controlled by the global Ref READ_OBSMAT_MMAP.\n\n\n\n\n\nread_obsmat(file::FileIO.File{format\"JLD\"}; keywords...)\n\nReads an observing matrix and pixelization descriptors from a JLD-formatted HDF5 file. This function is conditionally included via Requires.jl and requires the user to import JLD or using JLD first.\n\n\n\n\n\nread_obsmat(file::FileIO.File{format\"JLD2\"}; keywords...)\n\nReads an observing matrix and pixelization descriptors from a JLD2-formatted HDF5 file. This function is conditionally included via Requires.jl and requires the user to import JLD2 or using JLD2 first.\n\n\n\n\n\nread_obsmat(file::FileIO.File{format\"MAT\"}; keywords...)\n\nReads an observing matrix and pixelization descriptors from a MATLAB save file in v5, v6, v7, or v7.3 format. This function is conditionally included via Requires.jl and requires the user to import MAT or using MAT first.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Files.READ_OBSMAT_MMAP","page":"Public","title":"CMB.Files.READ_OBSMAT_MMAP","text":"READ_OBSMAT_MMAP = Ref{Bool}(true)\n\nControls the default memory mapping behavior of read_obsmat. Defaults to true.\n\n\n\n\n\n","category":"constant"},{"location":"lib/public/#CMB.Files.READ_OBSMAT_MMAP_FLAGS","page":"Public","title":"CMB.Files.READ_OBSMAT_MMAP_FLAGS","text":"READ_OBSMAT_MMAP_FLAGS = Ref{UnixMmap.MmapFlags}(MAP_SHARED)\n\nControls the flags passed to mmap when read_obsmat memory maps the observing matrix arrays. Defaults to MAP_SHARED on all systems, with Linux also including MAP_POPULATE by default.\n\n\n\n\n\n","category":"constant"},{"location":"lib/public/#CMB.Files.write_obsmat","page":"Public","title":"CMB.Files.write_obsmat","text":"write_obsmat(filename::String, obsmat::SparseMatrixCSC;\n             obsmat_name::String = \"R\",\n             fields = missing, fields_name::String = \"fields\",\n             pixels_right = missing, pixels_right_name::String = \"pixels_right\",\n             pixels_left  = missing, pixels_left_name::String  = \"pixels_left\")\n\nWrite an observing matrix obsmat to the HDF5 file filename. If the file exists, it will be overwritten completely (to ensure proper data alignment required for memory mapping), otherwise it will be created.\n\nAdditional metadata — pixelization descriptions pixels_right and pixels_left and an annotation of the Stokes field the observing matrix applies to fields —  may also be provided; for a missing value, the description will not be written to disk.\n\nThe HDF5 dataset and group names of the observing matrix and metadata can be changed from their defaults by setting the associated *_name keywords which effect.\n\nSee also: read_obsmat\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#Pixel-Covariance","page":"Public","title":"Pixel Covariance","text":"","category":"section"},{"location":"lib/public/","page":"Public","title":"Public","text":"Modules = [CMB.PixelCovariance]\nPrivate = false","category":"page"},{"location":"lib/public/","page":"Public","title":"Public","text":"The following enums/bit flags are not exported globally, but all of the named values can be imported into a scope by using the parent module (e.g. to access all of the covariance field constants, use using CMB.PixelCovariance.CovarianceFields.","category":"page"},{"location":"lib/public/","page":"Public","title":"Public","text":"CMB.PolarizationConventions.Convention\nCMB.StokesCrossFields.Field\nCMB.StokesCrossFields.TPol\nCMB.StokesCrossFields.Pol","category":"page"},{"location":"lib/public/#CMB.PolarizationConventions.Convention","page":"Public","title":"CMB.PolarizationConventions.Convention","text":"@enum Convention IAUConv HealpixConv\n\nAn enumeration to specify the two types of polarization conventions used to describe Stokes Q/U coordinate systems.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CMB.StokesCrossFields.Field","page":"Public","title":"CMB.StokesCrossFields.Field","text":"@bitflag Field TT QT UT TQ QQ UQ TU QU UU NO_FIELD=0\n\nA bitfield for identifying combinations of Stokes fields. There are 9 subblocks, named as the Cartesian product of elements T, Q, and U:\n\nTT  TQ  TU\nQT  QQ  QU\nUT  UQ  UU\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CMB.StokesCrossFields.TPol","page":"Public","title":"CMB.StokesCrossFields.TPol","text":"const TPol = QT | UT | TQ | TU\n\nAn alias for the temperature-cross-polarization Stokes field combinations.\n\n\n\n\n\n","category":"constant"},{"location":"lib/public/#CMB.StokesCrossFields.Pol","page":"Public","title":"CMB.StokesCrossFields.Pol","text":"const Pol  = QQ | UQ | QU | UU\n\nAn alias for the polarization-only sub-blocks Stokes field combinations.\n\n\n\n\n\n","category":"constant"},{"location":"#CMB.jl-Documentation","page":"CMB.jl Documentation","title":"CMB.jl Documentation","text":"","category":"section"},{"location":"","page":"CMB.jl Documentation","title":"CMB.jl Documentation","text":"CMB.jl is a library of routines for the analysis of cosmic microwave background (CMB) data. Development of features is being driven by the author's use cases — at this time, namely the production of “reobserved” pixel-pixel covariance matrices as used by the BICEP/Keck Array collaboration.","category":"page"},{"location":"","page":"CMB.jl Documentation","title":"CMB.jl Documentation","text":"Design goals of this package include:","category":"page"},{"location":"","page":"CMB.jl Documentation","title":"CMB.jl Documentation","text":"Native Julia implementation of core routines.\nNumerical stability and efficiency.\nParallelism and efficient memory sharing.","category":"page"},{"location":"#User-Manual-and-Documentation","page":"CMB.jl Documentation","title":"User Manual and Documentation","text":"","category":"section"},{"location":"","page":"CMB.jl Documentation","title":"CMB.jl Documentation","text":"Pages = [\n    \"man/external.md\",\n    \"man/sphere.md\",\n    \"man/obsmat.md\",\n    \"man/pixelcov.md\",\n    \"man/references.md\"\n]\nDepth = 1","category":"page"},{"location":"#Library-API-Reference","page":"CMB.jl Documentation","title":"Library API Reference","text":"","category":"section"},{"location":"","page":"CMB.jl Documentation","title":"CMB.jl Documentation","text":"Pages = [\n    \"lib/public.md\",\n    \"lib/private.md\"\n]\nDepth = 1","category":"page"},{"location":"man/obsmat/#man_obsmat","page":"Observing Matrices","title":"Observing Matrices","text":"","category":"section"},{"location":"man/obsmat/","page":"Observing Matrices","title":"Observing Matrices","text":"Pages = [\"obsmat.md\"]\nDepth = 2","category":"page"},{"location":"man/obsmat/","page":"Observing Matrices","title":"Observing Matrices","text":"\\providecommand{\\mat}[1]{\\symbf{#1}}\n\\providecommand{\\expv}[1]{\\left\\langle #1\\right\\rangle}","category":"page"},{"location":"man/obsmat/","page":"Observing Matrices","title":"Observing Matrices","text":"<div style=\"display:none;\">\n\\(\n\\newcommand{\\mat}[1]{\\mathbf{#1}}\n\\newcommand{\\expv}[1]{\\left\\langle #1\\right\\rangle}\n\\)\n</div>","category":"page"},{"location":"man/obsmat/#Introduction","page":"Observing Matrices","title":"Introduction","text":"","category":"section"},{"location":"man/obsmat/","page":"Observing Matrices","title":"Observing Matrices","text":"A fundamental fact about CMB observations is that any given map is filtered in some way. For instance, ground-based experiments apply timestream filters to mitigate the contribution of atmospheric noise, and even full-sky experiments such as WMAP and Planck must mask out the galactic plane.","category":"page"},{"location":"man/obsmat/","page":"Observing Matrices","title":"Observing Matrices","text":"Generically, any map making procedure can be encoded as some function which transforms an idealized (pixelized) map mathat m into an observed map mattilde m. If the function is a linear operation, then it can be encoded as a so-called observing matrix mat R with","category":"page"},{"location":"man/obsmat/","page":"Observing Matrices","title":"Observing Matrices","text":"    mattilde m = mat R mathat m","category":"page"},{"location":"man/obsmat/","page":"Observing Matrices","title":"Observing Matrices","text":"This section describes the tools provided by CMB.jl for working with obsering matrices. These tools are specifically motivated by the use of observing matrices in generating reobserved pixel-pixel covariance matrices.","category":"page"},{"location":"man/obsmat/","page":"Observing Matrices","title":"Observing Matrices","text":"A detailed description of composing an observing matrix is given in BICEP/Keck Array VII (as well as the theses of J. Tolan and J. Willmert).","category":"page"},{"location":"man/obsmat/#Loading-an-Observing-Matrix","page":"Observing Matrices","title":"Loading an Observing Matrix","text":"","category":"section"},{"location":"man/obsmat/","page":"Observing Matrices","title":"Observing Matrices","text":"It is assumed that all observing matrices are sparse, and the native format used by this package is of compressed sparse column (CSC) matrices in accordance with Julia's SparseMatrixCSC type from the SparseArrays standard library. Observing matrices are read from disk with the read_obsmat function, and the following formats are supported:","category":"page"},{"location":"man/obsmat/","page":"Observing Matrices","title":"Observing Matrices","text":"An HDF5 file written by write_obsmat. (See the next section.)\nnumpy sparse matrices saved to an HDF5 file by h5sparse in either CSC or compressed sparse row (CSR) format.\nMATLAB save files. Requires explicitly loading MAT.jl first.\nJulia sparse matrices saved to an HDF5 file in the JLD format. Requires explicitly loading JLD.jl first.\nJulia sparse matrices saved to an HDF5 file in the JLD2 format. Requires explicitly loading JLD2.jl first.","category":"page"},{"location":"man/obsmat/","page":"Observing Matrices","title":"Observing Matrices","text":"For repeated computation, the first format should be preferred due to its support for memory mapping the matrix from disk.[1]","category":"page"},{"location":"man/obsmat/","page":"Observing Matrices","title":"Observing Matrices","text":"[1]: In particular, it is not possible to memory map the on-disk arrays saved by numpy and MATLAB because the internal data structures use 0-indexed pointers which are incompatible with Julia's use of 1-indexing.","category":"page"},{"location":"man/obsmat/","page":"Observing Matrices","title":"Observing Matrices","text":"The return is a tuple, first the observing matrix mat R and second a NamedTuple of metadata with the following fields:","category":"page"},{"location":"man/obsmat/","page":"Observing Matrices","title":"Observing Matrices","text":"fields — a description of the Stokes fields for which the observing matrix applies — e.g. the value \"QU\" signals that mat R is the block matrix matR_QQ matR_QU matR_UQ matR_UU.\npixels_right — a description of the \"right-hand side\" map pixelization, i.e. the pixelization of a map-vector mathat m for which the product mat R mathat m is defined.\npixels_left — a description of the \"left-hand side\" map pixelization, i.e. the pixelization of the resultant map-vector mattilde m = mat R mathat m.","category":"page"},{"location":"man/obsmat/","page":"Observing Matrices","title":"Observing Matrices","text":"The pixelization descriptions are in general data-format and situation specific. For the HDF5 backend, the pixelization description may be any \"native\" HDF5.jl data type (such as numbers, strings, or arrays thereof) or an HDF5 group which is loaded recursively into a Dict{String,Any} with leaf-nodes which are a native type.","category":"page"},{"location":"man/obsmat/#Exporting-an-Observing-Matrix","page":"Observing Matrices","title":"Exporting an Observing Matrix","text":"","category":"section"},{"location":"man/obsmat/","page":"Observing Matrices","title":"Observing Matrices","text":"To support memory mapping the sparse matrix from disk, the write_obsmat function is provided to ensure proper data alignment and choice of HDF5 options.","category":"page"},{"location":"man/obsmat/#obsmat_mmap","page":"Observing Matrices","title":"Using Memory Mapping","text":"","category":"section"},{"location":"man/obsmat/","page":"Observing Matrices","title":"Observing Matrices","text":"By default with the HDF5 backend, the component arrays of the sparse matrix are memory mapped. This choice is made for one primary reason — memory mapping the arrays allows multiple instances of Julia to share a single copy of the matrix in RAM, with the OS managing this behavior automatically. This is especially useful for computations being run on a cluster where the cluster manager may launch multiple jobs doing similar calculations on the same compute node.","category":"page"},{"location":"man/obsmat/","page":"Observing Matrices","title":"Observing Matrices","text":"The default memory mapping behavior can be changed by setting the values of CMB.Files.READ_OBSMAT_MMAP and CMB.Files.READ_OBSMAT_MMAP_FLAGS — the former can be set to false to disable memory mapping completely:","category":"page"},{"location":"man/obsmat/","page":"Observing Matrices","title":"Observing Matrices","text":"julia> CMB.Files.READ_OBSMAT_MMAP[] = false  # disables default memory mapping","category":"page"},{"location":"man/obsmat/","page":"Observing Matrices","title":"Observing Matrices","text":"while the latter dictates the flags which are used during the underlying mmap call. On Linux systems, the default is","category":"page"},{"location":"man/obsmat/","page":"Observing Matrices","title":"Observing Matrices","text":"julia> CMB.Files.READ_OBSMAT_MMAP_FLAGS[] = UnixMmap.MMAP_SHARED | UnixMmap.MMAP_POPULATE","category":"page"},{"location":"man/obsmat/","page":"Observing Matrices","title":"Observing Matrices","text":"so that the arrays are pre-faulted into active RAM. (On other OSs, the arrays can either be manually faulted with a read loop, or the loads can be left to happen on demand when the matrix is used.)","category":"page"}]
}

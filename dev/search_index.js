var documenterSearchIndex = {"docs":
[{"location":"man/healpix/#man_healpix-1","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"","category":"section"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"Pages = [\"healpix.md\"]\nDepth = 2","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"The Healpix module implements a selection of functions for interacting with the Hierarchical Equal-Area Iso-Latitude Pixelization (HEALPix) as described in Górski et al. (2005). The emphasis has been on working with pixel index and spherical coordinate conversions for the RING-ordered scheme only. If a complete HEALPix implementation is required, try LibHealpix.jl which provides Julia bindings to the official C++ library or try using the Python healpy interface via PyCall.jl. Additionally, the Healpix.jl package aims for a complete native Julia reimplementation. newcommandNsideN_mathrmside","category":"page"},{"location":"man/healpix/#Basic-pixelization-properties-1","page":"HEALPix Pixelization","title":"Basic pixelization properties","text":"","category":"section"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"A core defining attribute of the HEALPix map is the Nside parameter. The minimum valid value is Nside = 1, representing the coarsest pixelization of the sphere which can be represented by HEALPix. The Nside then increases by factors of two—denoting ever finer resolutions—with the number of pixels covering the sphere being a function of Nside alone. CMB.Healpix.nside2npix returns the number of pixels in a given map:","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> using CMB.Healpix\n\njulia> nside = 4;\n\njulia> nside2npix(nside)\n192","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"Because all pixels are of equal area and the number of pixels is derived from only the Nside, the pixel surface area must be as well. For convenience, CMB.Healpix.nside2pixarea is provided and is equivalent to the simple from-scratch calculation (in steradians).","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> 4π / nside2npix(nside)\n0.06544984694978735\n\njulia> nside2pixarea(nside)\n0.06544984694978735","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"The number of iso-latitude rings is also a function of only Nside and calculated by CMB.Healpix.nside2nring:","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> nside2nring(nside)\n15","category":"page"},{"location":"man/healpix/#Working-with-pixel-indices-1","page":"HEALPix Pixelization","title":"Working with pixel indices","text":"","category":"section"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"The pixels are enumerated as 0-indexed integers from west to east along the iso-latitude rings, from north to south. For example, pixel 0 is the first pixel in the first ring, and pixel 103 is the sixteenth pixel in the eighth ring for an Nside = 4 map:","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> pix = (0, 103);\n\njulia> pix2ring.(nside, pix)    # Ring\n(1, 8)\n\njulia> pix2ringidx.(nside, pix) # Index in ring\n(1, 16)","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"note: Note\nBe careful to note that pixels are 0-indexed, but the rings and indices within a ring are 1-indexed.","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"The HEALPix grid is symmetric about equator, with the equatorial ring considered part of the northern hemisphere by convention. Membership as part of the northern or southern hemisphere can be tested with the CMB.Healpix.isnorth and CMB.Healpix.issouth functions, respectively. Pixel 103 is actually the last pixel in the northern hemisphere, so","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> isnorth(nside, 103)\ntrue\n\njulia> isnorth(nside, 104)\nfalse\n\njulia> issouth(nside, 104)\ntrue","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"In fact, each hemisphere is further composed of a so-called polar cap and equatorial belt region of pixels (a property derived from the mathematical details of the HEALPix grid's definition). According to the ring-ordered definition, pixel 0 should be in the polar cap (tested via CMB.Healpix.iscap), while pixel 103 in the equatorial ring is expected to be part of the equitorial belt (tested via CMB.Healpix.isequbelt).","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> iscap.(nside, pix)\n(true, false)\n\njulia> isequbelt.(nside, pix)\n(false, true)","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"Membership in a particular hemisphere's polar cap or equatorial belt is accomplished with variants inserting north and south into the function names, i.e. polar caps are distinguished by CMB.Healpix.isnorthcap and CMB.Healpix.issouthcap, and the halves of the equatorial belt are distinguished by CMB.Healpix.isnorthequbelt and CMB.Healpix.issouthequbelt.","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> pix = (0, 103, 104, 191);\n\njulia> isnorthcap.(nside, pix)\n(true, false, false, false)\n\njulia> isnorthequbelt.(nside, pix)\n(false, true, false, false)\n\njulia> issouthequbelt.(nside, pix)\n(false, false, true, false)\n\njulia> issouthcap.(nside, pix)\n(false, false, false, true)","category":"page"},{"location":"man/healpix/#Working-with-spherical-coordinates-1","page":"HEALPix Pixelization","title":"Working with spherical coordinates","text":"","category":"section"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"Up to now, all the features shown have concerned working with properties of the pixelization scheme, but the utility of the HEALPix grid is its ability to describe the surface of a sphere. Using spherical coordinates is more useful and more natural for more algorithms than the HEALPix-specific indexing scheme.","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"The first method of describing the location of a particular HEALPix pixel is as a colatitude/azimuth pair of angles on the surface of the sphere identifying the pixel center. Colatitude measures the angle (in radians) south of the North Pole, and azimuth measures the angle (in radians) east of the Prime Meridian. To get the colatitude, use CMB.Healpix.pix2theta,","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> pix2theta(nside, 103)\n1.5707963267948966","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"and to get the azimuth, use CMB.Healpix.pix2phi","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> pix2phi(nside, 103)\n6.086835766330224","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"(both named to follow the mathematical convention that colatitude/azimuth pairs in spherical coordinates are the variable pair (θ ϕ)). When the coordinate pair is required, the method CMB.Healpix.pix2ang returns a 2-tuple with the coordinates:","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> pix2ang(nside, 103)\n(1.5707963267948966, 6.086835766330224)\n\njulia> pix2ang(nside, 103) .|> rad2deg\n(90.0, 348.75)","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"The other common way to represent coordinates on the sphere is via unit vectors. The corresponding vector for a given pixel is retrieved with CMB.Healpix.pix2vec.","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> pix2vec(nside, 103)\n3-element StaticArrays.SArray{Tuple{3},Float64,1,3} with indices SOneTo(3):\n  0.9807852804032303\n -0.19509032201612872\n  0.0","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"where the elements correspond to the typical (x y z) right-handed coordinates with the positive z-axis passing through the North Pole and the positive x-axis passing through the Prime Meridian.","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"In reverse, converting an arbitrary spherical coordinate to a pixel index is accomplished via the CMB.Healpix.ang2pix and CMB.Healpix.vec2pix methods, respectively:","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> ang2pix(nside, pix2ang(nside, 103)...)\n103\n\njulia> vec2pix(nside, pix2vec(nside, 103))\n103","category":"page"},{"location":"man/healpix/#Input-validation-and-error-handling-1","page":"HEALPix Pixelization","title":"Input validation and error handling","text":"","category":"section"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"As stated earlier, the HEALPix Nside parameter takes on values which are powers of two and by convention of the official HEALPix [1] source is limited to the range 1 to 2^29. Validity of any nside parameter can be checked with the CMB.Healpix.ishealpixok function.","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> ishealpixok(4)\ntrue\n\njulia> ishealpixok.((5, 2^30))\n(false, false)","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"Likewise, once given an Nside value, the pixel indices are bounded in 0 to nside2npix(nside) - 1; the two-argument form of ishealpixok returns whether a pixel is valid for the specified nside or not:","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> nside2npix(4)\n192\n\njulia> ishealpixok(4, 191)\ntrue\n\njulia> ishealpixok(4, 192)\nfalse","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"Variants which throw a CMB.Healpix.InvalidNside or CMB.Healpix.InvalidPixel error are provided by CMB.Healpix.checkhealpix:","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> checkhealpix(5)\nERROR: 5 is not a valid Nside parameter (must be power of 2)\n[...]\n\njulia> checkhealpix(4, 192)\nERROR: 192 is not a valid pixel index for Nside = 4 (must be from 0 to 191)\n[...]","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"note: Note\nOnly the functions working with spherical coordinates validate their inputs. The pixel indexing and classification functions are considered low-level routines and assume valid inputs. For example,julia> nside2npix(5)\n300\n\njulia> pix2ring(5, 0)\n1\n\njulia> pix2theta(5, 0)\nERROR: 5 is not a valid Nside parameter (must be power of 2)\n[...]\n\njulia> isnorth(4, -1)\ntrue\n\njulia> pix2ringidx(4, -1)\n0\n\njulia> pix2phi(4, -1)\nERROR: -1 is not a valid pixel index for Nside = 4 (must be from 0 to 191)\n[...]This choise was made for the sake of computational efficiency — the low-level pixel indexing/classification functions are used internally to compute the spherical coordinates.","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"","category":"page"},{"location":"man/healpix/#Footnotes:-1","page":"HEALPix Pixelization","title":"Footnotes:","text":"","category":"section"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"[1]: Official HEALPix package: http://healpix.sourceforge.net/","category":"page"},{"location":"man/sphere/#man_sphere-1","page":"Spherical Functions","title":"Spherical Functions","text":"","category":"section"},{"location":"man/sphere/#","page":"Spherical Functions","title":"Spherical Functions","text":"Pages = [\"sphere.md\"]\nDepth = 2","category":"page"},{"location":"man/sphere/#","page":"Spherical Functions","title":"Spherical Functions","text":"A key aspect of computing pixel-pixel covariance is calculating relative orientations of the two pixels on the sphere. The Sphere module implements a few basic spherical functions. For HEALPix-specific calculations, see the HEALPix Pixelization documentation instead.","category":"page"},{"location":"man/sphere/#sphere_defn-1","page":"Spherical Functions","title":"Definitions","text":"","category":"section"},{"location":"man/sphere/#","page":"Spherical Functions","title":"Spherical Functions","text":"A colatitude-azimuth pair (θ ϕ) are coordinates on the sphere measuring the angular distance (in radians) from the North pole and east of the Prime Meridian, respectively. The coordinates will typically be normalized to the range θ  0 π and ϕ  0 2π).\nA latitude-longitude pair (δ λ) are coordinates on the sphere measuring the angular distance (in degrees) north or south of the Equator and east or west of the Prime Meridian, respectively. The coordinates will typically be normalized to the range δ  -90 90 and λ  -180 180.\nA Cartesian unit vector vec r centered at the origin of a sphere has its end-point at a location on the unit sphere. The coordinate system is right-handed, with the North Pole located at hat z = 0 0 1 and the intersection of the Prime Meridian and Equator located at hat x = 1 0 0.","category":"page"},{"location":"man/sphere/#","page":"Spherical Functions","title":"Spherical Functions","text":"In general, the function throughout the CMB package will take either colatitude-azimuth or unit vector coordinates.","category":"page"},{"location":"man/sphere/#sphere_usage-1","page":"Spherical Functions","title":"Usage","text":"","category":"section"},{"location":"man/sphere/#","page":"Spherical Functions","title":"Spherical Functions","text":"Conversion between colatitude-azimuth pairs, latitude-longitude pairs, and unit vectors can be accomplished via the unexported functions Sphere.colataz, Sphere.latlon, and Sphere.cartvec.","category":"page"},{"location":"man/sphere/#","page":"Spherical Functions","title":"Spherical Functions","text":"julia> using CMB.Sphere\n\njulia> using CMB.Sphere: colataz, latlon, cartvec\n\njulia> δ, λ = 44.97531, -93.23471;  # Tate Lab @ Univ. of Minnesota\n\njulia> θ, ϕ = colataz(δ, λ)         # lat-lon to colat-az\n(0.7858290851897657, 4.655932640537504)\n\njulia> latlon(θ, ϕ)                 # colat-az to lat-lon\n(44.97531, -93.23471)\n\njulia> r = cartvec(θ, ϕ)            # colat-az to unit vector\n3-element StaticArrays.SArray{Tuple{3},Float64,1,3} with indices SOneTo(3):\n -0.03991664732478908\n -0.7062843499648845\n  0.7068020078218715\n\njulia> colataz(r)       # unit vector to colat-az\n(0.7858290851897657, 4.655932640537504)\n\njulia> latlon(r)        # unit vector to lat-lon\n(44.97531000000001, -93.23471000000002)","category":"page"},{"location":"man/sphere/#","page":"Spherical Functions","title":"Spherical Functions","text":"Given two points on the sphere — represented as either a unit vector or a colatitude-azimuth pair — we can query for the angular distance between the two points with the distance function:","category":"page"},{"location":"man/sphere/#","page":"Spherical Functions","title":"Spherical Functions","text":"julia> r₁ = cartvec(colataz(-0.18114, -78.46762)); # Quito, Ecuador\n\njulia> r₂ = cartvec(colataz(69.64906,  18.95454)); # Tromsø, Norway\n\njulia> σ = distance(r₁, r₂)\n1.6187031137492613","category":"page"},{"location":"man/sphere/#","page":"Spherical Functions","title":"Spherical Functions","text":"In situations where the cosine of the separation is required instead — such as for Legendre polynomial calculations — it is more efficient to directly return the cosine of the angle with the cosdistance function:","category":"page"},{"location":"man/sphere/#","page":"Spherical Functions","title":"Spherical Functions","text":"julia> cosdistance(r₁, r₂)\n-0.047888464230114274","category":"page"},{"location":"man/sphere/#","page":"Spherical Functions","title":"Spherical Functions","text":"The angular separation alone is insufficient for describing the relative orientation of the two points; the orientation angle of the great circle connecting the two must be given with respect to some reference. A common choice is the bearing angle[1]. It measures the angle between the meridian (at one of the points) and the great circle connecting the two, as shown by the angle α_ij in Figure 1.","category":"page"},{"location":"man/sphere/#","page":"Spherical Functions","title":"Spherical Functions","text":"<figure>","category":"page"},{"location":"man/sphere/#","page":"Spherical Functions","title":"Spherical Functions","text":"(Image: sphere angles)","category":"page"},{"location":"man/sphere/#","page":"Spherical Functions","title":"Spherical Functions","text":"<figcaption style=\"font-size:smaller; text-align:left; font-style: normal;\">","category":"page"},{"location":"man/sphere/#","page":"Spherical Functions","title":"Spherical Functions","text":"Figure 1: Example showing the angular separation σ_ij and bearing angle α_ij between a pair of coordinates r_i and r_j. The great arc indicates the great circle path passing between both coordinates, and the blue arc is the meridian which passes through r_i. Only the bearing angle at r_i is shown; a second bearing angle α_ji at r_j also exists (and is in general different that α_ij) but is not shown. The additional vectors hatn_i^* and hatn_ij are used to derive the distance and bearing angle calculations and can be ignored.","category":"page"},{"location":"man/sphere/#","page":"Spherical Functions","title":"Spherical Functions","text":"The figure is reproduced from Appendix E of J. Willmert.","category":"page"},{"location":"man/sphere/#","page":"Spherical Functions","title":"Spherical Functions","text":"</figcaption>\n</figure>","category":"page"},{"location":"man/sphere/#","page":"Spherical Functions","title":"Spherical Functions","text":"The bearing function calculates the bearing angle at the first point for the great circle connecting the pair of points. Continuing with examples using r₁ and r₂ as defined above,","category":"page"},{"location":"man/sphere/#","page":"Spherical Functions","title":"Spherical Functions","text":"julia> α₁ = bearing(r₁, r₂)\n0.35250686784416724","category":"page"},{"location":"man/sphere/#","page":"Spherical Functions","title":"Spherical Functions","text":"Be careful to remember that the order of coordinates is important! The bearing angle at r₁ (in Ecuador near the equator) toward r₂ (in northern Norway) is north-northeast as expected. Reversing the coordinates,","category":"page"},{"location":"man/sphere/#","page":"Spherical Functions","title":"Spherical Functions","text":"julia> α₂ = bearing(r₂, r₁)\n-1.4503517603957734","category":"page"},{"location":"man/sphere/#","page":"Spherical Functions","title":"Spherical Functions","text":"the bearing at r₂ is almost directly west instead.","category":"page"},{"location":"man/sphere/#","page":"Spherical Functions","title":"Spherical Functions","text":"Like with distance and cosdistance, the bearing angle itself is not always necessary, and the instead vector components (cosine and sine of the angle) are sufficient. In such a case, it is more efficient to forego the inverse trigonometric operations and instead use bearing2:","category":"page"},{"location":"man/sphere/#","page":"Spherical Functions","title":"Spherical Functions","text":"julia> δn, δe = bearing2(r₁, r₂)\n(0.9385101625713766, 0.34525161078588545)","category":"page"},{"location":"man/sphere/#","page":"Spherical Functions","title":"Spherical Functions","text":"For instance, calculating cos(2α) and sin(2α) can be calculated easily a couple of trigonometric identities and is faster.","category":"page"},{"location":"man/sphere/#","page":"Spherical Functions","title":"Spherical Functions","text":"The inverse operation is reckon which calculates the coordinate of a point which is a given distance and direction away from a reference point. Given the angular distance σ and bearing α₁ from before, we can reconstruct r₂:","category":"page"},{"location":"man/sphere/#","page":"Spherical Functions","title":"Spherical Functions","text":"julia> using LinearAlgebra: dot\n\njulia> reckon(r₁, σ, α₁)\n3-element StaticArrays.SArray{Tuple{3},Float64,1,3} with indices SOneTo(3):\n 0.3289121239720345\n 0.11296169792358199\n 0.937580113647056\n\njulia> dot(ans, r₂)     # == 1 if ans is parallel to r₂\n1.0","category":"page"},{"location":"man/sphere/#","page":"Spherical Functions","title":"Spherical Functions","text":"[1]: The bearing angle is also sometimes called the azimuth angle, but to   avoid confusion with use of azimuth in colatitude-azimuth coordinates we   will exclusively use the term bearing.","category":"page"},{"location":"man/pixelcov/#man_pixelcov-1","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"","category":"section"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"DocTestFilters = Regex[\n        r\"Ptr{0x[0-9a-f]+}\",\n        r\"[0-9\\.]+ seconds( \\(.*\\))?\",\n        ]","category":"page"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"Pages = [\"pixelcov.md\"]\nDepth = 2","category":"page"},{"location":"man/pixelcov/#pixelcov_defn-1","page":"Pixel-pixel Covariance","title":"Definition","text":"","category":"section"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"The following definitions are a lightly-modified reproduction of Appendix A of Tegmark & Oliveira-Costa (2001).","category":"page"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"<div style=\"display:none;\">","category":"page"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"newcommandmat1mathbf1\nnewcommandexpv1leftlangle 1rightrangle\nnewcommandcovF1F_ell^1(z_ij)\nnewcommandcovTTexpvT_i T_j\nnewcommandcovTQexpvT_i Q_j\nnewcommandcovTUexpvT_i U_j\nnewcommandcovQQexpvQ_i Q_j\nnewcommandcovQUexpvQ_i U_j\nnewcommandcovUUexpvU_i U_j\nnewcommandcijc_ij\nnewcommandsijs_ij\nnewcommandcjic_ji\nnewcommandsjis_ji","category":"page"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"</div>","category":"page"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"The pixel-pixel covariance is best constructed in stages. We start by defining the covariance langle X_i Y_jrangle between any two Stokes fields X and Y at pixels i and j for a local coordinate system where the Q axis is pointed along the great circle connection pixel i to pixel j. In this simplified case, the 6 unique covariances are","category":"page"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"beginalign\n    covTT equiv frac14pi sum_ell C_ell^TT covF00\n        labeleqntheorycovtt\n    \n    covTQ equiv -frac14pi sum_ell C_ell^TE covF10\n        labeleqntheorycovtq\n    \n    covTU equiv -frac14pi sum_ell C_ell^TB covF10\n        labeleqntheorycovtu\n    \n    covQQ equiv frac14pi sum_ell\n        left C_ell^EE covF12 - C_ell^BB covF22 right\n        labeleqntheorycovqq\n    \n    covUU equiv frac14pi sum_ell\n        left C_ell^BB covF12 - C_ell^EE covF22 right\n        labeleqntheorycovuu\n    \n    covQU equiv frac14pi sum_ell\n        C_ell^EB left covF12 + covF22 right\n        labeleqntheorycovqu\nendalign","category":"page"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"for z_ij = cos(sigma_ij) and some fiducial spectrum C_ell. The polarization weighting functions are simple functions of the P_ell and P_ell^2 associated Legendre polynomials,","category":"page"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"beginalign\n    covF00 equiv (2ell + 1) P_ell(z_ij)\n        labeleqntheorycovF00\n    \n    covF10 equiv chi_ell\n        left\n        fracz_ij1-z_ij^2 P_ell-1(z_ij) - left(\n        frac11-z_ij^2 + fracell-12 right)P_ell(z_ij)\n        right\n        labeleqntheorycovF10\n    \n    covF12 equiv gamma_ell\n        left\n        fracell+21-z_ij^2 z_ij P^2_ell-1(z_ij) - left(\n        fracell-41-z_ij^2 + fracell(ell-1)2 right)\n        P^2_ell(z_ij)\n        right\n        labeleqntheorycovF12\n    \n    covF22 equiv 2gamma_ell\n        left\n        fracell+21-z_ij^2 P^2_ell-1(z_ij) -\n        fracell-11-z_ij^2 z_ij P^2_ell(z_ij)\n        right\n        labeleqntheorycovF22\nendalign","category":"page"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"where[1]","category":"page"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"beginalign\n    chi_ell equiv frac2ell (2ell + 1)\n        sqrt(ell-1)ell(ell+1)(ell+2)\n    \n    gamma_ell equiv frac2(2ell + 1)\n        (ell-1)ell(ell+1)(ell+2)\nendalign","category":"page"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"For a single pixel-pixel pair, the covariance terms form a symmetric 3 times 3 matrix mat M","category":"page"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"beginalign\n    mat M(z_ij) = beginbmatrix\n        covTT  covTQ  covTU \n        covTQ  covQQ  covQU \n        covTU  covQU  covUU\n    endbmatrix\nendalign","category":"page"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"which is rotated from the local to a global Stokes coordinate system by application of the rotation matrix","category":"page"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"beginalign\n    mat R(alpha) = beginbmatrix\n        1  0  0 \n        0  cos(2alpha)  -sin(2alpha) \n        0  sin(2alpha)   cos(2alpha)\n    endbmatrix\nendalign","category":"page"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"where alpha are bearing angles, such that the pixel-pixel covariance mat C_ij in global coordinates is defined by","category":"page"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"beginalign\n    mat C_ij = mat R(alpha_ij) mat M(z_ij) mat R(alpha_ji)^top\n        labeleqntheorycovrotate\nendalign","category":"page"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"Pay attention to the fact that the left-hand mat R uses the bearing angle alpha_ij at pixel i whereas the right-hand mat R uses the bearing angle alpha_ji at pixel j. Also note that these rotations move the covariances into the IAU polarization convention — to move into the HEALPix polarization convention, the rotations both need to be reversed, i.e. mat R leftrightarrow mat R^top.","category":"page"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"The pixel-pixel covariance matrix mat C for some set of pixels is constructed by calculating the terms in mat C_ij for each pair of pixels and filling in the 9 values as the (ij)-th entries of the covariance blocks in mat C. By blocks, we refer to the fact that mat C can be block-decomposed as","category":"page"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"beginalign\n    mat C = beginbmatrix\n        mat C^TT  mat C^TQ  mat C^TU \n        mat C^QT  mat C^QQ  mat C^QU \n        mat C^UT  mat C^UQ  mat C^UU\n    endbmatrix\nendalign","category":"page"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"For example, if one holds j constant and varies i in P across all pixels, then one would form 3 columns of mat C, one in each of the block-columns.","category":"page"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"It is also convenient to define the polarization-only block decompositions of the total covariance matrix as","category":"page"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"beginalign\n    mat C^mathrmPol equiv beginbmatrix\n        mat C^QQ  mat C^QU \n        mat C^UQ  mat C^UU endbmatrix\nendalign","category":"page"},{"location":"man/pixelcov/#Properties-and-Symmetries-1","page":"Pixel-pixel Covariance","title":"Properties and Symmetries","text":"","category":"section"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"The entire covariance matrix mat C is symmetric. Therefore the on-diagonal sub-blocks mat C^TT, mat C^QQ, and mat C^UU are individually symmetric as well, and the off-diagonal blocks must be related to one another as\nbeginalign*\n    mat C^TQ = left(mat C^QTright)^top \n    mat C^TU = left(mat C^UTright)^top \n    mat C^QU = left(mat C^UQright)^top\nendalign*\nThis directly implies the polarization-only matrix mat C^mathrmPol is symmetric as well.\nThe covariance matrices mat C, mat C^TT, and mat C^mathrmPol are at least positive-semidefinite for appropriate non-zero fiducial input spectra. Positive-definiteness only occurs when there are at least as many non-zero harmonic modes (C_ell^XY neq 0 over all spectra XY) as there are diagonal elements in the matrix (the number of pixels in the map(s) that the covariance describes).\nThe covariance matrices are linear in the fiducial spectra. For example, an EE-only covariance matrix mat C^EE (wherein all C_ell = 0 except for C_ell^EE which is non-zero somewhere) and an EB-only covariance matrix mat C^EB can be summed to define\nbeginalign*\n    mat C^EEEB = mat C^EE + mat C^EB\nendalign*\nwhich is equivalent to the covariance matrix which would have been produced if the fiducial spectrum had included the both of the C_ell^EE and C_ell^EB spectra from the start.\nSince the IAU and HEALPix polarization conventions differ by the direction of rotation in mat R(alpha) which corresponds to a change in the sign of the sin terms (sij and sji), the cosmologically-interesting case where C_ell^EB = 0 and C_ell^TB = 0 also simplifies such that the following are also true:\nbeginalign*\n    mat C_ijmathrmHealpix^TU = -mat C_ijmathrmIAU^TU \n    mat C_ijmathrmHealpix^UT = -mat C_ijmathrmIAU^UT \n    mat C_ijmathrmHealpix^QU = -mat C_ijmathrmIAU^QU \n    mat C_ijmathrmHealpix^UQ = -mat C_ijmathrmIAU^UQ\nendalign*\nand the remaining block components are unchanged.","category":"page"},{"location":"man/pixelcov/#Mathematical-Details-1","page":"Pixel-pixel Covariance","title":"Mathematical Details","text":"","category":"section"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"It is often useful to have the fully-expanded expressions for each of the pixel-pixel covariance terms after applying the local-to-global coordinate system rotations. If we define short-cut notation for each of the terms in the rotation matrices as","category":"page"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"beginalign*\n    mat R(alpha_ij) equiv beginbmatrix\n        1  0  0 \n        0  cij  -sij \n        0  sij   cij\n    endbmatrix\n    \n    mat R(alpha_ji)^top equiv beginbmatrix\n        1  0  0 \n        0   cji  sji \n        0  -sji  cji\n    endbmatrix\nendalign*","category":"page"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"then expanding Eqn. refeqntheorycovrotate explicitly (and grouping the terms by block-columns):","category":"page"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"beginalign*\n    beginbmatrix\n            mat C_ij^TT  mat C_ij^QT  mat C_ij^UT\n        endbmatrix = beginbmatrix\n            covTT \n            covTQcij - covTUsij \n            covTQsij + covTUcij\n        endbmatrix\n    \n    beginbmatrix\n            mat C_ij^TQ  mat C_ij^QQ  mat C_ij^UQ\n        endbmatrix = beginbmatrix\n            covTQcji - covTUsji \n            covQQcijcji - covQU(cijsji + sijcji) + covUUsijsji \n            covQQsijcji + covQU(cijcji - sijsji) - covUUcijsji\n        endbmatrix\n    \n    beginbmatrix\n            mat C_ij^TU  mat C_ij^QU  mat C_ij^UU\n        endbmatrix = beginbmatrix\n            covTQsji + covTUcji \n            covQQcijsji + covQU(cijcji - sijsji) - covUUsijcji \n            covQQsijsji + covQU(cijsji + sijcji) + covUUcijcji\n        endbmatrix\nendalign*","category":"page"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"","category":"page"},{"location":"man/pixelcov/#Footnotes-1","page":"Pixel-pixel Covariance","title":"Footnotes","text":"","category":"section"},{"location":"man/pixelcov/#","page":"Pixel-pixel Covariance","title":"Pixel-pixel Covariance","text":"[1]: In the limit as z rightarrow 1 (i.e. as the two points given by pointing vectors are [anti-]parallel), the left(1 - z^2right)^-1 terms diverge. The resolution is to special-case the numerical computation and make use of the mathematical limits,beginalign\n    covF10 = rlap0\n        hphantomleft (-1)^ell frac2ell+12 right\n        textas  z_ij to 1\n    \n    covF12 = begincases\n            frac2ell+12             textas  z_ij to +1 \n            frac2ell+12  (-1)^ell  textas  z_ij to -1\n        endcases\n    \n    covF22 = begincases\n            -frac2ell+12            textas  z_ij to +1 \n             frac2ell+12 (-1)^ell  textas  z_ij to -1\n        endcases\nendalignFurthermore, the bearing angle is not well defined for [anti-]parallel points. Thankfully, langle Q_i Q_jrangle = langle U_i U_j rangle and langle Q_i U_j rangle = 0, so the polarization weights are invariant under rotation; therefore we can take alpha = 0 without loss of generality. (See Tegmark & Oliveira-Costa (2001).)","category":"page"},{"location":"lib/private/#Private-Documentation-1","page":"Private","title":"Private Documentation","text":"","category":"section"},{"location":"lib/private/#Contents-1","page":"Private","title":"Contents","text":"","category":"section"},{"location":"lib/private/#","page":"Private","title":"Private","text":"Pages = [\"private.md\"]","category":"page"},{"location":"lib/private/#Generic-utilities-1","page":"Private","title":"Generic utilities","text":"","category":"section"},{"location":"lib/private/#","page":"Private","title":"Private","text":"Modules = [CMB]\nPublic = false","category":"page"},{"location":"lib/private/#CMB.quadprod","page":"Private","title":"CMB.quadprod","text":"quadprod(A, b, n, dir=:col)\n\nComputes the quadratic product ABA^top efficiently for the case where B is all zero except for the nth column or row vector b, for dir = :col or dir = :row, respectively.\n\n\n\n\n\n","category":"function"},{"location":"lib/private/#Sphere-Functions-1","page":"Private","title":"Sphere Functions","text":"","category":"section"},{"location":"lib/private/#","page":"Private","title":"Private","text":"Modules = [CMB.Sphere]\nPublic = false","category":"page"},{"location":"lib/private/#CMB.Sphere.x̂","page":"Private","title":"CMB.Sphere.x̂","text":"const x̂ = SVector(1, 0, 0)\nconst ŷ = SVector(0, 1, 0)\nconst ẑ = SVector(0, 0, 1)\n\nConstant unit vectors in the Cartesian directions.\n\n\n\n\n\n","category":"constant"},{"location":"lib/private/#CMB.Sphere.ŷ","page":"Private","title":"CMB.Sphere.ŷ","text":"const x̂ = SVector(1, 0, 0)\nconst ŷ = SVector(0, 1, 0)\nconst ẑ = SVector(0, 0, 1)\n\nConstant unit vectors in the Cartesian directions.\n\n\n\n\n\n","category":"constant"},{"location":"lib/private/#CMB.Sphere.ẑ","page":"Private","title":"CMB.Sphere.ẑ","text":"const x̂ = SVector(1, 0, 0)\nconst ŷ = SVector(0, 1, 0)\nconst ẑ = SVector(0, 0, 1)\n\nConstant unit vectors in the Cartesian directions.\n\n\n\n\n\n","category":"constant"},{"location":"lib/private/#CMB.Sphere.:∥-Tuple{Any,Any}","page":"Private","title":"CMB.Sphere.:∥","text":"∥(u, v) -> Bool\n\nTest whether vector u is parallel to vector v. Assumes that both are unit normalized.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#CMB.Sphere.cartvec-Tuple{Any,Any}","page":"Private","title":"CMB.Sphere.cartvec","text":"r = cartvec(θ, ϕ)\nr = cartvec((θ, ϕ))\n\nConverts the colatitude-azimuth pair (θ, ϕ) to a Cartesian unit vector r.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#CMB.Sphere.colataz-Tuple{Any,Any}","page":"Private","title":"CMB.Sphere.colataz","text":"θ, ϕ = colataz(δ, λ)\nθ, ϕ = colataz((δ, λ))\n\nConverts the latitude-longitude pair (δ, λ) in degrees to colatitude-azimuth (θ, ϕ) in radians.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#CMB.Sphere.colataz-Tuple{StaticArrays.SArray{Tuple{3},T,1,3} where T}","page":"Private","title":"CMB.Sphere.colataz","text":"θ, ϕ = colataz(r)\n\nConverts the Cartesian unit vector r to a colatitude-azimuth pair (θ, ϕ) in radians.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#CMB.Sphere.latlon-Tuple{Any,Any}","page":"Private","title":"CMB.Sphere.latlon","text":"δ, λ = latlon(θ, ϕ)\nδ, λ = latlon((θ, ϕ))\n\nConverts the colatitude-azimuth pair (θ, ϕ) in radians to latitude-longitude (δ, λ) in radians.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#CMB.Sphere.latlon-Tuple{StaticArrays.SArray{Tuple{3},T,1,3} where T}","page":"Private","title":"CMB.Sphere.latlon","text":"δ, λ = latlon(r)\n\nConverts the Cartesian unit vector r to a latitude-longitude pair (δ, λ) in degrees.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#Healpix-1","page":"Private","title":"Healpix","text":"","category":"section"},{"location":"lib/private/#","page":"Private","title":"Private","text":"Modules = [CMB.Healpix]\nPublic = false","category":"page"},{"location":"lib/private/#CMB.Healpix.MAX_NSIDE","page":"Private","title":"CMB.Healpix.MAX_NSIDE","text":"const MAX_NSIDE = 2^29\n\nMaximum valid N_mathrmside parameter value.\n\n\n\n\n\n","category":"constant"},{"location":"lib/private/#CMB.Healpix.unsafe_ang2pix-Tuple{Any,Any,Any}","page":"Private","title":"CMB.Healpix.unsafe_ang2pix","text":"p = unsafe_ang2pix(nside, θ, ϕ)\n\nLike ang2pix but neither calls checkhealpix to check the validity of nside nor checks the domain of the spherical coordinates θ and ϕ.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#CMB.Healpix.unsafe_pix2ang-Tuple{Any,Any}","page":"Private","title":"CMB.Healpix.unsafe_pix2ang","text":"(θ,ϕ) = unsafe_pix2ang(nside, p)\n\nLike pix2ang but does not call checkhealpix to check nside and pixel index validity.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#CMB.Healpix.unsafe_pix2phi-Union{Tuple{I}, Tuple{I,I}} where I<:Integer","page":"Private","title":"CMB.Healpix.unsafe_pix2phi","text":"(θ,ϕ) = unsafe_pix2phi(nside, p)\n\nLike pix2phi but does not call checkhealpix to check nside and pixel index validity.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#CMB.Healpix.unsafe_pix2theta-Tuple{Any,Any}","page":"Private","title":"CMB.Healpix.unsafe_pix2theta","text":"(θ,ϕ) = unsafe_pix2theta(nside, p)\n\nLike pix2theta but does not call checkhealpix to check nside and pixel index validity.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#CMB.Healpix.unsafe_pix2vec-Union{Tuple{I}, Tuple{I,I}} where I<:Integer","page":"Private","title":"CMB.Healpix.unsafe_pix2vec","text":"(θ,ϕ) = unsafe_pix2vec(nside, p)\n\nLike pix2vec but does not call checkhealpix to check nside and pixel index validity.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#CMB.Healpix.unsafe_pix2z-Union{Tuple{I}, Tuple{I,I}} where I<:Integer","page":"Private","title":"CMB.Healpix.unsafe_pix2z","text":"(θ,ϕ) = unsafe_pix2z(nside, p)\n\nLike pix2z but does not call checkhealpix to check nside and pixel index validity.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#CMB.Healpix.unsafe_vec2pix-Tuple{Any,Any}","page":"Private","title":"CMB.Healpix.unsafe_vec2pix","text":"p = unsafe_vec2pix(nside, r)\n\nLike vec2pix but does not check the validity of the nside or length of r.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#CMB.Healpix.unsafe_zphi2pix-Tuple{Any,Any,Any}","page":"Private","title":"CMB.Healpix.unsafe_zphi2pix","text":"p = unsafe_zphi2pix(nside, z, ϕ)\n\nLike unsafe_ang2pix but uses the value z = cos(θ) instead.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#Spherical-Harmonics-1","page":"Private","title":"Spherical Harmonics","text":"","category":"section"},{"location":"lib/private/#","page":"Private","title":"Private","text":"Modules = [CMB.SphericalHarmonics]\nPublic = false","category":"page"},{"location":"lib/private/#Pixel-Covariance-1","page":"Private","title":"Pixel Covariance","text":"","category":"section"},{"location":"lib/private/#","page":"Private","title":"Private","text":"Modules = [CMB.PixelCovariance]\nPublic = false","category":"page"},{"location":"man/references/#References-1","page":"References","title":"References","text":"","category":"section"},{"location":"man/references/#bib-bicepkeck-1","page":"References","title":"BICEP/Keck","text":"","category":"section"},{"location":"man/references/#","page":"References","title":"References","text":"J. Tolan. “Testing Inflationary Cosmology with BICEP2 and the Keck Array”. PhD Thesis. Stanford University, Aug. 2014. URL: http://purl.stanford.edu/sr837cd9569\nThe BICEP/Keck Array Collaboration. “BICEP/Keck Array VII: Matrix Based E/B Separation Applied to BICEP2 and the Keck Array” In: The Astrophysical Journal 825, 66 (Jul 2016) DOI: 10.3847/0004-637X/825/1/66 arXiv: 1603.05976\nJ. Willmert. “Constraining Inflationary B-modes with the BICEP/Keck Array Telescopes”. PhD Thesis. University of Minnesota, Nov 2019. URL: http://hdl.handle.net/11299/211821","category":"page"},{"location":"man/references/#bib-coordinates-1","page":"References","title":"Coordinate systems and conventions","text":"","category":"section"},{"location":"man/references/#","page":"References","title":"References","text":"J. P. Hamaker and J. D. Bregman. “Understanding radio polarimetry. III. Interpreting the IAU/IEEE definitions of the Stokes parameters.” In: Astronomy and Astrophysics, Supplement Series 117 (May 1996) pp. 161–165. DOI: 10.1051/aas:1996147","category":"page"},{"location":"man/references/#bib-healpix-1","page":"References","title":"HEALPix","text":"","category":"section"},{"location":"man/references/#","page":"References","title":"References","text":"K. M. Górski et al. “HEALPix: A Framework for High-Resolution Discretization and Fast Analysis of Data Distributed on the Sphere” In: The Astrophysical Journal 662, 2 (Apr 2005) p. 759–771 DOI: 10.1086/427976. arXiv: astro-ph/0409513\nErratum: The equatorial-belt longitude phi equation (Eq 9) should have the +1 outside the modulus:\n  s = (i - N_mathrmside) operatornamemod 2 + 1\nErratum: Equation 22 differs in signs from equations A2–A3, and neither could be made to work. Instead, the implementation here is derived from the system of equations:\n  beginalign*\n    z_p(ϕ k_p) = frac23 - frac2k_p3N_mathrmside\n        + frac8ϕ3π\n    \n    z_m(ϕ k_m) = -frac23 + frac2k_m3N_mathrmside\n        - frac8ϕ3π\n  endalign*","category":"page"},{"location":"man/references/#bib-pixelcovariance-1","page":"References","title":"Pixel Covariance","text":"","category":"section"},{"location":"man/references/#","page":"References","title":"References","text":"M. Tegmark and A. de Oliveira-Costa. “How to measure CMB polarization power spectra without losing information” In: Physical Review D 64, 063001 (Sep 2001) DOI: 10.1103/PhysRevD.64.063001 arXiv: astro-ph/0012120","category":"page"},{"location":"lib/public/#Public-Documentation-1","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"lib/public/#Contents-1","page":"Public","title":"Contents","text":"","category":"section"},{"location":"lib/public/#","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"lib/public/#Sphere-Functions-1","page":"Public","title":"Sphere Functions","text":"","category":"section"},{"location":"lib/public/#","page":"Public","title":"Public","text":"Modules = [CMB.Sphere]\nPrivate = false","category":"page"},{"location":"lib/public/#CMB.Sphere","page":"Public","title":"CMB.Sphere","text":"Collection of routines for working with coordinates on the sphere.\n\n\n\n\n\n","category":"module"},{"location":"lib/public/#CMB.Sphere.bearing","page":"Public","title":"CMB.Sphere.bearing","text":"Calculates the bearing angle (α), defined as the angle between the meridian (at the first coordinate) and the great circle connecting the first coordinate to the second. Angles are measured eastward of north and will be in the range -ππ. See also bearing2.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Sphere.bearing-NTuple{4,Any}","page":"Public","title":"CMB.Sphere.bearing","text":"α = bearing(θ₁, ϕ₁, θ₂, ϕ₂)\n\nPoints on the sphere are given as coordinate pairs (θ₁ϕ₁) and (θ₂ϕ₂) where θ is the colatitude angle from the North Pole and ϕ is the azimuthal angle, both in radians.\n\nExamples\n\njulia> bearing(π/2, 0.0, π/4, π/4)\n0.6154797086703873\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Sphere.bearing-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"Public","title":"CMB.Sphere.bearing","text":"α = bearing(r₁, r₂)\n\nPoints on the sphere are given as unit vectors r₁ and r₂.\n\nExamples\n\njulia> bearing([1.0, 0.0, 0.0], [0.5, 0.5, sqrt(2)/2])\n0.6154797086703873\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Sphere.bearing2","page":"Public","title":"CMB.Sphere.bearing2","text":"Calculates the north/east vector components of the bearing angle (i.e. δn = cos(α) δe = sin(α)), defined as the angle between the meridian (at the first coordinate) and the great circle connecting the first coordinate to the second. See also bearing.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Sphere.bearing2-NTuple{4,Any}","page":"Public","title":"CMB.Sphere.bearing2","text":"(δn, δe) = bearing2(θ₁, ϕ₁, θ₂, ϕ₂)\n\nPoints on the sphere are given as coordinate pairs (θ₁ϕ₁) and (θ₂ϕ₂) where θ is the colatitude angle from the North Pole and ϕ is the azimuthal angle, both in radians.\n\nExamples\n\njulia> bearing2(π/2, 0.0, π/4, π/4)\n(0.8164965809277261, 0.5773502691896257)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Sphere.bearing2-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"Public","title":"CMB.Sphere.bearing2","text":"(δn, δe) = bearing2(r₁, r₂)\n\nPoints on the sphere are given as unit vectors r₁ and r₂.\n\nExamples\n\njulia> bearing2([1.0, 0.0, 0.0], [0.5, 0.5, sqrt(2)/2])\n(0.816496580927726, 0.5773502691896257)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Sphere.cosdistance","page":"Public","title":"CMB.Sphere.cosdistance","text":"Calculates the cosine of the inner angle (z) between unit vectors pointing from the center of the sphere to two points on its surface.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Sphere.cosdistance-NTuple{4,Any}","page":"Public","title":"CMB.Sphere.cosdistance","text":"z = cosdistance(θ₁, ϕ₁, θ₂, ϕ₂)\n\nPoints on the sphere are given as coordinate pairs (θ₁ϕ₁) and (θ₂ϕ₂) where θ is the colatitude angle from the North Pole and ϕ is the azimuthal angle, both in radians.\n\nExamples\n\njulia> cosdistance(π/2, 0.0, π/4, π/4)\n0.5\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Sphere.cosdistance-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"Public","title":"CMB.Sphere.cosdistance","text":"z = cosdistance(r₁, r₂)\n\nPoints on the sphere are given as unit vectors r₁ and r₂.\n\nExamples\n\njulia> cosdistance([1.,0.,0.], [0.5,0.5,sqrt(2)/2])\n0.5\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Sphere.distance","page":"Public","title":"CMB.Sphere.distance","text":"Calculates the inner angle (σ) between unit vectors pointing from the center of the sphere to two points on its surface.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Sphere.distance-NTuple{4,Any}","page":"Public","title":"CMB.Sphere.distance","text":"σ = distance(θ₁, ϕ₁, θ₂, ϕ₂)\n\nPoints on the sphere are given as coordinate pairs (θ₁ϕ₁) and (θ₂ϕ₂) where θ is the colatitude angle from the North Pole and ϕ is the azimuthal angle, both in radians.\n\nExamples\n\njulia> distance(π/2, 0.0, π/4, π/4)\n1.0471975511965979\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Sphere.distance-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"Public","title":"CMB.Sphere.distance","text":"σ = distance(r₁, r₂)\n\nPoints on the sphere are given as unit vectors r₁ and r₂.\n\nExamples\n\njulia> distance([1.,0.,0.], [0.5,0.5,sqrt(2)/2])\n1.0471975511965979\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Sphere.reckon","page":"Public","title":"CMB.Sphere.reckon","text":"Calculates a position on the sphere a given distance (σ, in radians) and relative bearing angle (α, in radians) away from a given point (measuring the eastward-of-north orientation of the great circle connecting the source and destination points with respect to the merdian passing through the source).\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Sphere.reckon-NTuple{4,Any}","page":"Public","title":"CMB.Sphere.reckon","text":"(θ′, ϕ′) = reckon(θ, ϕ, σ, α)\n\nThe point on the sphere is given by the colatitude-azimuth pair (θ, ϕ), both given in radians.\n\nnote: Note\nWhen r points to either the north or south pole, the meridian is defined to be θ meridian, and the bearing angle α is oriented with respect to it.For example, moving a distance π2 with no bearing goes to the equator, with the longitude dependent on the input longitude:julia> reckon(0.0, 0.0, π/2, 0.0)\n(1.5707963267948966, 3.141592653589793)\n\njulia> reckon(0.0, π/2, π/2, 0.0)\n(1.5707963267948966, 4.71238898038469)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Sphere.reckon-Tuple{AbstractArray{T,1} where T,Any,Any}","page":"Public","title":"CMB.Sphere.reckon","text":"r′ = reckon(r::AbstractVector, σ, α)\n\nThe point on the sphere is given as a unit vector r.\n\nnote: Note\nWhen r points to either the north or south pole, the meridian is defined to be prime meridian and the bearing angle α is oriented with respect to it.For example, moving a distance π2 with no bearing goes to the negative x axis (i.e. 0° N, 180° W):julia> reckon([0.0, 0.0, 1.0], π/2, 0.0)\n3-element StaticArrays.SArray{Tuple{3},Float64,1,3} with indices SOneTo(3):\n -1.0\n  0.0\n  6.123233995736766e-17\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Healpix-1","page":"Public","title":"Healpix","text":"","category":"section"},{"location":"lib/public/#","page":"Public","title":"Public","text":"Modules = [CMB.Healpix]\nPrivate = false","category":"page"},{"location":"lib/public/#CMB.Healpix","page":"Public","title":"CMB.Healpix","text":"A module of functions implementing function which interact with the HEALPix pixel definitions. In most cases, only the RING ordering functions are being provided.\n\nSee \"HEALPix: A Framework for High-Resolution Discretization and Fast Analysis of Data Distributed on the Sphere\" Górski, Hivon, & Banday et al (2005) ApJ 622:759–771 arXiv: astro-ph/0409513\n\n\n\n\n\n","category":"module"},{"location":"lib/public/#CMB.Healpix.UNSEEN","page":"Public","title":"CMB.Healpix.UNSEEN","text":"const UNSEEN = -1.6375e+30\n\nSpecial value recognized by the libhealpix/healpy routines as an unobserved/masked pixel.\n\n\n\n\n\n","category":"constant"},{"location":"lib/public/#CMB.Healpix.InvalidNside","page":"Public","title":"CMB.Healpix.InvalidNside","text":"InvalidNside(nside)\n\nAn invalid nside value was provided.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CMB.Healpix.InvalidPixel","page":"Public","title":"CMB.Healpix.InvalidPixel","text":"InvalidPixel(nside, pix)\n\nAn invalid pixel index pix was provided for the given nside.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CMB.Healpix.ang2pix-Tuple{Any,Any,Any}","page":"Public","title":"CMB.Healpix.ang2pix","text":"p = ang2pix(nside, θ, ϕ)\n\nComputes the HEALPix pixel index p which contains the point (θϕ) given by the colatitude θ and azimuth ϕ, where nside is the Nside resolution factor.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Healpix.checkhealpix-Tuple{Any,Any}","page":"Public","title":"CMB.Healpix.checkhealpix","text":"checkhealpix(nside, pix)\n\nThrows an InvalidNside exception if nside is not a valid value or an InvalidPixel exception if pix is out of range for the given N_mathrmside.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Healpix.checkhealpix-Tuple{Any}","page":"Public","title":"CMB.Healpix.checkhealpix","text":"checkhealpix(nside)\n\nThrows an InvalidNside exception if nside is not a valid value.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Healpix.iscap","page":"Public","title":"CMB.Healpix.iscap","text":"iscap(nside, pix)\n\nTest for whether the given pixel pix is in either polar cap for an nside HEALPix map.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Healpix.isequbelt","page":"Public","title":"CMB.Healpix.isequbelt","text":"isequbelt(nside, pix)\n\nTest for whether the given pixel pix is in the equatorial belt for an nside HEALPix map.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Healpix.ishealpixok-Tuple{Any,Any}","page":"Public","title":"CMB.Healpix.ishealpixok","text":"isheapixok(nside, pix)\n\nReturns true if nside is valid and pix is in the range 0 to nside2npix(nside) - 1, otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Healpix.ishealpixok-Tuple{Any}","page":"Public","title":"CMB.Healpix.ishealpixok","text":"ishealpixok(nside)\n\nReturns true if nside is a power of two in the range 1 to 2^29, otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Healpix.isnorth","page":"Public","title":"CMB.Healpix.isnorth","text":"isnorth(nside, pix)\n\nTest for whether the given pixel pix is in the northern hemisphere (including the equatorial ring) for an nside HEALPix map.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Healpix.isnorthcap","page":"Public","title":"CMB.Healpix.isnorthcap","text":"isnorthcap(nside, pix)\n\nTest for whether the given pixel pix is in the northern polar cap for an nside HEALPix map.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Healpix.isnorthequbelt","page":"Public","title":"CMB.Healpix.isnorthequbelt","text":"isnorthequbelt(nside, pix)\n\nTest for whether the given pixel pix is in the northern equatorial belt (including the equatorial ring) for an nside HEALPix map.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Healpix.issouth","page":"Public","title":"CMB.Healpix.issouth","text":"issouth(nside, pix)\n\nTest for whether the given pixel pix is in the southern hemisphere (excluding the equatorial ring) for an nside HEALPix map.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Healpix.issouthcap","page":"Public","title":"CMB.Healpix.issouthcap","text":"issouthcap(nside, pix)\n\nTest for whether the given pixel pix is in the southern polar cap for an nside HEALPix map.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Healpix.issouthequbelt","page":"Public","title":"CMB.Healpix.issouthequbelt","text":"issouthequbelt(nside, pix)\n\nTest for whether the given pixel pix is in the southern equatorial belt (excluding the equatorial ring) for an nside HEALPix map.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Healpix.npix2nside-Tuple{Any}","page":"Public","title":"CMB.Healpix.npix2nside","text":"Nisde = npix2nside(npix)\n\nReturns the equivalent Nside corresponding to the number of pixels npix.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Healpix.nring2nside-Tuple{Any}","page":"Public","title":"CMB.Healpix.nring2nside","text":"Nside = nring2nside(nring)\n\nReturns the equivalent Nside corresponding to the number of iso-latitude rings nring.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Healpix.nside2npix","page":"Public","title":"CMB.Healpix.nside2npix","text":"Npix = nside2npix(nside)\n\nReturns the total number of pixels Npix in an nside HEALPix map. Note that HEALPix pixel indexing is 0-based, so valid pixel values are in the range 0 to Npix - 1.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Healpix.nside2npixcap","page":"Public","title":"CMB.Healpix.nside2npixcap","text":"Npix = nside2npixcap(nside)\n\nReturns the number of pixels Npix in the polar caps for the given nside HEALPix map.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Healpix.nside2npixequ","page":"Public","title":"CMB.Healpix.nside2npixequ","text":"Npix = nside2npixequ(nside)\n\nReturns the number of pixels Npix in the northern hemisphere, including the equatorial ring, for the given nside HEALPix map.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Healpix.nside2nring","page":"Public","title":"CMB.Healpix.nside2nring","text":"Nring = nside2nring(nside)\n\nReturns the number of iso-latitude rings Nring in the nside HEALPix map.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Healpix.nside2pixarea","page":"Public","title":"CMB.Healpix.nside2pixarea","text":"σ = nside2pixarea(nside)\n\nReturns the surface area σ (in steradians) of each pixel in the given nside HEALPix map.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Healpix.pix2ang-Tuple{Any,Any}","page":"Public","title":"CMB.Healpix.pix2ang","text":"(θ,ϕ) = pix2ang(nside, p)\n\nComputes the colatitude and azimuth pair (θ,ϕ) for the given pixel p, where nside is the Nside resolution factor.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Healpix.pix2phi-Union{Tuple{I}, Tuple{I,I}} where I<:Integer","page":"Public","title":"CMB.Healpix.pix2phi","text":"ϕ = pix2phi(nside, p)\n\nComputes the azimuth ϕ for the given pixel p, where nside is the Nside resolution factor.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Healpix.pix2ring-Union{Tuple{I}, Tuple{I,I}} where I<:Integer","page":"Public","title":"CMB.Healpix.pix2ring","text":"i = pix2ring(nside, p)\n\nComputes the ring index i for the given pixel p, where nside is the Nside resolution factor.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Healpix.pix2ringidx-Union{Tuple{I}, Tuple{I,I}} where I<:Integer","page":"Public","title":"CMB.Healpix.pix2ringidx","text":"j = pix2ringidx(nside, p)\n\nComputes the index j within the ring for the given pixel p, where nside is the Nside resolution factor.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Healpix.pix2theta-Tuple{Any,Any}","page":"Public","title":"CMB.Healpix.pix2theta","text":"θ = pix2theta(nside, p)\n\nComputes the colatitude θ for the given pixel p, where nside is the Nside resolution factor.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Healpix.pix2vec-Union{Tuple{I}, Tuple{I,I}} where I<:Integer","page":"Public","title":"CMB.Healpix.pix2vec","text":"r = pix2vec(nside, p)\n\nComputes the unit vector r pointing to the pixel center of the given pixel p, where nside is the Nside resolution factor.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Healpix.pix2z-Union{Tuple{I}, Tuple{I,I}} where I<:Integer","page":"Public","title":"CMB.Healpix.pix2z","text":"z = pix2z(nside, p)\n\nComputes the cosine of the colatitude z for the given pixel p, where nside is the Nside resolution factor.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Healpix.vec2pix-Tuple{Any,Any}","page":"Public","title":"CMB.Healpix.vec2pix","text":"p = vec2pix(nside, r)\n\nComputes the HEALPix pixel index p which contains the point at the end of the unit vector r, where nside is the Nside resolution factor.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Pixel-Covariance-1","page":"Public","title":"Pixel Covariance","text":"","category":"section"},{"location":"lib/public/#","page":"Public","title":"Public","text":"Modules = [CMB.PixelCovariance]\nPrivate = false","category":"page"},{"location":"lib/public/#","page":"Public","title":"Public","text":"The following enums/bit flags are not exported globally, but all of the named values can be imported into a scope by using the parent module (e.g. to access all of the covariance field constants, use using CMB.PixelCovariance.CovarianceFields.","category":"page"},{"location":"lib/public/#","page":"Public","title":"Public","text":"CMB.PixelCovariance.PolarizationConventions.Convention\nCMB.PixelCovariance.CovarianceFields.Field\nCMB.PixelCovariance.CovarianceFields.TPol\nCMB.PixelCovariance.CovarianceFields.Pol","category":"page"},{"location":"lib/public/#CMB.PixelCovariance.PolarizationConventions.Convention","page":"Public","title":"CMB.PixelCovariance.PolarizationConventions.Convention","text":"@enum Convention IAUConv HealpixConv\n\nAn enumeration to specify the two types of polarization conventions used to describe Stokes Q/U coordinate systems.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CMB.PixelCovariance.CovarianceFields.Field","page":"Public","title":"CMB.PixelCovariance.CovarianceFields.Field","text":"@bitflag Field TT QT UT TQ QQ UQ TU QU UU NO_FIELD=0\n\nA bitfield for identifying subblocks of the pixel-pixel covariance matrix. There are 9 subblocks, named as the Cartesian product of elements T, Q, and U:\n\nTT  TQ  TU\nQT  QQ  QU\nUT  UQ  UU\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CMB.PixelCovariance.CovarianceFields.TPol","page":"Public","title":"CMB.PixelCovariance.CovarianceFields.TPol","text":"const TPol = QT | UT | TQ | TU\n\nAn alias for the temperature-cross-polarization sub-blocks of the full covariance matrix.\n\n\n\n\n\n","category":"constant"},{"location":"lib/public/#CMB.PixelCovariance.CovarianceFields.Pol","page":"Public","title":"CMB.PixelCovariance.CovarianceFields.Pol","text":"const Pol  = QQ | UQ | QU | UU\n\nAn alias for the polarization-only sub-blocks of the full covariance matrix.\n\n\n\n\n\n","category":"constant"},{"location":"#CMB.jl-Documentation-1","page":"CMB.jl Documentation","title":"CMB.jl Documentation","text":"","category":"section"},{"location":"#","page":"CMB.jl Documentation","title":"CMB.jl Documentation","text":"CMB.jl is a library of routines for the analysis of cosmic microwave background (CMB) data. Development of features is being driven by the author's use cases — at this time, namely the production of “reobserved” pixel-pixel covariance matrices as used by the BICEP/Keck Array collaboration.","category":"page"},{"location":"#","page":"CMB.jl Documentation","title":"CMB.jl Documentation","text":"Design goals of this package include:","category":"page"},{"location":"#","page":"CMB.jl Documentation","title":"CMB.jl Documentation","text":"Native Julia implementation of core routines.\nNumerical stability and efficiency.\nParallelism and efficient memory sharing.","category":"page"},{"location":"#User-Manual-and-Documentation-1","page":"CMB.jl Documentation","title":"User Manual and Documentation","text":"","category":"section"},{"location":"#","page":"CMB.jl Documentation","title":"CMB.jl Documentation","text":"Pages = [\n    \"man/healpix.md\",\n    \"man/sphere.md\",\n    \"man/pixelcov.md\",\n    \"man/references.md\"\n]\nDepth = 1","category":"page"},{"location":"#Library-API-Reference-1","page":"CMB.jl Documentation","title":"Library API Reference","text":"","category":"section"},{"location":"#","page":"CMB.jl Documentation","title":"CMB.jl Documentation","text":"Pages = [\n    \"lib/public.md\",\n    \"lib/private.md\"\n]\nDepth = 1","category":"page"}]
}

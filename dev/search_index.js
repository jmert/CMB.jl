var documenterSearchIndex = {"docs":
[{"location":"man/healpix/#HEALPix-Pixelization-1","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"","category":"section"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"Pages = [\"healpix.md\"]\nDepth = 2","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"The Healpix module implements a selection of functions for interacting with the Hierarchical Equal-Area Iso-Latitude Pixelization (HEALPix) as described in Górski et al. (2005). The emphasis has been on working with pixel index and spherical coordinate conversions for the RING-ordered scheme only. If a complete HEALPix implementation is required, try LibHealpix.jl which provides Julia bindings to the official C++ library or try using the Python healpy interface via PyCall.jl. Additionally, the Healpix.jl package aims for a complete native Julia reimplementation. newcommandNsideN_mathrmside","category":"page"},{"location":"man/healpix/#Basic-pixelization-properties-1","page":"HEALPix Pixelization","title":"Basic pixelization properties","text":"","category":"section"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"A core defining attribute of the HEALPix map is the Nside parameter. The minimum valid value is Nside = 1, representing the coarsest pixelization of the sphere which can be represented by HEALPix. The Nside then increases by factors of two—denoting ever finer resolutions—with the number of pixels covering the sphere being a function of Nside alone. CMB.Healpix.nside2npix returns the number of pixels in a given map:","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> using CMB.Healpix\n\njulia> nside = 4;\n\njulia> nside2npix(nside)\n192","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"Because all pixels are of equal area and the number of pixels is derived from only the Nside, the pixel surface area must be as well. For convenience, CMB.Healpix.nside2pixarea is provided and is equivalent to the simple from-scratch calculation (in steradians).","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> 4π / nside2npix(nside)\n0.06544984694978735\n\njulia> nside2pixarea(nside)\n0.06544984694978735","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"The number of iso-latitude rings is also a function of only Nside and calculated by CMB.Healpix.nside2nring:","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> nside2nring(nside)\n15","category":"page"},{"location":"man/healpix/#Working-with-pixel-indices-1","page":"HEALPix Pixelization","title":"Working with pixel indices","text":"","category":"section"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"The pixels are enumerated as 0-indexed integers from west to east along the iso-latitude rings, from north to south. For example, pixel 0 is the first pixel in the first ring, and pixel 103 is the sixteenth pixel in the eighth ring for an Nside = 4 map:","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> pix = (0, 103);\n\njulia> pix2ring.(nside, pix)    # Ring\n(1, 8)\n\njulia> pix2ringidx.(nside, pix) # Index in ring\n(1, 16)","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"note: Note\nBe careful to note that pixels are 0-indexed, but the rings and indices within a ring are 1-indexed.","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"The HEALPix grid is symmetric about equator, with the equatorial ring considered part of the northern hemisphere by convention. Membership as part of the northern or southern hemisphere can be tested with the CMB.Healpix.isnorth and CMB.Healpix.issouth functions, respectively. Pixel 103 is actually the last pixel in the northern hemisphere, so","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> isnorth(nside, 103)\ntrue\n\njulia> isnorth(nside, 104)\nfalse\n\njulia> issouth(nside, 104)\ntrue","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"In fact, each hemisphere is further composed of a so-called polar cap and equatorial belt region of pixels (a property derived from the mathematical details of the HEALPix grid's definition). According to the ring-ordered definition, pixel 0 should be in the polar cap (tested via CMB.Healpix.iscap), while pixel 103 in the equatorial ring is expected to be part of the equitorial belt (tested via CMB.Healpix.isequbelt).","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> iscap.(nside, pix)\n(true, false)\n\njulia> isequbelt.(nside, pix)\n(false, true)","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"Membership in a particular hemisphere's polar cap or equatorial belt is accomplished with variants inserting north and south into the function names, i.e. polar caps are distinguished by CMB.Healpix.isnorthcap and CMB.Healpix.issouthcap, and the halves of the equatorial belt are distinguished by CMB.Healpix.isnorthequbelt and CMB.Healpix.issouthequbelt.","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> pix = (0, 103, 104, 191);\n\njulia> isnorthcap.(nside, pix)\n(true, false, false, false)\n\njulia> isnorthequbelt.(nside, pix)\n(false, true, false, false)\n\njulia> issouthequbelt.(nside, pix)\n(false, false, true, false)\n\njulia> issouthcap.(nside, pix)\n(false, false, false, true)","category":"page"},{"location":"man/healpix/#Working-with-spherical-coordinates-1","page":"HEALPix Pixelization","title":"Working with spherical coordinates","text":"","category":"section"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"Up to now, all the features shown have concerned working with properties of the pixelization scheme, but the utility of the HEALPix grid is its ability to describe the surface of a sphere. Using spherical coordinates is more useful and more natural for more algorithms than the HEALPix-specific indexing scheme.","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"The first method of describing the location of a particular HEALPix pixel is as a colatitude/azimuth pair of angles on the surface of the sphere identifying the pixel center. Colatitude measures the angle (in radians) south of the North Pole, and azimuth measures the angle (in radians) east of the Prime Meridian. To get the colatitude, use CMB.Healpix.pix2theta,","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> pix2theta(nside, 103)\n1.5707963267948966","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"and to get the azimuth, use CMB.Healpix.pix2phi","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> pix2phi(nside, 103)\n6.086835766330224","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"(both named to follow the mathematical convention that colatitude/azimuth pairs in spherical coordinates are the variable pair (θ ϕ)). When the coordinate pair is required, the method CMB.Healpix.pix2ang returns a 2-tuple with the coordinates:","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> pix2ang(nside, 103)\n(1.5707963267948966, 6.086835766330224)\n\njulia> pix2ang(nside, 103) .|> rad2deg\n(90.0, 348.75)","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"The other common way to represent coordinates on the sphere is via unit vectors. The corresponding vector for a given pixel is retrieved with CMB.Healpix.pix2vec.","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> pix2vec(nside, 103)\n3-element StaticArrays.SArray{Tuple{3},Float64,1,3} with indices SOneTo(3):\n  0.9807852804032303\n -0.19509032201612872\n  0.0","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"where the elements correspond to the typical (x y z) right-handed coordinates with the positive z-axis passing through the North Pole and the positive x-axis passing through the Prime Meridian.","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"In reverse, converting an arbitrary spherical coordinate to a pixel index... ...TO BE IMPLEMENTED...","category":"page"},{"location":"man/healpix/#Input-validation-and-error-handling-1","page":"HEALPix Pixelization","title":"Input validation and error handling","text":"","category":"section"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"As stated earlier, the HEALPix Nside parameter takes on values which are powers of two and by convention of the official HEALPix [1] source is limited to the range 1 to 2^29. Validity of any nside parameter can be checked with the CMB.Healpix.ishealpixok function.","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> ishealpixok(4)\ntrue\n\njulia> ishealpixok.((5, 2^30))\n(false, false)","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"Likewise, once given an Nside value, the pixel indices are bounded in 0 to nside2npix(nside) - 1; the two-argument form of ishealpixok returns whether a pixel is valid for the specified nside or not:","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> nside2npix(4)\n192\n\njulia> ishealpixok(4, 191)\ntrue\n\njulia> ishealpixok(4, 192)\nfalse","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"Variants which throw a CMB.Healpix.InvalidNside or CMB.Healpix.InvalidPixel error are provided by CMB.Healpix.checkhealpix:","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"julia> checkhealpix(5)\nERROR: 5 is not a valid Nside parameter (must be power of 2)\n[...]\n\njulia> checkhealpix(4, 192)\nERROR: 192 is not a valid pixel index for Nside = 4 (must be from 0 to 191)\n[...]","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"note: Note\nOnly the functions working with spherical coordinates validate their inputs. The pixel indexing and classification functions are considered low-level routines and assume valid inputs. For example,julia> nside2npix(5)\n300\n\njulia> pix2ring(5, 0)\n1\n\njulia> pix2theta(5, 0)\nERROR: 5 is not a valid Nside parameter (must be power of 2)\n[...]\n\njulia> isnorth(4, -1)\ntrue\n\njulia> pix2ringidx(4, -1)\n0\n\njulia> pix2phi(4, -1)\nERROR: -1 is not a valid pixel index for Nside = 4 (must be from 0 to 191)\n[...]This choise was made for the sake of computational efficiency — the low-level pixel indexing/classification functions are used internally to compute the spherical coordinates.","category":"page"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"","category":"page"},{"location":"man/healpix/#Footnotes:-1","page":"HEALPix Pixelization","title":"Footnotes:","text":"","category":"section"},{"location":"man/healpix/#","page":"HEALPix Pixelization","title":"HEALPix Pixelization","text":"[1]: Official HEALPix package: http://healpix.sourceforge.net/","category":"page"},{"location":"lib/private/#Private-Documentation-1","page":"Private","title":"Private Documentation","text":"","category":"section"},{"location":"lib/private/#Contents-1","page":"Private","title":"Contents","text":"","category":"section"},{"location":"lib/private/#","page":"Private","title":"Private","text":"Pages = [\"private.md\"]","category":"page"},{"location":"lib/private/#Sphere-Functions-1","page":"Private","title":"Sphere Functions","text":"","category":"section"},{"location":"lib/private/#","page":"Private","title":"Private","text":"Modules = [CMB.Sphere]\nPublic = false","category":"page"},{"location":"lib/private/#CMB.Sphere.x̂","page":"Private","title":"CMB.Sphere.x̂","text":"const x̂ = SVector(1, 0, 0)\nconst ŷ = SVector(0, 1, 0)\nconst ẑ = SVector(0, 0, 1)\n\nConstant unit vectors in the Cartesian directions.\n\n\n\n\n\n","category":"constant"},{"location":"lib/private/#CMB.Sphere.ŷ","page":"Private","title":"CMB.Sphere.ŷ","text":"const x̂ = SVector(1, 0, 0)\nconst ŷ = SVector(0, 1, 0)\nconst ẑ = SVector(0, 0, 1)\n\nConstant unit vectors in the Cartesian directions.\n\n\n\n\n\n","category":"constant"},{"location":"lib/private/#CMB.Sphere.ẑ","page":"Private","title":"CMB.Sphere.ẑ","text":"const x̂ = SVector(1, 0, 0)\nconst ŷ = SVector(0, 1, 0)\nconst ẑ = SVector(0, 0, 1)\n\nConstant unit vectors in the Cartesian directions.\n\n\n\n\n\n","category":"constant"},{"location":"lib/private/#CMB.Sphere.:∥-Tuple{Any,Any}","page":"Private","title":"CMB.Sphere.:∥","text":"∥(u, v)\n\nTest whether vector u is parallel to vector v. Assumes that both are unit normalized.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#CMB.Sphere.cart-Tuple{Any,Any}","page":"Private","title":"CMB.Sphere.cart","text":"cart(θ, ϕ)\n\nConverts the colatitude-azimuth pair to a Cartesian unit vector.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#Legendre-Functions-1","page":"Private","title":"Legendre Functions","text":"","category":"section"},{"location":"lib/private/#","page":"Private","title":"Private","text":"Modules = [CMB.Legendre]\nPublic = false","category":"page"},{"location":"lib/private/#CMB.Legendre.Plm_00","page":"Private","title":"CMB.Legendre.Plm_00","text":"Plm_00(::N, ::Type{T}) where {N<:AbstractLegendreNorm, T}\n\nReturns the initial condition P_0^0(x) for the associated Legendre recursions based on the normalization choice N for numeric type T.\n\n\n\n\n\n","category":"function"},{"location":"lib/private/#CMB.Legendre.Plm_α","page":"Private","title":"CMB.Legendre.Plm_α","text":"Plm_α(norm::N, ::Type{T}, l::Integer, m::Integer) where {N<:AbstractLegendreNorm, T}\n\nReturns the coefficient α_ℓ^m for the two-term recursion relation\n\n    P_ℓ+1^m(x) = α_ℓ+1^m x P_ℓ^m(x) - β_ℓ+1^m P_ℓ-1^m(x)\n\nwhere α_ℓ^m is appropriate for the choice of normalization N.\n\n\n\n\n\n","category":"function"},{"location":"lib/private/#CMB.Legendre.Plm_β","page":"Private","title":"CMB.Legendre.Plm_β","text":"Plm_β(norm::N, ::Type{T}, l::Integer, m::Integer) where {N<:AbstractLegendreNorm, T}\n\nReturns the coefficient β_ℓ^m for the two-term recursion relation\n\n    P_ℓ+1^m(x) = α_ℓ+1^m x P_ℓ^m(x) - β_ℓ+1^m P_ℓ-1^m(x)\n\nwhere β_ℓ^m is appropriate for the choice of normalization N.\n\n\n\n\n\n","category":"function"},{"location":"lib/private/#CMB.Legendre.Plm_μ","page":"Private","title":"CMB.Legendre.Plm_μ","text":"Plm_μ(norm::N, ::Type{T}, l::Integer) where {N<:AbstractLegendreNorm, T}\n\nReturns the coefficient μ_ℓ for the single-term recursion relation\n\n    P_ℓ+1^ℓ+1(x) = -μ_ℓ+1 sqrt1-x^2 P_ℓ^ℓ(x)\n\nwhere μ_ℓ is appropriate for the choice of normalization N.\n\n\n\n\n\n","category":"function"},{"location":"lib/private/#CMB.Legendre.Plm_ν","page":"Private","title":"CMB.Legendre.Plm_ν","text":"Plm_ν(norm::N, ::Type{T}, l::Integer) where {N<:AbstractLegendreNorm, T}\n\nReturns the coefficient ν_ℓ for the single-term recursion relation\n\n    P_ℓ+1^ℓ(x) = ν_ℓ+1 x P_ℓ^ℓ(x)\n\nwhere ν_ℓ is appropriate for the choice of normalization N.\n\n\n\n\n\n","category":"function"},{"location":"lib/private/#Healpix-1","page":"Private","title":"Healpix","text":"","category":"section"},{"location":"lib/private/#","page":"Private","title":"Private","text":"Modules = [CMB.Healpix]\nPublic = false","category":"page"},{"location":"lib/private/#CMB.Healpix.MAX_NSIDE","page":"Private","title":"CMB.Healpix.MAX_NSIDE","text":"const MAX_NSIDE = 2^29\n\nMaximum valid N_mathrmside parameter value.\n\n\n\n\n\n","category":"constant"},{"location":"lib/private/#CMB.Healpix.unsafe_pix2ang-Tuple{Any,Any}","page":"Private","title":"CMB.Healpix.unsafe_pix2ang","text":"(θ,ϕ) = unsafe_pix2ang(nside, p)\n\nLike pix2ang but does not call checkhealpix to check nside and pixel index validity.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#CMB.Healpix.unsafe_pix2phi-Union{Tuple{I}, Tuple{I,I}} where I<:Integer","page":"Private","title":"CMB.Healpix.unsafe_pix2phi","text":"(θ,ϕ) = unsafe_pix2phi(nside, p)\n\nLike pix2phi but does not call checkhealpix to check nside and pixel index validity.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#CMB.Healpix.unsafe_pix2theta-Tuple{Any,Any}","page":"Private","title":"CMB.Healpix.unsafe_pix2theta","text":"(θ,ϕ) = unsafe_pix2theta(nside, p)\n\nLike pix2theta but does not call checkhealpix to check nside and pixel index validity.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#CMB.Healpix.unsafe_pix2vec-Union{Tuple{I}, Tuple{I,I}} where I<:Integer","page":"Private","title":"CMB.Healpix.unsafe_pix2vec","text":"(θ,ϕ) = unsafe_pix2vec(nside, p)\n\nLike pix2vec but does not call checkhealpix to check nside and pixel index validity.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#CMB.Healpix.unsafe_pix2z-Union{Tuple{I}, Tuple{I,I}} where I<:Integer","page":"Private","title":"CMB.Healpix.unsafe_pix2z","text":"(θ,ϕ) = unsafe_pix2z(nside, p)\n\nLike pix2z but does not call checkhealpix to check nside and pixel index validity.\n\n\n\n\n\n","category":"method"},{"location":"lib/private/#Pixel-Covariance-1","page":"Private","title":"Pixel Covariance","text":"","category":"section"},{"location":"lib/private/#","page":"Private","title":"Private","text":"Modules = [CMB.PixelCovariance]\nPublic = false","category":"page"},{"location":"lib/private/#CMB.PixelCovariance.FIELDMAP","page":"Private","title":"CMB.PixelCovariance.FIELDMAP","text":"const FIELDMAP\n\nA symbol array which states the canonical ordering of the block matrices within a pixel-pixel covariance matrix.\n\n\n\n\n\n","category":"constant"},{"location":"lib/private/#CMB.PixelCovariance.SPECTRAMAP","page":"Private","title":"CMB.PixelCovariance.SPECTRAMAP","text":"const SPECTRAMAP\n\nA symbol array which states the canonical ordering of spectra.\n\n\n\n\n\n","category":"constant"},{"location":"lib/private/#Miscellaneous-Utilities-1","page":"Private","title":"Miscellaneous Utilities","text":"","category":"section"},{"location":"lib/private/#","page":"Private","title":"Private","text":"Modules = [CMB.Util]\nPublic = false","category":"page"},{"location":"lib/private/#CMB.Util.@abserr-Tuple{Any}","page":"Private","title":"CMB.Util.@abserr","text":"@abserr fncall(args...)\n\nTakes the function call fncall(args...) and rewrites the expression to calculate the absolute deviation between the regular call and one with all arguments promoted to BigFloat or BigInt.\n\nExample\n\njulia> CMB.Util.@abserr sin(π-1e-5)\n4.1944097844272447e-22\n\nSee Also\n\n@relerr, @absrelerr\n\n\n\n\n\n","category":"macro"},{"location":"lib/private/#CMB.Util.@absrelerr-Tuple{Any}","page":"Private","title":"CMB.Util.@absrelerr","text":"@absrelerr fncall(args...)\n\nTakes the function call fncall(args...) and rewrites the expression to calculate the absolute and relative deviation between the regular call and one with all arguments promoted to BigFloat or BigInt, returning both as a tuple pair.\n\nExample\n\njulia> CMB.Util.@absrelerr sin(π-1e-5)\n(4.1944097844272447e-22, 0.24759425226749643)\n\nSee Also\n\n@abserr, @relerr\n\n\n\n\n\n","category":"macro"},{"location":"lib/private/#CMB.Util.@relerr-Tuple{Any}","page":"Private","title":"CMB.Util.@relerr","text":"@relerr fncall(args...)\n\nTakes the function call fncall(args...) and rewrites the expression to calculate the relative deviation (in ulps) between the regular call and one with all arguments promoted to BigFloat or BigInt.\n\nExample\n\njulia> CMB.Util.@relerr sin(π-1e-5)\n0.24759425226749643\n\nSee Also\n\n@abserr, @absrelerr\n\n\n\n\n\n","category":"macro"},{"location":"man/references/#References-1","page":"References","title":"References","text":"","category":"section"},{"location":"man/references/#bib-coordinates-1","page":"References","title":"Coordinate systems and conventions","text":"","category":"section"},{"location":"man/references/#","page":"References","title":"References","text":"J. P. Hamaker and J. D. Bregman. “Understanding radio polarimetry. III. Interpreting the IAU/IEEE definitions of the Stokes parameters.” In: Astronomy and Astrophysics, Supplement Series 117 (May 1996) pp. 161–165. DOI: 10.1051/aas:1996147","category":"page"},{"location":"man/references/#bib-legendre-1","page":"References","title":"Legendre functions","text":"","category":"section"},{"location":"man/references/#","page":"References","title":"References","text":"T. Limpanuparb and J. Milthorpe. “Associated Legendre Polynomials and Spherical Harmonics Computation for Chemistry Applications” In: Proceedings of the 40th Congress on Science and Technology of Thailand (Dec 2014) arXiv: 1410.1748\n“Legendre polynomials” on Wikipedia and Wolfram Math World\n“Associated Legendre polynomials” on Wikipedia and Wolfrm Math World","category":"page"},{"location":"man/references/#bib-healpix-1","page":"References","title":"HEALPix","text":"","category":"section"},{"location":"man/references/#","page":"References","title":"References","text":"K. M. Górski et al. “HEALPix: A Framework for High-Resolution Discretization and Fast Analysis of Data Distributed on the Sphere” In: The Astrophysical Journal 662, 2 (Apr 2005) p. 759–771 DOI: 10.1086/427976. arXiv: astro-ph/0409513\nErratum: The equatorial-belt longitude phi equation (Eq 9) should have the +1 outside the modulus:\n  s = (i - N_mathrmside) operatornamemod 2 + 1","category":"page"},{"location":"man/references/#bib-pixelcovariance-1","page":"References","title":"Pixel Covariance","text":"","category":"section"},{"location":"man/references/#","page":"References","title":"References","text":"M. Tegmark and A. de Oliveira-Costa. “How to measure CMB polarization power spectra without losing information” In: Physical Review D 64, 063001 (Sep 2001) DOI: 10.1103/PhysRevD.64.063001 arXiv: astro-ph/0012120\nThe BICEP/Keck Array Collaboration. “BICEP/Keck Array VII: Matrix Based E/B Separation Applied to BICEP2 and the Keck Array” In: The Astrophysical Journal 825, 66 (Jul 2016) DOI: 10.3847/0004-637X/825/1/66 arXiv: 1603.05976","category":"page"},{"location":"lib/public/#Public-Documentation-1","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"lib/public/#Contents-1","page":"Public","title":"Contents","text":"","category":"section"},{"location":"lib/public/#","page":"Public","title":"Public","text":"Pages = [\"public.md\"]","category":"page"},{"location":"lib/public/#Sphere-Functions-1","page":"Public","title":"Sphere Functions","text":"","category":"section"},{"location":"lib/public/#","page":"Public","title":"Public","text":"Modules = [CMB.Sphere]\nPrivate = false","category":"page"},{"location":"lib/public/#CMB.Sphere","page":"Public","title":"CMB.Sphere","text":"Collection of routines for working with coordinates on the sphere.\n\n\n\n\n\n","category":"module"},{"location":"lib/public/#CMB.Sphere.bearing","page":"Public","title":"CMB.Sphere.bearing","text":"Calculates the bearing angle (α), defined as the angle between the meridian (at the first coordinate) and the great circle connecting the first coordinate to the second. Angles are measured clockwise and will be in the range 0π). See also bearing2.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Sphere.bearing-NTuple{4,Any}","page":"Public","title":"CMB.Sphere.bearing","text":"α = bearing(θ₁, ϕ₁, θ₂, ϕ₂)\n\nPoints on the sphere are given as coordinate pairs (θ₁ϕ₁) and (θ₂ϕ₂) where θ is the colatitude angle from the North Pole and ϕ is the azimuthal angle, both in radians.\n\nExamples\n\njulia> bearing(π/2, 0.0, π/4, π/4)\n0.6154797086703873\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Sphere.bearing-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"Public","title":"CMB.Sphere.bearing","text":"α = bearing(r₁, r₂)\n\nPoints on the sphere are given as unit vectors r₁ and r₂.\n\nExamples\n\njulia> bearing([1.0, 0.0, 0.0], [0.5, 0.5, sqrt(2)/2])\n0.6154797086703873\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Sphere.bearing2","page":"Public","title":"CMB.Sphere.bearing2","text":"Calculates the latitude/longitude vector components of the bearing angle (i.e. δθ = cos(α) δϕ = sin(α)), defined as the angle between the meridian (at the first coordinate) and the great circle connecting the first coordinate to the second. See also bearing.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Sphere.bearing2-NTuple{4,Any}","page":"Public","title":"CMB.Sphere.bearing2","text":"(δθ, δϕ) = bearing2(θ₁, ϕ₁, θ₂, ϕ₂)\n\nPoints on the sphere are given as coordinate pairs (θ₁ϕ₁) and (θ₂ϕ₂) where θ is the colatitude angle from the North Pole and ϕ is the azimuthal angle, both in radians.\n\nExamples\n\njulia> bearing2(π/2, 0.0, π/4, π/4)\n(0.8164965809277261, 0.5773502691896257)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Sphere.bearing2-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"Public","title":"CMB.Sphere.bearing2","text":"(δθ, δϕ) = bearing2(r₁, r₂)\n\nPoints on the sphere are given as unit vectors r₁ and r₂.\n\nExamples\n\njulia> bearing2([1.0, 0.0, 0.0], [0.5, 0.5, sqrt(2)/2])\n(0.816496580927726, 0.5773502691896257)\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Sphere.cosdistance","page":"Public","title":"CMB.Sphere.cosdistance","text":"Calculates the cosine of the inner angle (z) between unit vectors pointing from the center of the sphere to two points on its surface.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Sphere.cosdistance-NTuple{4,Any}","page":"Public","title":"CMB.Sphere.cosdistance","text":"z = cosdistance(θ₁, ϕ₁, θ₂, ϕ₂)\n\nPoints on the sphere are given as coordinate pairs (θ₁ϕ₁) and (θ₂ϕ₂) where θ is the colatitude angle from the North Pole and ϕ is the azimuthal angle, both in radians.\n\nExamples\n\njulia> cosdistance(π/2, 0.0, π/4, π/4)\n0.5\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Sphere.cosdistance-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"Public","title":"CMB.Sphere.cosdistance","text":"z = cosdistance(r₁, r₂)\n\nPoints on the sphere are given as unit vectors r₁ and r₂.\n\nExamples\n\njulia> cosdistance([1.,0.,0.], [0.5,0.5,sqrt(2)/2])\n0.5\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Sphere.distance","page":"Public","title":"CMB.Sphere.distance","text":"Calculates the inner angle (σ) between unit vectors pointing from the center of the sphere to two points on its surface.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Sphere.distance-NTuple{4,Any}","page":"Public","title":"CMB.Sphere.distance","text":"σ = distance(θ₁, ϕ₁, θ₂, ϕ₂)\n\nPoints on the sphere are given as coordinate pairs (θ₁ϕ₁) and (θ₂ϕ₂) where θ is the colatitude angle from the North Pole and ϕ is the azimuthal angle, both in radians.\n\nExamples\n\njulia> distance(π/2, 0.0, π/4, π/4)\n1.0471975511965979\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Sphere.distance-Tuple{AbstractArray{T,1} where T,AbstractArray{T,1} where T}","page":"Public","title":"CMB.Sphere.distance","text":"σ = distance(r₁, r₂)\n\nPoints on the sphere are given as unit vectors r₁ and r₂.\n\nExamples\n\njulia> distance([1.,0.,0.], [0.5,0.5,sqrt(2)/2])\n1.0471975511965979\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Legendre-Functions-1","page":"Public","title":"Legendre Functions","text":"","category":"section"},{"location":"lib/public/#","page":"Public","title":"Public","text":"Modules = [CMB.Legendre]\nPrivate = false","category":"page"},{"location":"lib/public/#CMB.Legendre","page":"Public","title":"CMB.Legendre","text":"Collections of functions which compute the associated Legendre functions.\n\nBased on implementation described in Limpanuparb and Milthorpe (2014) “Associated Legendre Polynomials and Spherical Harmonics Computation for Chemistry Applications” arXiv:1410.1748v1\n\n\n\n\n\n","category":"module"},{"location":"lib/public/#CMB.Legendre.AbstractLegendreNorm","page":"Public","title":"CMB.Legendre.AbstractLegendreNorm","text":"abstract type AbstractLegendreNorm end\n\nAbstract supertype for normalization conditions of the Associated Legendre polynomials.\n\nExample\n\njulia> using InteractiveUtils; subtypes(AbstractLegendreNorm)\n3-element Array{Any,1}:\n LegendreNormCoeff\n LegendreSphereNorm\n LegendreUnitNorm\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CMB.Legendre.LegendreNormCoeff","page":"Public","title":"CMB.Legendre.LegendreNormCoeff","text":"struct LegendreNormCoeff{N<:AbstractLegendreNorm,T<:Real} <: AbstractLegendreNorm\n\nPrecomputed recursion relation coefficients for the normalization N and value type T.\n\nExample\n\njulia> LegendreNormCoeff{LegendreSphereNorm,Float64}(1)\nLegendreNormCoeff{LegendreSphereNorm,Float64} for lmax = 1, mmax = 1 with coefficients:\n    μ: [0.0, 1.22474]\n    ν: [1.73205, 2.23607]\n    α: [0.0 0.0; 1.73205 0.0]\n    β: [0.0 0.0; -0.0 0.0]\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CMB.Legendre.LegendreSphereCoeff","page":"Public","title":"CMB.Legendre.LegendreSphereCoeff","text":"LegendreSphereCoeff{T}\n\nTable type of precomputed recursion relation coefficients for the spherical harmonic normalization. Alias for LegendreNormCoeff{LegendreSphereNorm,T}.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CMB.Legendre.LegendreSphereNorm","page":"Public","title":"CMB.Legendre.LegendreSphereNorm","text":"struct LegendreSphereNorm <: AbstractLegendreNorm end\n\nTrait type denoting the spherical-harmonic normalization of the associated Legendre polynomials.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CMB.Legendre.LegendreUnitCoeff","page":"Public","title":"CMB.Legendre.LegendreUnitCoeff","text":"LegendreUnitCoeff{T}\n\nPrecomputed recursion relation coefficients for the standard unit normalization. Alias for LegendreNormCoeff{LegendreUnitNorm,T}.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CMB.Legendre.LegendreUnitNorm","page":"Public","title":"CMB.Legendre.LegendreUnitNorm","text":"struct LegendreUnitNorm <: AbstractLegendreNorm end\n\nTrait type denoting the unit normalization of the associated Legendre polynomials.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CMB.Legendre.Nlm-Union{Tuple{T}, Tuple{Type{T},Integer,Integer}} where T","page":"Public","title":"CMB.Legendre.Nlm","text":"N = Nlm([T=Float64], l, m)\n\nComputes the normalization constant\n\n    N_ℓ^m  sqrtfrac2ℓ+14π frac(ℓ-m)(ℓ+m)\n\nwhich defines the Spherical Harmonic normalized functions λ_ℓ^m(x) in terms of the standard unit normalized P_ℓ^m(x)\n\n    λ_ℓ^m(x)  N_ℓ^m P_ℓ^m(x)\n\nusing numbers of type T.\n\nSee also Plm and λlm.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Legendre.Pl!-Tuple{Any,Integer,Any}","page":"Public","title":"CMB.Legendre.Pl!","text":"Pl!(P, l::Integer, x)\n\nFills the array P with the unit-normalized Legendre polynomial values P_ℓ(x) for fixed order m = 0; equivalent to legendre!(LegendreUnitNorm(), P, l, 0, x).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Legendre.Pl-Tuple{Integer,Number}","page":"Public","title":"CMB.Legendre.Pl","text":"p = Pl(l::Integer, x::Number)\n\nComputes the Legendre polynomials using unit normalization and for degree m = 0; equivalent to p = legendre(LegendreUnitNorm(), l, 0, x).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Legendre.Plm!-Tuple{Any,Integer,Integer,Any}","page":"Public","title":"CMB.Legendre.Plm!","text":"Plm!(P, l::Integer, m::Integer, x)\n\nFills the array P with the unit-normalized associated Legendre polynomial values P_ℓ^m(x); equivalent to legendre!(LegendreUnitNorm(), P, l, m, x).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Legendre.Plm-Tuple{Integer,Integer,Number}","page":"Public","title":"CMB.Legendre.Plm","text":"p = Plm(l::Integer, m::Integer, x::Number)\n\nComputes the associated Legendre polynomials using unit normalization; equivalent to p = legendre(LegendreUnitNorm(), l, m, x).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Legendre.legendre!-Tuple{AbstractLegendreNorm,Any,Integer,Integer,Any}","page":"Public","title":"CMB.Legendre.legendre!","text":"legendre!(norm::AbstractLegendreNorm, Λ, l::Integer, m::Integer, x)\n\nFills the array Λ with the Legendre polynomial values N_ℓ^m P_ℓ^m(x) up to/of degree l and order m for the normalization scheme norm. Λ must be an array with between 0 and 2 more dimensions than x, with the leading dimensions having the same shape as x.\n\nIf ndims(Λ) == ndims(x), then Λ is filled with the polynomial values at x for degree l and order m.\nIf ndims(Λ) == ndims(x) + 1, then l is interpreted as lmax, and Λ filled with polynomial values for all degrees 0 ≤ l ≤ lmax of order m.\nIf ndims(Λ) == ndims(x) + 2, then l is interpreted as lmax and m as mmax, and Λ is filled with polynomial values for all degrees 0 ≤ l ≤ lmax and orders 0 ≤ m ≤ min(mmax, l).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Legendre.legendre-Tuple{AbstractLegendreNorm,Integer,Integer,Number}","page":"Public","title":"CMB.Legendre.legendre","text":"p = legendre(norm::AbstractLegendreNorm, l::Integer, m::Integer, x::Number)\nP = legendre.(norm::AbstractLegendreNorm, l, m, x)\n\nComputes the associated Legendre polynomial N_ℓ^m P_ℓ^m(x) of degree l and order m at x for the normalization scheme norm.\n\nWith broadcasting syntax, the polynomials can be computed over any iterable x. Furthermore,\n\nIf l isa Integer && m isa Integer, then the output P has the same shape as x and is filled with the polynomial values of order l and degree m.\nIf l isa UnitRange && m isa Integer, then l is interpreted as lmax, and the output P has one more dimension than x with the trailing dimension spanning the degrees 0 ≤ l ≤ lmax.\nIf l isa UnitRange && m isa UnitRange, then l is interpreted as lmax and m as mmax, and the output P has two more dimensions than x with the trailing dimensions spanning the degrees 0 ≤ l ≤ lmax and orders 0 ≤ m ≤ mmax, respectively.\n\nNote that in second and third case, the UnitRanges must satisify first(l) == 0 and first(m) == 0.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Legendre.legendre-Tuple{AbstractLegendreNorm,Integer,Number}","page":"Public","title":"CMB.Legendre.legendre","text":"p = legendre(norm::AbstractLegendreNorm, l::Integer, x::Number)\nP = legendre.(norm::AbstractLegendreNorm, l, x)\n\nComputes the associated Legendre polynomial assuming the order m = 0; equivalent to legendre(norm, l, 0, x) and legendre.(norm, l, 0, x).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Legendre.λlm!-Tuple{Any,Integer,Integer,Any}","page":"Public","title":"CMB.Legendre.λlm!","text":"λlm!(Λ, l::Integer, m::Integer, x)\n\nFills the array Λ with the spherical-harmonic normalized associated Legendre polynomial values λ_ℓ^m(x); equivalent to legendre!(LegendreSphereNorm(), P, l, m, x).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Legendre.λlm-Tuple{Integer,Integer,Number}","page":"Public","title":"CMB.Legendre.λlm","text":"λ = λlm(l::Integer, m::Integer, x::Number)\n\nComputes the associated Legendre polynomials using spherical-harmonic normalization; equivalent to λ = legendre(LegendreSphereNorm(), l, m, x).\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Healpix-1","page":"Public","title":"Healpix","text":"","category":"section"},{"location":"lib/public/#","page":"Public","title":"Public","text":"Modules = [CMB.Healpix]\nPrivate = false","category":"page"},{"location":"lib/public/#CMB.Healpix","page":"Public","title":"CMB.Healpix","text":"A module of functions implementing function which interact with the HEALPix pixel definitions. In most cases, only the RING ordering functions are being provided.\n\nSee \"HEALPix: A Framework for High-Resolution Discretization and Fast Analysis of Data Distributed on the Sphere\" Górski, Hivon, & Banday et al (2005) ApJ 622:759–771 arXiv: astro-ph/0409513\n\n\n\n\n\n","category":"module"},{"location":"lib/public/#CMB.Healpix.UNSEEN","page":"Public","title":"CMB.Healpix.UNSEEN","text":"const UNSEEN = -1.6375e+30\n\nSpecial value recognized by the libhealpix/healpy routines as an unobserved/masked pixel.\n\n\n\n\n\n","category":"constant"},{"location":"lib/public/#CMB.Healpix.InvalidNside","page":"Public","title":"CMB.Healpix.InvalidNside","text":"InvalidNside(nside)\n\nAn invalid nside value was provided.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CMB.Healpix.InvalidPixel","page":"Public","title":"CMB.Healpix.InvalidPixel","text":"InvalidPixel(nside, pix)\n\nAn invalid pixel index pix was provided for the given nside.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CMB.Healpix.checkhealpix-Tuple{Any,Any}","page":"Public","title":"CMB.Healpix.checkhealpix","text":"checkhealpix(nside, pix)\n\nThrows an InvalidNside exception if nside is not a valid value or an InvalidPixel exception if pix is out of range for the given N_mathrmside.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Healpix.checkhealpix-Tuple{Any}","page":"Public","title":"CMB.Healpix.checkhealpix","text":"checkhealpix(nside)\n\nThrows an InvalidNside exception if nside is not a valid value.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Healpix.iscap","page":"Public","title":"CMB.Healpix.iscap","text":"iscap(nside, pix)\n\nTest for whether the given pixel pix is in either polar cap for an nside HEALPix map.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Healpix.isequbelt","page":"Public","title":"CMB.Healpix.isequbelt","text":"isequbelt(nside, pix)\n\nTest for whether the given pixel pix is in the equatorial belt for an nside HEALPix map.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Healpix.ishealpixok-Tuple{Any,Any}","page":"Public","title":"CMB.Healpix.ishealpixok","text":"isheapixok(nside, pix)\n\nReturns true if nside is valid and pix is in the range 0 to nside2npix(nside) - 1, otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Healpix.ishealpixok-Tuple{Any}","page":"Public","title":"CMB.Healpix.ishealpixok","text":"ishealpixok(nside)\n\nReturns true if nside is a power of two in the range 1 to 2^29, otherwise false.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Healpix.isnorth","page":"Public","title":"CMB.Healpix.isnorth","text":"isnorth(nside, pix)\n\nTest for whether the given pixel pix is in the northern hemisphere (including the equatorial ring) for an nside HEALPix map.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Healpix.isnorthcap","page":"Public","title":"CMB.Healpix.isnorthcap","text":"isnorthcap(nside, pix)\n\nTest for whether the given pixel pix is in the northern polar cap for an nside HEALPix map.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Healpix.isnorthequbelt","page":"Public","title":"CMB.Healpix.isnorthequbelt","text":"isnorthequbelt(nside, pix)\n\nTest for whether the given pixel pix is in the northern equatorial belt (including the equatorial ring) for an nside HEALPix map.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Healpix.issouth","page":"Public","title":"CMB.Healpix.issouth","text":"issouth(nside, pix)\n\nTest for whether the given pixel pix is in the southern hemisphere (excluding the equatorial ring) for an nside HEALPix map.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Healpix.issouthcap","page":"Public","title":"CMB.Healpix.issouthcap","text":"issouthcap(nside, pix)\n\nTest for whether the given pixel pix is in the southern polar cap for an nside HEALPix map.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Healpix.issouthequbelt","page":"Public","title":"CMB.Healpix.issouthequbelt","text":"issouthequbelt(nside, pix)\n\nTest for whether the given pixel pix is in the southern equatorial belt (excluding the equatorial ring) for an nside HEALPix map.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Healpix.npix2nside-Tuple{Any}","page":"Public","title":"CMB.Healpix.npix2nside","text":"Nisde = npix2nside(npix)\n\nReturns the equivalent Nside corresponding to the number of pixels npix.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Healpix.nring2nside-Tuple{Any}","page":"Public","title":"CMB.Healpix.nring2nside","text":"Nside = nring2nside(nring)\n\nReturns the equivalent Nside corresponding to the number of iso-latitude rings nring.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Healpix.nside2npix","page":"Public","title":"CMB.Healpix.nside2npix","text":"Npix = nside2npix(nside)\n\nReturns the total number of pixels Npix in an nside HEALPix map. Note that HEALPix pixel indexing is 0-based, so valid pixel values are in the range 0 to Npix - 1.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Healpix.nside2npixcap","page":"Public","title":"CMB.Healpix.nside2npixcap","text":"Npix = nside2npixcap(nside)\n\nReturns the number of pixels Npix in the polar caps for the given nside HEALPix map.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Healpix.nside2npixequ","page":"Public","title":"CMB.Healpix.nside2npixequ","text":"Npix = nside2npixequ(nside)\n\nReturns the number of pixels Npix in the northern hemisphere, including the equatorial ring, for the given nside HEALPix map.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Healpix.nside2nring","page":"Public","title":"CMB.Healpix.nside2nring","text":"Nring = nside2nring(nside)\n\nReturns the number of iso-latitude rings Nring in the nside HEALPix map.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Healpix.nside2pixarea","page":"Public","title":"CMB.Healpix.nside2pixarea","text":"σ = nside2pixarea(nside)\n\nReturns the surface area σ (in steradians) of each pixel in the given nside HEALPix map.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Healpix.pix2ang-Tuple{Any,Any}","page":"Public","title":"CMB.Healpix.pix2ang","text":"(θ,ϕ) = pix2ang(nside, p)\n\nComputes the colatitude and azimuth pair (θ,ϕ) for the given pixel p.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Healpix.pix2phi-Union{Tuple{I}, Tuple{I,I}} where I<:Integer","page":"Public","title":"CMB.Healpix.pix2phi","text":"ϕ = pix2phi(nside, p)\n\nComputes the azimuth ϕ for the given pixel p. nside is the Nside resolution factor.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Healpix.pix2ring-Union{Tuple{I}, Tuple{I,I}} where I<:Integer","page":"Public","title":"CMB.Healpix.pix2ring","text":"i = pix2ring(nside, p)\n\nComputes the ring index i for the given pixel p. nside is the Nside resolution factor.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Healpix.pix2ringidx-Union{Tuple{I}, Tuple{I,I}} where I<:Integer","page":"Public","title":"CMB.Healpix.pix2ringidx","text":"j = pix2ringidx(nside, p)\n\nComputes the index j within the ring for the given pixel p. nside is the Nside resolution factor.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Healpix.pix2theta-Tuple{Any,Any}","page":"Public","title":"CMB.Healpix.pix2theta","text":"θ = pix2theta(nside, p)\n\nComputes the colatitude θ for the given pixel p. nside is the Nside resolution factor.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Healpix.pix2vec-Union{Tuple{I}, Tuple{I,I}} where I<:Integer","page":"Public","title":"CMB.Healpix.pix2vec","text":"r::SVector{3} = pix2vec(nside, p)\n\nComputes the unit vector r pointing to the pixel center of the given pixel p.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Healpix.pix2z-Union{Tuple{I}, Tuple{I,I}} where I<:Integer","page":"Public","title":"CMB.Healpix.pix2z","text":"z = pix2z(nside, p)\n\nComputes the cosine of the colatitude z for the given pixel p. nside is the Nside resolution factor.\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#Pixel-Covariance-1","page":"Public","title":"Pixel Covariance","text":"","category":"section"},{"location":"lib/public/#","page":"Public","title":"Public","text":"Modules = [CMB.PixelCovariance]\nPrivate = false","category":"page"},{"location":"lib/public/#CMB.PixelCovariance","page":"Public","title":"CMB.PixelCovariance","text":"Collection of functions which compute the pixel-pixel covariance of the CMB sky.\n\nBased on equations given in Tegmark and de Oliveira-Costa (2001) “How to measure CMB polarization power spectra without losing information” arXiv:astro-ph/0012120v3\n\n\n\n\n\n","category":"module"},{"location":"lib/public/#CMB.PixelCovariance.PixelCovarianceCache","page":"Public","title":"CMB.PixelCovariance.PixelCovarianceCache","text":"struct PixelCovarianceCache\n\nData structure which contains all the information and buffers required to compute the pixel-pixel covariance terms for a given pixel with respect to all other pixels.\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#CMB.PixelCovariance.PixelCovarianceCoeff","page":"Public","title":"CMB.PixelCovariance.PixelCovarianceCoeff","text":"struct PixelCovarianceCoeff{T<:Real}\n\nPrecomputed recursion relation coefficients for computing the pixel-pixel covariance.\n\nExample\n\njulia> PixelCovarianceCoeff{Float64}(2)\nPixelCovarianceCoeff{Float64} for lmax = 2 with coefficients:\n    λ: LegendreNormCoeff{LegendreUnitNorm,Float64}\n    η: [0.0795775, 0.238732, 0.397887]\n    α: [0.0, 0.0, 0.324874]\n    β: [0.0, 0.0, 0.0331573]\n\n\n\n\n\n","category":"type"},{"location":"lib/public/#Miscellaneous-Utilities-1","page":"Public","title":"Miscellaneous Utilities","text":"","category":"section"},{"location":"lib/public/#","page":"Public","title":"Public","text":"Modules = [CMB.Util]\nPrivate = false","category":"page"},{"location":"lib/public/#CMB.Util","page":"Public","title":"CMB.Util","text":"Miscellaneous utility functions.\n\n\n\n\n\n","category":"module"},{"location":"lib/public/#CMB.Util.outer","page":"Public","title":"CMB.Util.outer","text":"Computes the outer product between a given column of a sparse matrix and a vector.\n\n\n\n\n\n","category":"function"},{"location":"lib/public/#CMB.Util.outer-Union{Tuple{Ti}, Tuple{Tv}, Tuple{AbstractArray{Tv,1},SparseArrays.SparseMatrixCSC{Tv,Ti},Integer}} where Ti where Tv","page":"Public","title":"CMB.Util.outer","text":"outer(w::AbstractVector, A::SparseMatrixCSC, n::Integer)\n\nPerforms the equivalent of vec w veca_n^dagger where vec a_n is the column A[:,n].\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Util.outer-Union{Tuple{Ti}, Tuple{Tv}, Tuple{SparseArrays.SparseMatrixCSC{Tv,Ti},Integer,AbstractArray{Tv,1}}} where Ti where Tv","page":"Public","title":"CMB.Util.outer","text":"outer(A::SparseMatrixCSC, n::Integer, w::AbstractVector)\n\nPerforms the equivalent of vec a_n vec w^dagger where vec a_n is the column A[:,n].\n\n\n\n\n\n","category":"method"},{"location":"lib/public/#CMB.Util.quadprod","page":"Public","title":"CMB.Util.quadprod","text":"quadprod(A, b, n, dir=:col)\n\nComputes the quadratic product ABA^T efficiently for the case where B is all zero except for the nth column or row vector b, for dir = :col or dir = :row, respectively.\n\n\n\n\n\n","category":"function"},{"location":"#CMB.jl-Documentation-1","page":"CMB.jl Documentation","title":"CMB.jl Documentation","text":"","category":"section"},{"location":"#","page":"CMB.jl Documentation","title":"CMB.jl Documentation","text":"CMB.jl is a library of routines for the analysis of cosmic microwave background (CMB) data. Development of features is being driven by the author's use cases — at this time, namely the production of “reobserved” pixel-pixel covariance matrices as used by the BICEP/Keck Array collaboration.","category":"page"},{"location":"#","page":"CMB.jl Documentation","title":"CMB.jl Documentation","text":"Design goals of this package include:","category":"page"},{"location":"#","page":"CMB.jl Documentation","title":"CMB.jl Documentation","text":"Native Julia implementation of core routines.\nNumerical stability and efficiency.\nParallelism and efficient memory sharing.","category":"page"},{"location":"#User-Manual-and-Documentation-1","page":"CMB.jl Documentation","title":"User Manual and Documentation","text":"","category":"section"},{"location":"#","page":"CMB.jl Documentation","title":"CMB.jl Documentation","text":"Pages = [\n    \"man/healpix.md\",\n    \"man/legendre.md\",\n    \"man/references.md\"\n]\nDepth = 1","category":"page"},{"location":"#Library-API-Reference-1","page":"CMB.jl Documentation","title":"Library API Reference","text":"","category":"section"},{"location":"#","page":"CMB.jl Documentation","title":"CMB.jl Documentation","text":"Pages = [\n    \"lib/public.md\",\n    \"lib/private.md\"\n]\nDepth = 1","category":"page"},{"location":"#main-index-1","page":"CMB.jl Documentation","title":"Index","text":"","category":"section"},{"location":"#","page":"CMB.jl Documentation","title":"CMB.jl Documentation","text":"Pages = [\"lib/public.md\"]","category":"page"},{"location":"man/legendre/#Legendre-Polynomials-1","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"","category":"section"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"DocTestFilters = Regex[\n        r\"Ptr{0x[0-9a-f]+}\",\n        r\"[0-9\\.]+ seconds( \\(.*\\))?\",\n        ]","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"Pages = [\"legendre.md\"]\nDepth = 2","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"The Legendre module implementation has been largely based on the approach of Limpanuparb and Milthorpe (2014).","category":"page"},{"location":"man/legendre/#legendre_defn-1","page":"Legendre Polynomials","title":"Definition and Properties","text":"","category":"section"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"The associated Legendre polynomials P_ℓ^m(x) are the solution to the differential equation","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"beginalign\n    (1-x^2) fracd^2dx^2P_ℓ^m(x) - 2x fracddxP_ℓ^m(x) + left ℓ(ℓ+1) -\n        fracm^21-x^2 right P_ℓ^m(x) = 0\nendalign","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"which arises as the colatitude θ part of solving Laplace's equation ^2 ψ + λψ = 0 in spherical coordinates (where x = cos(θ)).","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"There are several different conventions used to define P_ℓ^m that provide different properties, but the convention used here is typical of quantum mechanics and obeys the following properties:","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"Solutions only exist for integer ℓ and m, where ℓ  0 and m  ℓ.\nThe associated Legendre functions are normalized such that P_0^0 is unity and have orthogonality conditions,\nbeginalign\n    int_-1^1 P_ℓ^m(x) P_ℓ^m(x)mathrmdx\n        = frac22ℓ+1 frac(ℓ+m)(ℓ-m)\n        delta_ℓℓ\nendalign\nfor constant m and\nbeginalign\n    int_-1^1 fracP_ℓ^m(x) P_ℓ^m(x)1-x^2mathrmdx\n        = frac1m frac(ℓ+m)(ℓ-m) delta_mm\nendalign\nfor constant ℓ, where δ is the Kronecker delta.\nThe phase convention for the Legendre functions is chosen such that the negative orders are related to positive orders according to,\nbeginalign\n    P_ℓ^-m(x) = (-1)^m frac(ℓ-m)(ℓ+m) P_ℓ^m(x)\nendalign\nThe Legendre functions can be enumerated for non-negative m using the three following recursion relations (given the initial condition P_0^0(x)):\nbeginalign\n    (ℓ - m + 1)P_ℓ+1^m(x) = (2ℓ+1)xP_ℓ^m(x) - (ℓ+m)P_ℓ-1^m(x)\n    labeleqnstd_rr_2term\n    \n    P_ℓ+1^ℓ+1(x) = -(2ℓ+1)sqrt1-x^2 P_ℓ^ℓ(x)\n    labeleqnstd_rr_1term_lm\n    \n    P_ℓ+1^ℓ(x) = x(2ℓ+1)P_ℓ^ℓ(x)\n    labeleqnstd_rr_1term_l\nendalign","category":"page"},{"location":"man/legendre/#legendre_usage-1","page":"Legendre Polynomials","title":"Usage","text":"","category":"section"},{"location":"man/legendre/#Calculating-scalar-values-1","page":"Legendre Polynomials","title":"Calculating scalar values","text":"","category":"section"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"At its simplest, the associated Legendre polynomial P_ℓ^m(x) is computed by calling CMB.Legendre.Plm. For example, to compute P_2^1(05),","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"julia> using CMB.Legendre\n\njulia> Plm(2, 1, 0.5)\n-1.299038105676658","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"When m = 0 and only the Legendre polynomial P_ℓ(x) is needed, CMB.Legendre.Pl can be used instead:","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"julia> Plm(2, 0, 0.5)\n-0.125\n\njulia> Pl(2, 0.5)\n-0.125\n\njulia> Pl(2, 0.5) == Plm(2, 0, 0.5)\ntrue","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"In the context of CMB analysis, a common use of the associated Legendre polynomials is to compute the spherical harmonics Y_ℓm(θϕ):","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"beginalign\n    beginaligned\n    Y_ℓm(θϕ)  (-1)^m N_ℓ^m P_ℓ^m(cos θ) e^imϕ \n    textwhere  N_ℓ^m  sqrtfrac2ℓ+14π frac(ℓ-m)(ℓ+m)\n    endaligned\nendalign","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"The function CMB.Legendre.Nlm calculates the normalization factor N_ℓ^m:","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"julia> Nlm(2, 0)\n0.6307831305050401\n\njulia> Nlm(2, 0) * Plm(2, 0, 0.5)\n-0.07884789131313001","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"An important fact about the associated Legendre polynomials is that for m  0, P_ℓ^m(x) diverges to  as ℓ   [1]. For even moderately large pairs of (ℓm), numerical underflow and overflow make computing the spherical harmonics impossible this way:","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"julia> n = Nlm(157, 150)      # Underflows\n0.0\n\njulia> p = Plm(157, 150, 0.5) # Overflows\nInf\n\njulia> n * p                  # Undefined\nNaN","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"One way around this would be to just use extended precision arithmetic","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"julia> n = Nlm(BigFloat, 157, 150)\n4.14800666209481424285411223457923933542541063872695815968861285171699012214351e-314\n\njulia> p = Plm(157, 150, big\"0.5\")\n4.768286486602206390406601862422168575170463348990958242752608686436785229641823e+308\n\njulia> Float64(n * p)\n1.9778884113202627e-5","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"but at the expense of much more computationally expensive calculations.","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"An alternative way forward is to directly calculate the spherical harmonic normalized associated Legendre polynomials λ_ℓ^m(x) so that the spherical harmonics are defined as","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"beginalign\n    beginaligned\n    Y_ℓm(θϕ) = (-1)^m λ_ℓ^m(cos θ) e^imϕ \n     textwhere  λ_ℓ^m(x)  N_ℓ^m P_ℓ^m(x)\n    endaligned\nendalign","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"CMB.Legendre.λlm implements this scheme and avoids the under/overflow of computing the normalization separately from the function:","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"julia> λlm(157, 150, 0.5)\n1.977888411320258e-5","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"note: Note\nWe are not just limited to efficient and numerically stable computation of λ_ℓ^m(x); the package supports arbitrary normalizations.  For further information on implementing custom Legendre normalizations, see the Custom normalizations section.","category":"page"},{"location":"man/legendre/#Calculating-all-values-up-to-a-given-ℓ_\\mathrm{max}-1","page":"Legendre Polynomials","title":"Calculating all values up to a given ℓ_mathrmmax","text":"","category":"section"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"Because calculating a particular Legendre polynomial value is the end result of running a recurrence relation, looping evaluation of P_ℓ^m(x) for all ℓ is inefficient and redoes a lot of work:","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"julia> λ = zeros(701);\n\njulia> @time λ[3:701] = [λlm(l, 2, 0.5) for l in 2:700];\n  0.063346 seconds (56.42 k allocations: 2.539 MiB)","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"It's far more efficient to accumulate the intermediate terms while running the recurrence relations. Both of Plm and λlm have modifying counterparts, Plm! and λlm! respectively, which fill an appropriately sized vector for a specified ℓ_mathrmmax.","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"julia> @time λlm!(λ, 700, 2, 0.5);\n  0.000162 seconds (14 allocations: 320 bytes)","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"On my machine, this ends up being roughly 400 times faster!","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"If all Legendre polynomial values for some x over all ℓ  0ℓ_mathrmmax and m  0ℓ are required, instead supply an output matrix into which the lower triangle of values is filled:","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"julia> Λ = zeros(701, 701);\n\njulia> λlm!(Λ, 700, 700, 0.5);\n\njulia> Λ[701,3] == λlm(700, 2, 0.5)   # N.B. 1-based indexing of the array!\ntrue","category":"page"},{"location":"man/legendre/#Broadcasting-over-multiple-arguments-1","page":"Legendre Polynomials","title":"Broadcasting over multiple arguments","text":"","category":"section"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"The Legendre polynomials can be evaluated over multiple arguments x as well by using Julia's standard broadcasting syntax:","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"julia> λlm.(2, 0, range(-1.0, 1.0, length=5))\n5-element Array{Float64,1}:\n  0.63078313050504\n -0.07884789131313\n -0.31539156525252\n -0.07884789131313\n  0.63078313050504","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"Broadcasting has been specialized for calls to Pl, Plm, and λlm to avoid the overhead inherent in calling the scalar functions multiple times:","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"julia> z = range(-1.0, 1.0, length=500);\n\njulia> @time [λlm(2, 0, i) for i in z];\n  0.054037 seconds (54.23 k allocations: 2.447 MiB)\n\njulia> @time λlm.(2, 0, z);\n  0.000032 seconds (13 allocations: 36.719 KiB)","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"In fact, the shape of z is preserved, so any matrix shape can be used:","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"julia> λlm.(2, 0, rand(3,3,3))\n3×3×3 Array{Float64,3}:\n[:, :, 1] =\n  0.326489  -0.285639  -0.313698\n  0.46875   -0.241804  -0.310982\n -0.289767  -0.276217  -0.191519\n\n[:, :, 2] =\n  0.580778   -0.251413   0.091097\n  0.0093121   0.468216  -0.00159624\n -0.0402128  -0.288992   0.397937\n\n[:, :, 3] =\n  0.57083   -0.311711  -0.313631\n  0.242235  -0.197404  -0.247441\n -0.107      0.242107  -0.311164","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"Obtaining the Legendre polynomials over multiple ell and/or m values for many arguments can be done via broadcasting as well. The degree l must be a UnitRange starting at zero, and m may be either a scalar integer (to calculate all ell for a fixed m) or a UnitRange starting at zero as well. For example, to compute the P_ell^0(z) and P_ell^2(z) coefficients to an ell_mathrmmax = 700, one could execute","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"julia> summary(Plm.(0:700, 0:2, z))\n\"500×701×3 Array{Float64,3}\"","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"The output array will have between 0 and 2 more dimensions more than the dimensionality of the input arguments depending on the calling convention. For scalar values of l and m, the output will be the same shape as z with no extra trailing dimensions. If instead l is a UnitRange, the output dimensionality increases by one, and the trailing dimension runs over the degrees ell; switching to m a UnitRange as well, the output dimensionality is two greater than z, with the penultimate and final dimensions running over ell and m, respectively.","category":"page"},{"location":"man/legendre/#Precomputed-recursion-factors-1","page":"Legendre Polynomials","title":"Precomputed recursion factors","text":"","category":"section"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"A final trick to accelerating calculation of any normalization of the associated Legendre polynomials is to pre-compute the appropriate recursion relation coefficients.","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"At a low level, Plm/Plm! and λlm/λlm! are simple wrappers around the general legendre/legendre! functions. The trait type LegendreUnitNorm dispatches internal functions to compute P_ℓ^m(x):","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"julia> legendre(LegendreUnitNorm(), 5, 2, 0.5) == Plm(5, 2, 0.5)\ntrue","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"and LegendreSphereNorm does the same for λ_ℓ^m(x):","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"julia> legendre(LegendreSphereNorm(), 5, 2, 0.5) == λlm(5, 2, 0.5)\ntrue","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"The type LegendreNormCoeff stores the coefficients for a particular normalization (and value type) so that the coefficients must only be calculated once. Aliases for the unit and spherical normalizations are provided by default, LegendreUnitCoeff and LegendreSphereCoeff respectively.","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"julia> coeff = LegendreSphereCoeff{Float64}(700);\n\njulia> legendre(coeff, 5, 2, 0.5)\n-0.15888479843070935","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"warning: Performance Note\nChoosing whether to use the pre-computed coefficients or not should be guided by benchmarking and performance profiling. Modern processors can perform many floating point operations in the time it takes to load the coefficients from memory, so depending on the complexity of the normalization, you may actually achieve better performance by recomputing the recursion coefficients on demand.","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"Notice that due to its flexibility, legendre! requires explicit lmax and mmax arguments even though the LegendreNormCoeff has a lmax and mmax set during construction. This allows us to pass both a coefficient cache and output array which are larger than the computed set of coefficients. For example, the output matrix and cache used above each support computing the Legendre polynomials up to ell = 700, but if we only need ell le 2, we can avoid computing terms beyond our required problem size.","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"julia> fill!(Λ, 0);\n\njulia> legendre!(coeff, Λ, 2, 2, 0.5);\n\njulia> Λ[1:5, 1:5]\n5×5 Array{Float64,2}:\n  0.282095    0.0       0.0       0.0  0.0\n  0.244301   -0.299207  0.0       0.0  0.0\n -0.0788479  -0.334523  0.289706  0.0  0.0\n  0.0         0.0       0.0       0.0  0.0\n  0.0         0.0       0.0       0.0  0.0","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"In most situations, though, it'll probably be most convenient to use the functor interface attached to the coefficient cache object which assumes the lmax it was constructed with. The coefficient table itself is callable with forms similar to legendre and legendre! except that the norm and lmax arguments are implicit/not necessary.","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"julia> coeff(20, 0.5)    # == legendre(coeff, 20, 0.5)\n-0.08734916334699527\n\njulia> coeff(20, 2, 0.5) # == legendre(coeff, 20, 2, 0.5)\n0.10617507806374693\n\njulia> leg! = coeff;    # alias to clarify that leg! modifies\n\njulia> leg!(λ, 2, 0.5); # same as legendre!(coeff, λ, size(coeff.α, 1) - 1, 2, 0.5)\n\njulia> leg!(Λ, 0.5);    # same as legendre!(coeff, Λ, (size(coeff.α) .- 1)..., 0.5)","category":"page"},{"location":"man/legendre/#legendre_customnorm-1","page":"Legendre Polynomials","title":"Custom normalizations","text":"","category":"section"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"CMB.Legendre provides the standard and spherical harmonic normalizations by default, but arbitrary normalizations are also supported. The mile-high overview is that the initial condition and recurrence relation (r.r.) coefficients are all methods which dispatch on a normalization trait type, so a new normalization is added by simply extending appropriate types and methods. The following table lists all of the types to extend and method specialization to implement.","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"Interfaces to extend/implement Brief description\nCMB.Legendre.AbstractLegendreNorm Supertype of normalization trait types\nCMB.Legendre.Plm_00() Value of N_0^0 P_0^0(x) for the given normalization\nCMB.Legendre.Plm_μ() Coefficient μ_m for the 1-term r.r. boosting ℓ  ℓ+1 and m  m+1\nCMB.Legendre.Plm_ν() Coefficient ν_m for the 1-term r.r. boosting ℓ  ℓ+1\nCMB.Legendre.Plm_α() Coefficient α_ℓ^m for the 2-term r.r. acting on the (ℓm) term\nCMB.Legendre.Plm_β() Coefficient β_ℓ^m for the 2-term r.r. acting on the (ℓ-1m) term","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"As a concrete example, we'll walk through how λ_ℓ^m(x) is defined to have the spherical harmonic normalization baked in.","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"beginalign\n    λ_ℓ^m(x)  N_ℓ^m P_ℓ^m(x)\n    \n    N_ℓ^m = sqrtfrac2ℓ+14π frac(ℓ-m)(ℓ+m)\nendalign","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"Baking in the normalization happens by changing the coefficients in the recursion relations given in the Definitions and Properties section. For our purposes, they take on the form:","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"beginalign\n    P_ell+1^m(x) = alpha_ell+1^m x P_ell^m(x)\n        - beta_ell+1^m P_ell-1^m(x)\n        labeleqncus_rr_2term\n    \n    P_m+1^m+1(x) = mu_m+1 sqrt1-x^2 P_m^m(x)\n        labeleqncus_rr_1term_lm\n    \n    P_m+1^m(x) = nu_m x P_m^m(x)\n        labeleqncus_rr_1term_l\nendalign","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"The normalization is encoded in the coefficients α_ℓ^m, β_ℓ^m, μ_m, and ν_m. For the standard (unity) normalization, these take on the values","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"beginalign\n    α_ℓ^m = frac2ℓ - 1ℓ - m \n    β_ℓ^m = fracℓ + m - 1ℓ - m \n    μ_m = 2ℓ - 1 \n    ν_m = 2ℓ + 1\nendalign","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"by simply identifying the coefficients from Eqns. refeqnstd_rr_2term–refeqnstd_rr_1term_l on each of the P_ℓ^m(x) terms on the right hand side. For other normalizations, we multiply through by the normalization factor appropriate for the left-hand side of the equations, rearrange terms to correctly normalize the terms on the right, and identify the coefficients left over. For example, α_ℓ^m and β_ℓ^m for λ_ℓ^m(x) are determined by starting with Eq. refeqnstd_rr_2term and multiply through by N_ℓ+1^m. The left-hand side by definition is λ_ℓ+1^m, leaving us with","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"beginalign\n    beginsplit\n        λ_ℓ+1^m = frac2ℓ + 1ℓ - m + 1 x\n            sqrtfrac2ℓ+34π frac(ℓ-m+1)(ℓ+m+1) P_ℓ^m(x) -\n            \n            quadquad fracℓ+mℓ-m+1 sqrtfrac2ℓ+34π\n            frac(ℓ-m+1)(ℓ+m+1) P_ℓ-1^m(x)\n    endsplit\nendalign","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"Through judicious use of algebra, the terms on the right-hand side can be manipulated to gather terms of the form N_ℓ^m P_ℓ^m(x) and N_ℓ-1^m P_ℓ-1^m(x), leaving us with","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"beginalign\n    λ_ℓ+1^m = sqrtfrac2ℓ+32ℓ-1 frac4ℓ^2 - 1(ℓ+1)^2 - m^2 x\n        λ_ℓ^m(x) -\n        sqrtfrac2ℓ+32ℓ-1 fracℓ^2 - m^2(ℓ+1)^2 - m^2\n        λ_ℓ-1^m(x)\nendalign","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"We identify each of the two square root terms as α_ℓ+1^m and β_ℓ+1^m since they are the cofficients appropriate for generating λ_ℓ+1^m(x). Doing so with the other two recurrence relation equations, we obtain:","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"beginalign\n    α_ℓ^m = sqrtfrac2ℓ+12ℓ-3 frac4(ℓ-1)^2 - 1ℓ^2 - m^2 \n    β_ℓ^m = sqrtfrac2ℓ+12ℓ-3 frac(ℓ-1)^2 - m^2ℓ^2 - m^2 \n    μ_m = sqrt1 + frac12m \n    ν_m = sqrt2m + 3\nendalign","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"The final math required is to define the initial condition λ_0^0(x). This is straight forward given the definition:","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"beginalign\n    λ_0^0(x) = N_0^0 P_0^0(x) = sqrtfrac14π  1 \n    λ_0^0(x) = sqrtfrac14π\nendalign","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"We now have all the information required to define a custom Legendre normalization. Begin by importing the types and methods which will need to be extended:","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"julia> using CMB.Legendre\n\njulia> import CMB.Legendre: AbstractLegendreNorm, Plm_00, Plm_μ, Plm_ν, Plm_α, Plm_β","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"We'll call our new normalization λNorm, which must be a subclass of AbstractLegendreNorm.","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"julia> struct λNorm <: AbstractLegendreNorm end","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"The initial condition is specified by providing a method of Plm_00 which takes our normalization trait type as the first argument. (The second argument can be useful if some extra type information is required to set up a type-stable algorithm, which we'll ignore here for the sake of simplicity.)","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"julia> Plm_00(::λNorm, T::Type) = sqrt(1 / 4π)\nPlm_00 (generic function with 4 methods)","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"Finally, we provide methods which encode the cofficients as well:","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"julia> function Plm_α(::λNorm, T::Type, l::Integer, m::Integer)\n           fac1 = (2l + 1) / ((2l - 3) * (l^2 - m^2))\n           fac2 = 4*(l-1)^2 - 1\n           return sqrt(fac1 * fac2)\n       end\nPlm_α (generic function with 4 methods)\n\njulia> function Plm_β(::λNorm, T::Type, l::Integer, m::Integer)\n           fac1 = (2l + 1) / ((2l - 3) * (l^2 - m^2))\n           fac2 = (l-1)^2 - m^2\n           return sqrt(fac1 * fac2)\n       end\nPlm_β (generic function with 4 methods)\n\njulia> Plm_μ(::λNorm, T::Type, m::Integer) = sqrt(1 + 1 / 2m)\nPlm_μ (generic function with 4 methods)\n\njulia> Plm_ν(::λNorm, T::Type, m::Integer) = sqrt(3 + 2m)\nPlm_ν (generic function with 4 methods)","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"With just those 5 methods provided, the full Legendre framework is available, including precomputing the coefficients.","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"julia> legendre(λNorm(), 700, 500, 0.4)\n0.35366224602811\n\njulia> coeff = LegendreNormCoeff{λNorm,Float64}(700);\n\njulia> legendre(coeff, 700, 500, 0.4)\n0.35366224602811","category":"page"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"","category":"page"},{"location":"man/legendre/#Footnotes-1","page":"Legendre Polynomials","title":"Footnotes","text":"","category":"section"},{"location":"man/legendre/#","page":"Legendre Polynomials","title":"Legendre Polynomials","text":"[1]: Specifically, the envelope of P_ℓ^m(x) which bounds the local extrema for all values of x can be shown to be    left P_ℓ^m(cos θ) right  fracΓ(ℓ+m+1)Γ(ℓ+frac32)\n        left( frac2π sin θ right)^12(see Eq. 8.10.7 (p336) of Abramowitz and Stegun, “Handbook of Mathematical Functions” 10th printing (1972)). For fixed m and any x, we take the asymptotic limit as ℓ   and simplify Γ(z) via Stirling's approximation to get the scaling of the associated Legendre polynomial envelope    DeclareMathOperator*envenv\n    env_ℓleft( P_ℓ^m right)  ℓ^m - 12 text In contrast, the normalization factor N_ℓ^m scales as ℓ^12 - m, exactly canceling the scaling of envleft(P_ℓ^mright), so overall the spherical harmonic normalized Legendre polynomials λ_ℓ^m(x) asymptote to some constant envelope:    env_ℓ left( λ_ℓ^m right)  ℓ^0 = textconstant ","category":"page"}]
}

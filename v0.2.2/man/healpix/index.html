<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>HEALPix Pixelization · CMB Analysis</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">CMB Analysis</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">CMB.jl Documentation</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href>HEALPix Pixelization</a><ul class="internal"><li><a class="tocitem" href="#Basic-pixelization-properties-1"><span>Basic pixelization properties</span></a></li><li><a class="tocitem" href="#Working-with-pixel-indices-1"><span>Working with pixel indices</span></a></li><li><a class="tocitem" href="#Working-with-spherical-coordinates-1"><span>Working with spherical coordinates</span></a></li><li><a class="tocitem" href="#Input-validation-and-error-handling-1"><span>Input validation and error handling</span></a></li></ul></li><li><a class="tocitem" href="../sphere/">Spherical Functions</a></li><li><a class="tocitem" href="../references/">References</a></li></ul></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../../lib/public/">Public</a></li><li><a class="tocitem" href="../../lib/private/">Private</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>HEALPix Pixelization</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>HEALPix Pixelization</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jmert/CMB.jl/blob/master/docs/src/man/healpix.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="man_healpix-1"><a class="docs-heading-anchor" href="#man_healpix-1"><code>HEALPix</code> Pixelization</a><a class="docs-heading-anchor-permalink" href="#man_healpix-1" title="Permalink"></a></h1><ul><li><a href="#man_healpix-1"><code>HEALPix</code> Pixelization</a></li><ul><li><a href="#Basic-pixelization-properties-1">Basic pixelization properties</a></li><li><a href="#Working-with-pixel-indices-1">Working with pixel indices</a></li><li><a href="#Working-with-spherical-coordinates-1">Working with spherical coordinates</a></li><li><a href="#Input-validation-and-error-handling-1">Input validation and error handling</a></li></ul></ul><p>The <a href="../../lib/public/#CMB.Healpix"><code>Healpix</code></a> module implements a selection of functions for interacting with the <strong>H</strong>ierarchical <strong>E</strong>qual-<strong>A</strong>rea Iso-<strong>L</strong>atitude <strong>Pix</strong>elization (<code>HEALPix</code>) as described in <a href="../references/#bib-healpix-1">Górski et al. (2005)</a>. The emphasis has been on working with pixel index and spherical coordinate conversions for the RING-ordered scheme only. If a complete <code>HEALPix</code> implementation is required, try <a href="https://github.com/mweastwood/LibHealpix.jl">LibHealpix.jl</a> which provides Julia bindings to the official C++ library or try using the Python <a href="https://github.com/healpy/healpy">healpy</a> interface via <a href="https://github.com/JuliaPy/PyCall.jl">PyCall.jl</a>. Additionally, the <a href="https://github.com/ziotom78/Healpix.jl">Healpix.jl</a> package aims for a complete native Julia reimplementation. <span>$\newcommand{\Nside}{N_\mathrm{side}}$</span></p><h2 id="Basic-pixelization-properties-1"><a class="docs-heading-anchor" href="#Basic-pixelization-properties-1">Basic pixelization properties</a><a class="docs-heading-anchor-permalink" href="#Basic-pixelization-properties-1" title="Permalink"></a></h2><p>A core defining attribute of the <code>HEALPix</code> map is the <span>$\Nside$</span> parameter. The minimum valid value is <span>$\Nside = 1$</span>, representing the coarsest pixelization of the sphere which can be represented by <code>HEALPix</code>. The <span>$\Nside$</span> then increases by factors of two—denoting ever finer resolutions—with the number of pixels covering the sphere being a function of <span>$\Nside$</span> alone. <a href="../../lib/public/#CMB.Healpix.nside2npix"><code>CMB.Healpix.nside2npix</code></a> returns the number of pixels in a given map:</p><pre><code class="language-julia-repl">julia&gt; using CMB.Healpix

julia&gt; nside = 4;

julia&gt; nside2npix(nside)
192</code></pre><p>Because all pixels are of equal area and the number of pixels is derived from only the <span>$\Nside$</span>, the pixel surface area must be as well. For convenience, <a href="../../lib/public/#CMB.Healpix.nside2pixarea"><code>CMB.Healpix.nside2pixarea</code></a> is provided and is equivalent to the simple from-scratch calculation (in steradians).</p><pre><code class="language-julia-repl">julia&gt; 4π / nside2npix(nside)
0.06544984694978735

julia&gt; nside2pixarea(nside)
0.06544984694978735</code></pre><p>The number of iso-latitude rings is also a function of only <span>$\Nside$</span> and calculated by <a href="../../lib/public/#CMB.Healpix.nside2nring"><code>CMB.Healpix.nside2nring</code></a>:</p><pre><code class="language-julia-repl">julia&gt; nside2nring(nside)
15</code></pre><h2 id="Working-with-pixel-indices-1"><a class="docs-heading-anchor" href="#Working-with-pixel-indices-1">Working with pixel indices</a><a class="docs-heading-anchor-permalink" href="#Working-with-pixel-indices-1" title="Permalink"></a></h2><p>The pixels are enumerated as 0-indexed integers from west to east along the iso-latitude rings, from north to south. For example, pixel 0 is the first pixel in the first ring, and pixel 103 is the sixteenth pixel in the eighth ring for an <span>$\Nside = 4$</span> map:</p><pre><code class="language-julia-repl">julia&gt; pix = (0, 103);

julia&gt; pix2ring.(nside, pix)    # Ring
(1, 8)

julia&gt; pix2ringidx.(nside, pix) # Index in ring
(1, 16)</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Be careful to note that pixels are 0-indexed, but the rings and indices within a ring are 1-indexed.</p></div></div><p>The <code>HEALPix</code> grid is symmetric about equator, with the equatorial ring considered part of the northern hemisphere by convention. Membership as part of the northern or southern hemisphere can be tested with the <a href="../../lib/public/#CMB.Healpix.isnorth"><code>CMB.Healpix.isnorth</code></a> and <a href="../../lib/public/#CMB.Healpix.issouth"><code>CMB.Healpix.issouth</code></a> functions, respectively. Pixel 103 is actually the last pixel in the northern hemisphere, so</p><pre><code class="language-julia-repl">julia&gt; isnorth(nside, 103)
true

julia&gt; isnorth(nside, 104)
false

julia&gt; issouth(nside, 104)
true</code></pre><p>In fact, each hemisphere is further composed of a so-called <em>polar cap</em> and <em>equatorial belt</em> region of pixels (a property derived from the mathematical details of the <code>HEALPix</code> grid&#39;s definition). According to the ring-ordered definition, pixel 0 should be in the polar cap (tested via <a href="../../lib/public/#CMB.Healpix.iscap"><code>CMB.Healpix.iscap</code></a>), while pixel 103 in the equatorial ring is expected to be part of the equitorial belt (tested via <a href="../../lib/public/#CMB.Healpix.isequbelt"><code>CMB.Healpix.isequbelt</code></a>).</p><pre><code class="language-julia-repl">julia&gt; iscap.(nside, pix)
(true, false)

julia&gt; isequbelt.(nside, pix)
(false, true)</code></pre><p>Membership in a particular hemisphere&#39;s polar cap or equatorial belt is accomplished with variants inserting <code>north</code> and <code>south</code> into the function names, i.e. polar caps are distinguished by <a href="../../lib/public/#CMB.Healpix.isnorthcap"><code>CMB.Healpix.isnorthcap</code></a> and <a href="../../lib/public/#CMB.Healpix.issouthcap"><code>CMB.Healpix.issouthcap</code></a>, and the halves of the equatorial belt are distinguished by <a href="../../lib/public/#CMB.Healpix.isnorthequbelt"><code>CMB.Healpix.isnorthequbelt</code></a> and <a href="../../lib/public/#CMB.Healpix.issouthequbelt"><code>CMB.Healpix.issouthequbelt</code></a>.</p><pre><code class="language-julia-repl">julia&gt; pix = (0, 103, 104, 191);

julia&gt; isnorthcap.(nside, pix)
(true, false, false, false)

julia&gt; isnorthequbelt.(nside, pix)
(false, true, false, false)

julia&gt; issouthequbelt.(nside, pix)
(false, false, true, false)

julia&gt; issouthcap.(nside, pix)
(false, false, false, true)</code></pre><h2 id="Working-with-spherical-coordinates-1"><a class="docs-heading-anchor" href="#Working-with-spherical-coordinates-1">Working with spherical coordinates</a><a class="docs-heading-anchor-permalink" href="#Working-with-spherical-coordinates-1" title="Permalink"></a></h2><p>Up to now, all the features shown have concerned working with properties of the pixelization scheme, but the utility of the <code>HEALPix</code> grid is its ability to describe the surface of a sphere. Using spherical coordinates is more useful and more natural for more algorithms than the <code>HEALPix</code>-specific indexing scheme.</p><p>The first method of describing the location of a particular <code>HEALPix</code> pixel is as a colatitude/azimuth pair of angles on the surface of the sphere identifying the pixel center. Colatitude measures the angle (in radians) south of the North Pole, and azimuth measures the angle (in radians) east of the Prime Meridian. To get the colatitude, use <a href="../../lib/public/#CMB.Healpix.pix2theta-Tuple{Any,Any}"><code>CMB.Healpix.pix2theta</code></a>,</p><pre><code class="language-julia-repl">julia&gt; pix2theta(nside, 103)
1.5707963267948966</code></pre><p>and to get the azimuth, use <a href="../../lib/public/#CMB.Healpix.pix2phi-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer"><code>CMB.Healpix.pix2phi</code></a></p><pre><code class="language-julia-repl">julia&gt; pix2phi(nside, 103)
6.086835766330224</code></pre><p>(both named to follow the mathematical convention that colatitude/azimuth pairs in spherical coordinates are the variable pair <span>$(θ, ϕ)$</span>). When the coordinate pair is required, the method <a href="../../lib/public/#CMB.Healpix.pix2ang-Tuple{Any,Any}"><code>CMB.Healpix.pix2ang</code></a> returns a 2-tuple with the coordinates:</p><pre><code class="language-julia-repl">julia&gt; pix2ang(nside, 103)
(1.5707963267948966, 6.086835766330224)

julia&gt; pix2ang(nside, 103) .|&gt; rad2deg
(90.0, 348.75)</code></pre><p>The other common way to represent coordinates on the sphere is via unit vectors. The corresponding vector for a given pixel is retrieved with <a href="../../lib/public/#CMB.Healpix.pix2vec-Union{Tuple{I}, Tuple{I,I}} where I&lt;:Integer"><code>CMB.Healpix.pix2vec</code></a>.</p><pre><code class="language-julia-repl">julia&gt; pix2vec(nside, 103)
3-element StaticArrays.SArray{Tuple{3},Float64,1,3} with indices SOneTo(3):
  0.9807852804032303
 -0.19509032201612872
  0.0</code></pre><p>where the elements correspond to the typical <span>$(x, y, z)$</span> right-handed coordinates with the positive <span>$z$</span>-axis passing through the North Pole and the positive <span>$x$</span>-axis passing through the Prime Meridian.</p><p>In reverse, converting an arbitrary spherical coordinate to a pixel index is accomplished via the <a href="../../lib/public/#CMB.Healpix.ang2pix-Tuple{Any,Any,Any}"><code>CMB.Healpix.ang2pix</code></a> and <a href="../../lib/public/#CMB.Healpix.vec2pix-Tuple{Any,Any}"><code>CMB.Healpix.vec2pix</code></a> methods, respectively:</p><pre><code class="language-julia-repl">julia&gt; ang2pix(nside, pix2ang(nside, 103)...)
103

julia&gt; vec2pix(nside, pix2vec(nside, 103))
103</code></pre><h2 id="Input-validation-and-error-handling-1"><a class="docs-heading-anchor" href="#Input-validation-and-error-handling-1">Input validation and error handling</a><a class="docs-heading-anchor-permalink" href="#Input-validation-and-error-handling-1" title="Permalink"></a></h2><p>As stated earlier, the <code>HEALPix</code> <span>$\Nside$</span> parameter takes on values which are powers of two and by convention of the official <code>HEALPix</code> <sup class="footnote-reference"><a id="citeref-1" href="#footnote-1">[1]</a></sup> source is limited to the range <span>$1$</span> to <span>$2^{29}$</span>. Validity of any <code>nside</code> parameter can be checked with the <a href="../../lib/public/#CMB.Healpix.ishealpixok-Tuple{Any}"><code>CMB.Healpix.ishealpixok</code></a> function.</p><pre><code class="language-julia-repl">julia&gt; ishealpixok(4)
true

julia&gt; ishealpixok.((5, 2^30))
(false, false)</code></pre><p>Likewise, once given an <span>$\Nside$</span> value, the pixel indices are bounded in <span>$0$</span> to <code>nside2npix(nside) - 1</code>; the two-argument form of <a href="../../lib/public/#CMB.Healpix.ishealpixok-Tuple{Any,Any}"><code>ishealpixok</code></a> returns whether a pixel is valid for the specified <code>nside</code> or not:</p><pre><code class="language-julia-repl">julia&gt; nside2npix(4)
192

julia&gt; ishealpixok(4, 191)
true

julia&gt; ishealpixok(4, 192)
false</code></pre><p>Variants which throw a <a href="../../lib/public/#CMB.Healpix.InvalidNside"><code>CMB.Healpix.InvalidNside</code></a> or <a href="../../lib/public/#CMB.Healpix.InvalidPixel"><code>CMB.Healpix.InvalidPixel</code></a> error are provided by <a href="../../lib/public/#CMB.Healpix.checkhealpix-Tuple{Any,Any}"><code>CMB.Healpix.checkhealpix</code></a>:</p><pre><code class="language-julia-repl">julia&gt; checkhealpix(5)
ERROR: 5 is not a valid Nside parameter (must be power of 2)
[...]

julia&gt; checkhealpix(4, 192)
ERROR: 192 is not a valid pixel index for Nside = 4 (must be from 0 to 191)
[...]</code></pre><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Only the functions working with spherical coordinates validate their inputs. The pixel indexing and classification functions are considered low-level routines and assume valid inputs. For example,</p><pre><code class="language-julia-repl">julia&gt; nside2npix(5)
300

julia&gt; pix2ring(5, 0)
1

julia&gt; pix2theta(5, 0)
ERROR: 5 is not a valid Nside parameter (must be power of 2)
[...]

julia&gt; isnorth(4, -1)
true

julia&gt; pix2ringidx(4, -1)
0

julia&gt; pix2phi(4, -1)
ERROR: -1 is not a valid pixel index for Nside = 4 (must be from 0 to 191)
[...]</code></pre><p>This choise was made for the sake of computational efficiency — the low-level pixel indexing/classification functions are used internally to compute the spherical coordinates.</p></div></div><hr/><h3 id="Footnotes:-1"><a class="docs-heading-anchor" href="#Footnotes:-1">Footnotes:</a><a class="docs-heading-anchor-permalink" href="#Footnotes:-1" title="Permalink"></a></h3><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-1"><a class="tag is-link" href="#citeref-1">1</a>Official <code>HEALPix</code> package: <a href="http://healpix.sourceforge.net/">http://healpix.sourceforge.net/</a></li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../">« CMB.jl Documentation</a><a class="docs-footer-nextpage" href="../sphere/">Spherical Functions »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Wednesday 8 July 2020 18:18">Wednesday 8 July 2020</span>. Using Julia version 1.2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
